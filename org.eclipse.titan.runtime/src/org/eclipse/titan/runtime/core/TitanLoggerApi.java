/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 ******************************************************************************/
package org.eclipse.titan.runtime.core;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.titan.runtime.core.Base_Template.template_sel;
import org.eclipse.titan.runtime.core.Base_Type.TTCN_Typedescriptor;
import org.eclipse.titan.runtime.core.Optional.optional_sel;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tr_pos;
import org.eclipse.titan.runtime.core.RAW.RAW_enc_tree;
import org.eclipse.titan.runtime.core.RAW.TTCN_RAWdescriptor;
import org.eclipse.titan.runtime.core.RAW.ext_bit_t;
import org.eclipse.titan.runtime.core.RAW.raw_sign_t;
import org.eclipse.titan.runtime.core.RAW.top_bit_order_t;
import org.eclipse.titan.runtime.core.RecordOfMatch.match_function_t;
import org.eclipse.titan.runtime.core.TTCN_EncDec.coding_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.error_type;
import org.eclipse.titan.runtime.core.TTCN_EncDec.raw_order_t;
import org.eclipse.titan.runtime.core.TTCN_Logger.TTCN_Location;
import org.eclipse.titan.runtime.core.TTCN_Logger.TTCN_Location.entity_type_t;
import org.eclipse.titan.runtime.core.TitanCharString.CharCoding;

/**
 * Generated from TitanLoggerApi.xsd
 *
 * @author Kristof Szabados
 */
public final class TitanLoggerApi extends TTCN_Module {
public TitanLoggerApi() {
super("TitanLoggerApi", moduleTypeEnum.TTCN3_MODULE);
}

public static final TTCN_Typedescriptor TitanLog_descr_ = new TTCN_Typedescriptor("TitanLog", null, null);
public static final TTCN_Typedescriptor TitanLog_sequence__list_0_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0", null, null);
public static final TTCN_Typedescriptor TitanLog_sequence__list_0_entityId_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0_entityId", null, null);
public static final TitanUniversalCharString TitanLog_sequence__list_0_entityId_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLog_sequence__list_0_event__list_0_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0_event__list_0", null, null);
public static final TitanUniversalCharString TitanLog_sequence__list_0_event__list_0_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLog_sequence__list_0_event__list_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list_0_event__list", null, null);
public static final TitanUniversalCharString TitanLog_sequence__list_0_event__list_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TitanLog_sequence__list_0_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLog_sequence__list_descr_ = new TTCN_Typedescriptor("TitanLog_sequence__list", null, null);
public static final TitanUniversalCharString TitanLog_sequence__list_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TitanLog_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanSingleLogEvent_descr_ = new TTCN_Typedescriptor("TitanSingleLogEvent", null, null);
public static final TTCN_Typedescriptor TitanSingleLogEvent_entityId_descr_ = new TTCN_Typedescriptor("TitanSingleLogEvent_entityId", null, null);
public static final TitanUniversalCharString TitanSingleLogEvent_entityId_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanSingleLogEvent_event_descr_ = new TTCN_Typedescriptor("TitanSingleLogEvent_event", null, null);
public static final TitanUniversalCharString TitanSingleLogEvent_event_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TitanSingleLogEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLogEvent_descr_ = new TTCN_Typedescriptor("TitanLogEvent", null, null);
public static final TTCN_Typedescriptor TitanLogEvent_timestamp_descr_ = new TTCN_Typedescriptor("TitanLogEvent_timestamp", null, null);
public static final TitanUniversalCharString TitanLogEvent_timestamp_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLogEvent_sourceInfo__list_0_descr_ = new TTCN_Typedescriptor("TitanLogEvent_sourceInfo__list_0", null, null);
public static final TitanUniversalCharString TitanLogEvent_sourceInfo__list_0_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLogEvent_sourceInfo__list_descr_ = new TTCN_Typedescriptor("TitanLogEvent_sourceInfo__list", null, null);
public static final TitanUniversalCharString TitanLogEvent_sourceInfo__list_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor TitanLogEvent_severity_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TitanLogEvent_severity_descr_ = new TTCN_Typedescriptor("TitanLogEvent_severity", TitanLogEvent_severity_raw_, null);
public static final TitanUniversalCharString TitanLogEvent_severity_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TitanLogEvent_logEvent_descr_ = new TTCN_Typedescriptor("TitanLogEvent_logEvent", null, null);
public static final TitanUniversalCharString TitanLogEvent_logEvent_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TitanLogEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimestampType_descr_ = new TTCN_Typedescriptor("TimestampType", null, null);
public static final TTCN_RAWdescriptor TimestampType_seconds_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TimestampType_seconds_descr_ = new TTCN_Typedescriptor("TimestampType_seconds", TimestampType_seconds_raw_, null);
public static final TitanUniversalCharString TimestampType_seconds_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor TimestampType_microSeconds_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TimestampType_microSeconds_descr_ = new TTCN_Typedescriptor("TimestampType_microSeconds", TimestampType_microSeconds_raw_, null);
public static final TitanUniversalCharString TimestampType_microSeconds_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TimestampType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LocationInfo_descr_ = new TTCN_Typedescriptor("LocationInfo", null, null);
public static final TTCN_RAWdescriptor LocationInfo_filename_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor LocationInfo_filename_descr_ = new TTCN_Typedescriptor("LocationInfo_filename", LocationInfo_filename_raw_, null);
public static final TitanUniversalCharString LocationInfo_filename_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor LocationInfo_line_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor LocationInfo_line_descr_ = new TTCN_Typedescriptor("LocationInfo_line", LocationInfo_line_raw_, null);
public static final TitanUniversalCharString LocationInfo_line_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor LocationInfo_ent__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor LocationInfo_ent__name_descr_ = new TTCN_Typedescriptor("LocationInfo_ent__name", LocationInfo_ent__name_raw_, null);
public static final TitanUniversalCharString LocationInfo_ent__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LocationInfo_ent__type_descr_ = new TTCN_Typedescriptor("LocationInfo_ent__type", null, null);
public static final TitanUniversalCharString LocationInfo_ent__type_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString LocationInfo_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ComponentIDType_descr_ = new TTCN_Typedescriptor("ComponentIDType", null, null);
public static final TTCN_RAWdescriptor ComponentIDType_id_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ComponentIDType_id_descr_ = new TTCN_Typedescriptor("ComponentIDType_id", ComponentIDType_id_raw_, null);
public static final TitanUniversalCharString ComponentIDType_id_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ComponentIDType_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ComponentIDType_name_descr_ = new TTCN_Typedescriptor("ComponentIDType_name", ComponentIDType_name_raw_, null);
public static final TitanUniversalCharString ComponentIDType_name_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ComponentIDType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_descr_ = new TTCN_Typedescriptor("LogEventType", null, null);
public static final TTCN_Typedescriptor LogEventType_choice_descr_ = new TTCN_Typedescriptor("LogEventType_choice", null, null);
public static final TTCN_Typedescriptor LogEventType_choice_actionEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_actionEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_actionEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_defaultEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_defaultEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_defaultEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_errorLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_errorLog", null, null);
public static final TitanUniversalCharString LogEventType_choice_errorLog_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_executorEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_executorEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_executorEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_functionEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_functionEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_functionEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_parallelEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_parallelEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_parallelEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_testcaseOp_descr_ = new TTCN_Typedescriptor("LogEventType_choice_testcaseOp", null, null);
public static final TitanUniversalCharString LogEventType_choice_testcaseOp_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_portEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_portEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_portEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_statistics_descr_ = new TTCN_Typedescriptor("LogEventType_choice_statistics", null, null);
public static final TitanUniversalCharString LogEventType_choice_statistics_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_timerEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_timerEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_timerEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_userLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_userLog", null, null);
public static final TitanUniversalCharString LogEventType_choice_userLog_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_verdictOp_descr_ = new TTCN_Typedescriptor("LogEventType_choice_verdictOp", null, null);
public static final TitanUniversalCharString LogEventType_choice_verdictOp_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_warningLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_warningLog", null, null);
public static final TitanUniversalCharString LogEventType_choice_warningLog_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_matchingEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_matchingEvent", null, null);
public static final TitanUniversalCharString LogEventType_choice_matchingEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_debugLog_descr_ = new TTCN_Typedescriptor("LogEventType_choice_debugLog", null, null);
public static final TitanUniversalCharString LogEventType_choice_debugLog_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor LogEventType_choice_executionSummary_descr_ = new TTCN_Typedescriptor("LogEventType_choice_executionSummary", null, null);
public static final TitanUniversalCharString LogEventType_choice_executionSummary_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor LogEventType_choice_unhandledEvent_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor LogEventType_choice_unhandledEvent_descr_ = new TTCN_Typedescriptor("LogEventType_choice_unhandledEvent", LogEventType_choice_unhandledEvent_raw_, null);
public static final TitanUniversalCharString LogEventType_choice_unhandledEvent_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString LogEventType_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString LogEventType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Strings_descr_ = new TTCN_Typedescriptor("Strings", null, null);
public static final TTCN_RAWdescriptor Strings_str__list_0_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Strings_str__list_0_descr_ = new TTCN_Typedescriptor("Strings_str__list_0", Strings_str__list_0_raw_, null);
public static final TitanUniversalCharString Strings_str__list_0_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Strings_str__list_descr_ = new TTCN_Typedescriptor("Strings_str__list", null, null);
public static final TitanUniversalCharString Strings_str__list_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Strings_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Categorized_descr_ = new TTCN_Typedescriptor("Categorized", null, null);
public static final TTCN_RAWdescriptor Categorized_category_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Categorized_category_descr_ = new TTCN_Typedescriptor("Categorized_category", Categorized_category_raw_, null);
public static final TitanUniversalCharString Categorized_category_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Categorized_text_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Categorized_text_descr_ = new TTCN_Typedescriptor("Categorized_text", Categorized_text_raw_, null);
public static final TitanUniversalCharString Categorized_text_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Categorized_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ErrorEvent_descr_ = new TTCN_Typedescriptor("ErrorEvent", null, null);
public static final TTCN_RAWdescriptor ErrorEvent_text_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ErrorEvent_text_descr_ = new TTCN_Typedescriptor("ErrorEvent_text", ErrorEvent_text_raw_, null);
public static final TitanUniversalCharString ErrorEvent_text_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ErrorEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor WarningEvent_descr_ = new TTCN_Typedescriptor("WarningEvent", null, null);
public static final TTCN_RAWdescriptor WarningEvent_text_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor WarningEvent_text_descr_ = new TTCN_Typedescriptor("WarningEvent_text", WarningEvent_text_raw_, null);
public static final TitanUniversalCharString WarningEvent_text_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString WarningEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TestcaseEvent_descr_ = new TTCN_Typedescriptor("TestcaseEvent", null, null);
public static final TTCN_Typedescriptor TestcaseEvent_choice_descr_ = new TTCN_Typedescriptor("TestcaseEvent_choice", null, null);
public static final TTCN_Typedescriptor TestcaseEvent_choice_testcaseStarted_descr_ = new TTCN_Typedescriptor("TestcaseEvent_choice_testcaseStarted", null, null);
public static final TitanUniversalCharString TestcaseEvent_choice_testcaseStarted_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TestcaseEvent_choice_testcaseFinished_descr_ = new TTCN_Typedescriptor("TestcaseEvent_choice_testcaseFinished", null, null);
public static final TitanUniversalCharString TestcaseEvent_choice_testcaseFinished_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TestcaseEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TestcaseEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ParallelEvent_descr_ = new TTCN_Typedescriptor("ParallelEvent", null, null);
public static final TTCN_Typedescriptor ParallelEvent_choice_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice", null, null);
public static final TTCN_Typedescriptor ParallelEvent_choice_parallelPTC_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice_parallelPTC", null, null);
public static final TitanUniversalCharString ParallelEvent_choice_parallelPTC_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ParallelEvent_choice_parallelPTC__exit_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice_parallelPTC__exit", null, null);
public static final TitanUniversalCharString ParallelEvent_choice_parallelPTC__exit_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ParallelEvent_choice_parallelPort_descr_ = new TTCN_Typedescriptor("ParallelEvent_choice_parallelPort", null, null);
public static final TitanUniversalCharString ParallelEvent_choice_parallelPort_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ParallelEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ParallelEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor RandomAction_descr_ = new TTCN_Typedescriptor("RandomAction", null, null);
public static final TitanUniversalCharString RandomAction_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FunctionEvent_descr_ = new TTCN_Typedescriptor("FunctionEvent", null, null);
public static final TTCN_Typedescriptor FunctionEvent_choice_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice", null, null);
public static final TTCN_RAWdescriptor FunctionEvent_choice_unqualified_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FunctionEvent_choice_unqualified_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_unqualified", FunctionEvent_choice_unqualified_raw_, null);
public static final TitanUniversalCharString FunctionEvent_choice_unqualified_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FunctionEvent_choice_random_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random", null, null);
public static final TTCN_Typedescriptor FunctionEvent_choice_random_operation_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random_operation", null, null);
public static final TitanUniversalCharString FunctionEvent_choice_random_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor FunctionEvent_choice_random_retval_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FunctionEvent_choice_random_retval_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random_retval", FunctionEvent_choice_random_retval_raw_, null);
public static final TitanUniversalCharString FunctionEvent_choice_random_retval_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor FunctionEvent_choice_random_intseed_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FunctionEvent_choice_random_intseed_descr_ = new TTCN_Typedescriptor("FunctionEvent_choice_random_intseed", FunctionEvent_choice_random_intseed_raw_, null);
public static final TitanUniversalCharString FunctionEvent_choice_random_intseed_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString FunctionEvent_choice_random_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString FunctionEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString FunctionEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingEvent_descr_ = new TTCN_Typedescriptor("MatchingEvent", null, null);
public static final TTCN_Typedescriptor MatchingEvent_choice_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice", null, null);
public static final TTCN_Typedescriptor MatchingEvent_choice_matchingDone_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingDone", null, null);
public static final TitanUniversalCharString MatchingEvent_choice_matchingDone_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingEvent_choice_matchingSuccess_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingSuccess", null, null);
public static final TitanUniversalCharString MatchingEvent_choice_matchingSuccess_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingEvent_choice_matchingFailure_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingFailure", null, null);
public static final TitanUniversalCharString MatchingEvent_choice_matchingFailure_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingEvent_choice_matchingProblem_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingProblem", null, null);
public static final TitanUniversalCharString MatchingEvent_choice_matchingProblem_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingEvent_choice_matchingTimeout_descr_ = new TTCN_Typedescriptor("MatchingEvent_choice_matchingTimeout", null, null);
public static final TitanUniversalCharString MatchingEvent_choice_matchingTimeout_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerEvent_descr_ = new TTCN_Typedescriptor("TimerEvent", null, null);
public static final TTCN_Typedescriptor TimerEvent_choice_descr_ = new TTCN_Typedescriptor("TimerEvent_choice", null, null);
public static final TTCN_Typedescriptor TimerEvent_choice_readTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_readTimer", null, null);
public static final TitanUniversalCharString TimerEvent_choice_readTimer_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerEvent_choice_startTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_startTimer", null, null);
public static final TitanUniversalCharString TimerEvent_choice_startTimer_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerEvent_choice_guardTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_guardTimer", null, null);
public static final TitanUniversalCharString TimerEvent_choice_guardTimer_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerEvent_choice_stopTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_stopTimer", null, null);
public static final TitanUniversalCharString TimerEvent_choice_stopTimer_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerEvent_choice_timeoutTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_timeoutTimer", null, null);
public static final TitanUniversalCharString TimerEvent_choice_timeoutTimer_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerEvent_choice_timeoutAnyTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_timeoutAnyTimer", null, null);
public static final TitanUniversalCharString TimerEvent_choice_timeoutAnyTimer_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor TimerEvent_choice_unqualifiedTimer_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TimerEvent_choice_unqualifiedTimer_descr_ = new TTCN_Typedescriptor("TimerEvent_choice_unqualifiedTimer", TimerEvent_choice_unqualifiedTimer_raw_, null);
public static final TitanUniversalCharString TimerEvent_choice_unqualifiedTimer_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TimerEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TimerEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor DefaultEvent_descr_ = new TTCN_Typedescriptor("DefaultEvent", null, null);
public static final TTCN_Typedescriptor DefaultEvent_choice_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice", null, null);
public static final TTCN_Typedescriptor DefaultEvent_choice_defaultopActivate_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice_defaultopActivate", null, null);
public static final TitanUniversalCharString DefaultEvent_choice_defaultopActivate_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor DefaultEvent_choice_defaultopDeactivate_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice_defaultopDeactivate", null, null);
public static final TitanUniversalCharString DefaultEvent_choice_defaultopDeactivate_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor DefaultEvent_choice_defaultopExit_descr_ = new TTCN_Typedescriptor("DefaultEvent_choice_defaultopExit", null, null);
public static final TitanUniversalCharString DefaultEvent_choice_defaultopExit_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString DefaultEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString DefaultEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorEvent_descr_ = new TTCN_Typedescriptor("ExecutorEvent", null, null);
public static final TTCN_Typedescriptor ExecutorEvent_choice_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice", null, null);
public static final TTCN_Typedescriptor ExecutorEvent_choice_executorRuntime_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorRuntime", null, null);
public static final TitanUniversalCharString ExecutorEvent_choice_executorRuntime_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorEvent_choice_executorConfigdata_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorConfigdata", null, null);
public static final TitanUniversalCharString ExecutorEvent_choice_executorConfigdata_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorEvent_choice_extcommandStart_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorEvent_choice_extcommandStart_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_extcommandStart", ExecutorEvent_choice_extcommandStart_raw_, null);
public static final TitanUniversalCharString ExecutorEvent_choice_extcommandStart_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorEvent_choice_extcommandSuccess_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorEvent_choice_extcommandSuccess_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_extcommandSuccess", ExecutorEvent_choice_extcommandSuccess_raw_, null);
public static final TitanUniversalCharString ExecutorEvent_choice_extcommandSuccess_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorEvent_choice_executorComponent_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorComponent", null, null);
public static final TitanUniversalCharString ExecutorEvent_choice_executorComponent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorEvent_choice_logOptions_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorEvent_choice_logOptions_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_logOptions", ExecutorEvent_choice_logOptions_raw_, null);
public static final TitanUniversalCharString ExecutorEvent_choice_logOptions_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorEvent_choice_executorMisc_descr_ = new TTCN_Typedescriptor("ExecutorEvent_choice_executorMisc", null, null);
public static final TitanUniversalCharString ExecutorEvent_choice_executorMisc_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutorEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutorEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_descr_ = new TTCN_Typedescriptor("PortEvent", null, null);
public static final TTCN_Typedescriptor PortEvent_choice_descr_ = new TTCN_Typedescriptor("PortEvent_choice", null, null);
public static final TTCN_Typedescriptor PortEvent_choice_portQueue_descr_ = new TTCN_Typedescriptor("PortEvent_choice_portQueue", null, null);
public static final TitanUniversalCharString PortEvent_choice_portQueue_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_portState_descr_ = new TTCN_Typedescriptor("PortEvent_choice_portState", null, null);
public static final TitanUniversalCharString PortEvent_choice_portState_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_procPortSend_descr_ = new TTCN_Typedescriptor("PortEvent_choice_procPortSend", null, null);
public static final TitanUniversalCharString PortEvent_choice_procPortSend_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_procPortRecv_descr_ = new TTCN_Typedescriptor("PortEvent_choice_procPortRecv", null, null);
public static final TitanUniversalCharString PortEvent_choice_procPortRecv_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_msgPortSend_descr_ = new TTCN_Typedescriptor("PortEvent_choice_msgPortSend", null, null);
public static final TitanUniversalCharString PortEvent_choice_msgPortSend_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_msgPortRecv_descr_ = new TTCN_Typedescriptor("PortEvent_choice_msgPortRecv", null, null);
public static final TitanUniversalCharString PortEvent_choice_msgPortRecv_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_dualMapped_descr_ = new TTCN_Typedescriptor("PortEvent_choice_dualMapped", null, null);
public static final TitanUniversalCharString PortEvent_choice_dualMapped_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_dualDiscard_descr_ = new TTCN_Typedescriptor("PortEvent_choice_dualDiscard", null, null);
public static final TitanUniversalCharString PortEvent_choice_dualDiscard_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_setState_descr_ = new TTCN_Typedescriptor("PortEvent_choice_setState", null, null);
public static final TitanUniversalCharString PortEvent_choice_setState_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortEvent_choice_portMisc_descr_ = new TTCN_Typedescriptor("PortEvent_choice_portMisc", null, null);
public static final TitanUniversalCharString PortEvent_choice_portMisc_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString PortEvent_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString PortEvent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerType_descr_ = new TTCN_Typedescriptor("TimerType", null, null);
public static final TTCN_RAWdescriptor TimerType_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TimerType_name_descr_ = new TTCN_Typedescriptor("TimerType_name", TimerType_name_raw_, null);
public static final TitanUniversalCharString TimerType_name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor TimerType_value___raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TimerType_value___descr_ = new TTCN_Typedescriptor("TimerType_value__", TimerType_value___raw_, null);
public static final TitanUniversalCharString TimerType_value___default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TimerType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerGuardType_descr_ = new TTCN_Typedescriptor("TimerGuardType", null, null);
public static final TTCN_RAWdescriptor TimerGuardType_value___raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TimerGuardType_value___descr_ = new TTCN_Typedescriptor("TimerGuardType_value__", TimerGuardType_value___raw_, null);
public static final TitanUniversalCharString TimerGuardType_value___default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TimerGuardType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TimerAnyTimeoutType_descr_ = new TTCN_Typedescriptor("TimerAnyTimeoutType", null, null);
public static final TitanUniversalCharString TimerAnyTimeoutType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor QualifiedName_descr_ = new TTCN_Typedescriptor("QualifiedName", null, null);
public static final TTCN_RAWdescriptor QualifiedName_module__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor QualifiedName_module__name_descr_ = new TTCN_Typedescriptor("QualifiedName_module__name", QualifiedName_module__name_raw_, null);
public static final TitanUniversalCharString QualifiedName_module__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor QualifiedName_testcase__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor QualifiedName_testcase__name_descr_ = new TTCN_Typedescriptor("QualifiedName_testcase__name", QualifiedName_testcase__name_raw_, null);
public static final TitanUniversalCharString QualifiedName_testcase__name_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString QualifiedName_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TestcaseType_descr_ = new TTCN_Typedescriptor("TestcaseType", null, null);
public static final TTCN_Typedescriptor TestcaseType_name_descr_ = new TTCN_Typedescriptor("TestcaseType_name", null, null);
public static final TitanUniversalCharString TestcaseType_name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor TestcaseType_verdict_descr_ = new TTCN_Typedescriptor("TestcaseType_verdict", null, null);
public static final TitanUniversalCharString TestcaseType_verdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor TestcaseType_reason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor TestcaseType_reason_descr_ = new TTCN_Typedescriptor("TestcaseType_reason", TestcaseType_reason_raw_, null);
public static final TitanUniversalCharString TestcaseType_reason_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString TestcaseType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutionSummaryType_descr_ = new TTCN_Typedescriptor("ExecutionSummaryType", null, null);
public static final TTCN_RAWdescriptor ExecutionSummaryType_numberOfTestcases_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutionSummaryType_numberOfTestcases_descr_ = new TTCN_Typedescriptor("ExecutionSummaryType_numberOfTestcases", ExecutionSummaryType_numberOfTestcases_raw_, null);
public static final TitanUniversalCharString ExecutionSummaryType_numberOfTestcases_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutionSummaryType_overallStatistics_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutionSummaryType_overallStatistics_descr_ = new TTCN_Typedescriptor("ExecutionSummaryType_overallStatistics", ExecutionSummaryType_overallStatistics_raw_, null);
public static final TitanUniversalCharString ExecutionSummaryType_overallStatistics_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutionSummaryType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor VerdictOp_descr_ = new TTCN_Typedescriptor("VerdictOp", null, null);
public static final TTCN_Typedescriptor VerdictOp_choice_descr_ = new TTCN_Typedescriptor("VerdictOp_choice", null, null);
public static final TTCN_Typedescriptor VerdictOp_choice_setVerdict_descr_ = new TTCN_Typedescriptor("VerdictOp_choice_setVerdict", null, null);
public static final TitanUniversalCharString VerdictOp_choice_setVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor VerdictOp_choice_getVerdict_descr_ = new TTCN_Typedescriptor("VerdictOp_choice_getVerdict", null, null);
public static final TitanUniversalCharString VerdictOp_choice_getVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor VerdictOp_choice_finalVerdict_descr_ = new TTCN_Typedescriptor("VerdictOp_choice_finalVerdict", null, null);
public static final TitanUniversalCharString VerdictOp_choice_finalVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString VerdictOp_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString VerdictOp_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor StatisticsType_descr_ = new TTCN_Typedescriptor("StatisticsType", null, null);
public static final TTCN_Typedescriptor StatisticsType_choice_descr_ = new TTCN_Typedescriptor("StatisticsType_choice", null, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics", null, null);
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_none___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_none___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_none__", StatisticsType_choice_verdictStatistics_none___raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_none___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_nonePercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_nonePercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_nonePercent", StatisticsType_choice_verdictStatistics_nonePercent_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_nonePercent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_pass___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_pass___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_pass__", StatisticsType_choice_verdictStatistics_pass___raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_pass___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_passPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_passPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_passPercent", StatisticsType_choice_verdictStatistics_passPercent_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_passPercent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_inconc___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_inconc___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_inconc__", StatisticsType_choice_verdictStatistics_inconc___raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_inconc___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_inconcPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_inconcPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_inconcPercent", StatisticsType_choice_verdictStatistics_inconcPercent_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_inconcPercent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_fail___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_fail___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_fail__", StatisticsType_choice_verdictStatistics_fail___raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_fail___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_failPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_failPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_failPercent", StatisticsType_choice_verdictStatistics_failPercent_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_failPercent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_error___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_error___descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_error__", StatisticsType_choice_verdictStatistics_error___raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_error___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_verdictStatistics_errorPercent_raw_ = new TTCN_RAWdescriptor(64,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_verdictStatistics_errorPercent_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_verdictStatistics_errorPercent", StatisticsType_choice_verdictStatistics_errorPercent_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_errorPercent_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString StatisticsType_choice_verdictStatistics_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_controlpartStart_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_controlpartStart_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_controlpartStart", StatisticsType_choice_controlpartStart_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_controlpartStart_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_controlpartFinish_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_controlpartFinish_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_controlpartFinish", StatisticsType_choice_controlpartFinish_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_controlpartFinish_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StatisticsType_choice_controlpartErrors_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StatisticsType_choice_controlpartErrors_descr_ = new TTCN_Typedescriptor("StatisticsType_choice_controlpartErrors", StatisticsType_choice_controlpartErrors_raw_, null);
public static final TitanUniversalCharString StatisticsType_choice_controlpartErrors_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString StatisticsType_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString StatisticsType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor SetVerdictType_descr_ = new TTCN_Typedescriptor("SetVerdictType", null, null);
public static final TTCN_Typedescriptor SetVerdictType_newVerdict_descr_ = new TTCN_Typedescriptor("SetVerdictType_newVerdict", null, null);
public static final TitanUniversalCharString SetVerdictType_newVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor SetVerdictType_oldVerdict_descr_ = new TTCN_Typedescriptor("SetVerdictType_oldVerdict", null, null);
public static final TitanUniversalCharString SetVerdictType_oldVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor SetVerdictType_localVerdict_descr_ = new TTCN_Typedescriptor("SetVerdictType_localVerdict", null, null);
public static final TitanUniversalCharString SetVerdictType_localVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor SetVerdictType_oldReason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor SetVerdictType_oldReason_descr_ = new TTCN_Typedescriptor("SetVerdictType_oldReason", SetVerdictType_oldReason_raw_, null);
public static final TitanUniversalCharString SetVerdictType_oldReason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor SetVerdictType_newReason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor SetVerdictType_newReason_descr_ = new TTCN_Typedescriptor("SetVerdictType_newReason", SetVerdictType_newReason_raw_, null);
public static final TitanUniversalCharString SetVerdictType_newReason_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString SetVerdictType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor VerdictType_descr_ = new TTCN_Typedescriptor("VerdictType", null, null);
public static final TTCN_Typedescriptor VerdictType_fromVerdict_descr_ = new TTCN_Typedescriptor("VerdictType_fromVerdict", null, null);
public static final TitanUniversalCharString VerdictType_fromVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor VerdictType_toVerdict_descr_ = new TTCN_Typedescriptor("VerdictType_toVerdict", null, null);
public static final TitanUniversalCharString VerdictType_toVerdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor VerdictType_verdictReason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor VerdictType_verdictReason_descr_ = new TTCN_Typedescriptor("VerdictType_verdictReason", VerdictType_verdictReason_raw_, null);
public static final TitanUniversalCharString VerdictType_verdictReason_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString VerdictType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FinalVerdictType_descr_ = new TTCN_Typedescriptor("FinalVerdictType", null, null);
public static final TTCN_Typedescriptor FinalVerdictType_choice_descr_ = new TTCN_Typedescriptor("FinalVerdictType_choice", null, null);
public static final TTCN_Typedescriptor FinalVerdictType_choice_info_descr_ = new TTCN_Typedescriptor("FinalVerdictType_choice_info", null, null);
public static final TitanUniversalCharString FinalVerdictType_choice_info_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FinalVerdictType_choice_notification_descr_ = new TTCN_Typedescriptor("FinalVerdictType_choice_notification", null, null);
public static final TitanUniversalCharString FinalVerdictType_choice_notification_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString FinalVerdictType_choice_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString FinalVerdictType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FinalVerdictInfo_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo", null, null);
public static final TTCN_RAWdescriptor FinalVerdictInfo_is__ptc_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FinalVerdictInfo_is__ptc_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_is__ptc", FinalVerdictInfo_is__ptc_raw_, null);
public static final TitanUniversalCharString FinalVerdictInfo_is__ptc_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FinalVerdictInfo_ptc__verdict_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_ptc__verdict", null, null);
public static final TitanUniversalCharString FinalVerdictInfo_ptc__verdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FinalVerdictInfo_local__verdict_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_local__verdict", null, null);
public static final TitanUniversalCharString FinalVerdictInfo_local__verdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor FinalVerdictInfo_new__verdict_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_new__verdict", null, null);
public static final TitanUniversalCharString FinalVerdictInfo_new__verdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor FinalVerdictInfo_verdict__reason_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FinalVerdictInfo_verdict__reason_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_verdict__reason", FinalVerdictInfo_verdict__reason_raw_, null);
public static final TitanUniversalCharString FinalVerdictInfo_verdict__reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor FinalVerdictInfo_ptc__compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FinalVerdictInfo_ptc__compref_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_ptc__compref", FinalVerdictInfo_ptc__compref_raw_, null);
public static final TitanUniversalCharString FinalVerdictInfo_ptc__compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor FinalVerdictInfo_ptc__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor FinalVerdictInfo_ptc__name_descr_ = new TTCN_Typedescriptor("FinalVerdictInfo_ptc__name", FinalVerdictInfo_ptc__name_raw_, null);
public static final TitanUniversalCharString FinalVerdictInfo_ptc__name_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString FinalVerdictInfo_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Verdict_descr_ = new TTCN_Typedescriptor("Verdict", null, null);
public static final TitanUniversalCharString Verdict_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor DefaultOp_descr_ = new TTCN_Typedescriptor("DefaultOp", null, null);
public static final TTCN_RAWdescriptor DefaultOp_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor DefaultOp_name_descr_ = new TTCN_Typedescriptor("DefaultOp_name", DefaultOp_name_raw_, null);
public static final TitanUniversalCharString DefaultOp_name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor DefaultOp_id_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor DefaultOp_id_descr_ = new TTCN_Typedescriptor("DefaultOp_id", DefaultOp_id_raw_, null);
public static final TitanUniversalCharString DefaultOp_id_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor DefaultOp_end_descr_ = new TTCN_Typedescriptor("DefaultOp_end", null, null);
public static final TitanUniversalCharString DefaultOp_end_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString DefaultOp_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor DefaultEnd_descr_ = new TTCN_Typedescriptor("DefaultEnd", null, null);
public static final TitanUniversalCharString DefaultEnd_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PortType_descr_ = new TTCN_Typedescriptor("PortType", null, null);
public static final TitanUniversalCharString PortType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingSuccessType_descr_ = new TTCN_Typedescriptor("MatchingSuccessType", null, null);
public static final TTCN_Typedescriptor MatchingSuccessType_port__type_descr_ = new TTCN_Typedescriptor("MatchingSuccessType_port__type", null, null);
public static final TitanUniversalCharString MatchingSuccessType_port__type_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingSuccessType_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingSuccessType_port__name_descr_ = new TTCN_Typedescriptor("MatchingSuccessType_port__name", MatchingSuccessType_port__name_raw_, null);
public static final TitanUniversalCharString MatchingSuccessType_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingSuccessType_info_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingSuccessType_info_descr_ = new TTCN_Typedescriptor("MatchingSuccessType_info", MatchingSuccessType_info_raw_, null);
public static final TitanUniversalCharString MatchingSuccessType_info_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingSuccessType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingFailureType_descr_ = new TTCN_Typedescriptor("MatchingFailureType", null, null);
public static final TTCN_Typedescriptor MatchingFailureType_port__type_descr_ = new TTCN_Typedescriptor("MatchingFailureType_port__type", null, null);
public static final TitanUniversalCharString MatchingFailureType_port__type_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingFailureType_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingFailureType_port__name_descr_ = new TTCN_Typedescriptor("MatchingFailureType_port__name", MatchingFailureType_port__name_raw_, null);
public static final TitanUniversalCharString MatchingFailureType_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingFailureType_choice_descr_ = new TTCN_Typedescriptor("MatchingFailureType_choice", null, null);
public static final TTCN_RAWdescriptor MatchingFailureType_choice_system___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingFailureType_choice_system___descr_ = new TTCN_Typedescriptor("MatchingFailureType_choice_system__", MatchingFailureType_choice_system___raw_, null);
public static final TitanUniversalCharString MatchingFailureType_choice_system___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingFailureType_choice_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingFailureType_choice_compref_descr_ = new TTCN_Typedescriptor("MatchingFailureType_choice_compref", MatchingFailureType_choice_compref_raw_, null);
public static final TitanUniversalCharString MatchingFailureType_choice_compref_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingFailureType_choice_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingFailureType_reason_descr_ = new TTCN_Typedescriptor("MatchingFailureType_reason", null, null);
public static final TitanUniversalCharString MatchingFailureType_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingFailureType_info_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingFailureType_info_descr_ = new TTCN_Typedescriptor("MatchingFailureType_info", MatchingFailureType_info_raw_, null);
public static final TitanUniversalCharString MatchingFailureType_info_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingFailureType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingProblemType_descr_ = new TTCN_Typedescriptor("MatchingProblemType", null, null);
public static final TTCN_RAWdescriptor MatchingProblemType_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingProblemType_port__name_descr_ = new TTCN_Typedescriptor("MatchingProblemType_port__name", MatchingProblemType_port__name_raw_, null);
public static final TitanUniversalCharString MatchingProblemType_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingProblemType_reason_descr_ = new TTCN_Typedescriptor("MatchingProblemType_reason", null, null);
public static final TitanUniversalCharString MatchingProblemType_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingProblemType_operation_descr_ = new TTCN_Typedescriptor("MatchingProblemType_operation", null, null);
public static final TitanUniversalCharString MatchingProblemType_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingProblemType_check___raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingProblemType_check___descr_ = new TTCN_Typedescriptor("MatchingProblemType_check__", MatchingProblemType_check___raw_, null);
public static final TitanUniversalCharString MatchingProblemType_check___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingProblemType_any__port_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingProblemType_any__port_descr_ = new TTCN_Typedescriptor("MatchingProblemType_any__port", MatchingProblemType_any__port_raw_, null);
public static final TitanUniversalCharString MatchingProblemType_any__port_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingProblemType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingDoneType_descr_ = new TTCN_Typedescriptor("MatchingDoneType", null, null);
public static final TTCN_Typedescriptor MatchingDoneType_reason_descr_ = new TTCN_Typedescriptor("MatchingDoneType_reason", null, null);
public static final TitanUniversalCharString MatchingDoneType_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingDoneType_type___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingDoneType_type___descr_ = new TTCN_Typedescriptor("MatchingDoneType_type__", MatchingDoneType_type___raw_, null);
public static final TitanUniversalCharString MatchingDoneType_type___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingDoneType_ptc_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingDoneType_ptc_descr_ = new TTCN_Typedescriptor("MatchingDoneType_ptc", MatchingDoneType_ptc_raw_, null);
public static final TitanUniversalCharString MatchingDoneType_ptc_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor MatchingDoneType_return__type_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingDoneType_return__type_descr_ = new TTCN_Typedescriptor("MatchingDoneType_return__type", MatchingDoneType_return__type_raw_, null);
public static final TitanUniversalCharString MatchingDoneType_return__type_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingDoneType_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor MatchingTimeout_descr_ = new TTCN_Typedescriptor("MatchingTimeout", null, null);
public static final TTCN_RAWdescriptor MatchingTimeout_timer__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor MatchingTimeout_timer__name_descr_ = new TTCN_Typedescriptor("MatchingTimeout_timer__name", MatchingTimeout_timer__name_raw_, null);
public static final TitanUniversalCharString MatchingTimeout_timer__name_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString MatchingTimeout_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorRuntime_descr_ = new TTCN_Typedescriptor("ExecutorRuntime", null, null);
public static final TTCN_Typedescriptor ExecutorRuntime_reason_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_reason", null, null);
public static final TitanUniversalCharString ExecutorRuntime_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorRuntime_module__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorRuntime_module__name_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_module__name", ExecutorRuntime_module__name_raw_, null);
public static final TitanUniversalCharString ExecutorRuntime_module__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorRuntime_testcase__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorRuntime_testcase__name_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_testcase__name", ExecutorRuntime_testcase__name_raw_, null);
public static final TitanUniversalCharString ExecutorRuntime_testcase__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorRuntime_pid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorRuntime_pid_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_pid", ExecutorRuntime_pid_raw_, null);
public static final TitanUniversalCharString ExecutorRuntime_pid_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorRuntime_fd__setsize_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorRuntime_fd__setsize_descr_ = new TTCN_Typedescriptor("ExecutorRuntime_fd__setsize", ExecutorRuntime_fd__setsize_raw_, null);
public static final TitanUniversalCharString ExecutorRuntime_fd__setsize_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutorRuntime_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorUnqualified_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified", null, null);
public static final TTCN_Typedescriptor ExecutorUnqualified_reason_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_reason", null, null);
public static final TitanUniversalCharString ExecutorUnqualified_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorUnqualified_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorUnqualified_name_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_name", ExecutorUnqualified_name_raw_, null);
public static final TitanUniversalCharString ExecutorUnqualified_name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorUnqualified_addr_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorUnqualified_addr_descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_addr", ExecutorUnqualified_addr_raw_, null);
public static final TitanUniversalCharString ExecutorUnqualified_addr_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorUnqualified_port___raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorUnqualified_port___descr_ = new TTCN_Typedescriptor("ExecutorUnqualified_port__", ExecutorUnqualified_port___raw_, null);
public static final TitanUniversalCharString ExecutorUnqualified_port___default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutorUnqualified_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorConfigdata_descr_ = new TTCN_Typedescriptor("ExecutorConfigdata", null, null);
public static final TTCN_Typedescriptor ExecutorConfigdata_reason_descr_ = new TTCN_Typedescriptor("ExecutorConfigdata_reason", null, null);
public static final TitanUniversalCharString ExecutorConfigdata_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorConfigdata_param___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorConfigdata_param___descr_ = new TTCN_Typedescriptor("ExecutorConfigdata_param__", ExecutorConfigdata_param___raw_, null);
public static final TitanUniversalCharString ExecutorConfigdata_param___default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutorConfigdata_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ExecutorComponent_descr_ = new TTCN_Typedescriptor("ExecutorComponent", null, null);
public static final TTCN_Typedescriptor ExecutorComponent_reason_descr_ = new TTCN_Typedescriptor("ExecutorComponent_reason", null, null);
public static final TitanUniversalCharString ExecutorComponent_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ExecutorComponent_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ExecutorComponent_compref_descr_ = new TTCN_Typedescriptor("ExecutorComponent_compref", ExecutorComponent_compref_raw_, null);
public static final TitanUniversalCharString ExecutorComponent_compref_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ExecutorComponent_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ParallelPTC_descr_ = new TTCN_Typedescriptor("ParallelPTC", null, null);
public static final TTCN_Typedescriptor ParallelPTC_reason_descr_ = new TTCN_Typedescriptor("ParallelPTC_reason", null, null);
public static final TitanUniversalCharString ParallelPTC_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_module___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_module___descr_ = new TTCN_Typedescriptor("ParallelPTC_module__", ParallelPTC_module___raw_, null);
public static final TitanUniversalCharString ParallelPTC_module___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_name_descr_ = new TTCN_Typedescriptor("ParallelPTC_name", ParallelPTC_name_raw_, null);
public static final TitanUniversalCharString ParallelPTC_name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_compref_descr_ = new TTCN_Typedescriptor("ParallelPTC_compref", ParallelPTC_compref_raw_, null);
public static final TitanUniversalCharString ParallelPTC_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_compname_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_compname_descr_ = new TTCN_Typedescriptor("ParallelPTC_compname", ParallelPTC_compname_raw_, null);
public static final TitanUniversalCharString ParallelPTC_compname_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_tc__loc_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_tc__loc_descr_ = new TTCN_Typedescriptor("ParallelPTC_tc__loc", ParallelPTC_tc__loc_raw_, null);
public static final TitanUniversalCharString ParallelPTC_tc__loc_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_alive__pid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_alive__pid_descr_ = new TTCN_Typedescriptor("ParallelPTC_alive__pid", ParallelPTC_alive__pid_raw_, null);
public static final TitanUniversalCharString ParallelPTC_alive__pid_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParallelPTC_status_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParallelPTC_status_descr_ = new TTCN_Typedescriptor("ParallelPTC_status", ParallelPTC_status_raw_, null);
public static final TitanUniversalCharString ParallelPTC_status_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ParallelPTC_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Parallel_descr_ = new TTCN_Typedescriptor("Parallel", null, null);
public static final TTCN_Typedescriptor Parallel_reason_descr_ = new TTCN_Typedescriptor("Parallel_reason", null, null);
public static final TitanUniversalCharString Parallel_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Parallel_alive___raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Parallel_alive___descr_ = new TTCN_Typedescriptor("Parallel_alive__", Parallel_alive___raw_, null);
public static final TitanUniversalCharString Parallel_alive___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Parallel_function__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Parallel_function__name_descr_ = new TTCN_Typedescriptor("Parallel_function__name", Parallel_function__name_raw_, null);
public static final TitanUniversalCharString Parallel_function__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Parallel_src__compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Parallel_src__compref_descr_ = new TTCN_Typedescriptor("Parallel_src__compref", Parallel_src__compref_raw_, null);
public static final TitanUniversalCharString Parallel_src__compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Parallel_src__port_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Parallel_src__port_descr_ = new TTCN_Typedescriptor("Parallel_src__port", Parallel_src__port_raw_, null);
public static final TitanUniversalCharString Parallel_src__port_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Parallel_dst__compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Parallel_dst__compref_descr_ = new TTCN_Typedescriptor("Parallel_dst__compref", Parallel_dst__compref_raw_, null);
public static final TitanUniversalCharString Parallel_dst__compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Parallel_dst__port_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Parallel_dst__port_descr_ = new TTCN_Typedescriptor("Parallel_dst__port", Parallel_dst__port_raw_, null);
public static final TitanUniversalCharString Parallel_dst__port_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Parallel_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor StartFunction_descr_ = new TTCN_Typedescriptor("StartFunction", null, null);
public static final TTCN_RAWdescriptor StartFunction_function__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StartFunction_function__name_descr_ = new TTCN_Typedescriptor("StartFunction_function__name", StartFunction_function__name_raw_, null);
public static final TitanUniversalCharString StartFunction_function__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StartFunction_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StartFunction_compref_descr_ = new TTCN_Typedescriptor("StartFunction_compref", StartFunction_compref_raw_, null);
public static final TitanUniversalCharString StartFunction_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor StartFunction_parameter__list_0_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor StartFunction_parameter__list_0_descr_ = new TTCN_Typedescriptor("StartFunction_parameter__list_0", StartFunction_parameter__list_0_raw_, null);
public static final TitanUniversalCharString StartFunction_parameter__list_0_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor StartFunction_parameter__list_descr_ = new TTCN_Typedescriptor("StartFunction_parameter__list", null, null);
public static final TitanUniversalCharString StartFunction_parameter__list_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString StartFunction_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor PTC__exit_descr_ = new TTCN_Typedescriptor("PTC__exit", null, null);
public static final TTCN_RAWdescriptor PTC__exit_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor PTC__exit_compref_descr_ = new TTCN_Typedescriptor("PTC__exit_compref", PTC__exit_compref_raw_, null);
public static final TitanUniversalCharString PTC__exit_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor PTC__exit_pid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor PTC__exit_pid_descr_ = new TTCN_Typedescriptor("PTC__exit_pid", PTC__exit_pid_raw_, null);
public static final TitanUniversalCharString PTC__exit_pid_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor PTC__exit_statuscode_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor PTC__exit_statuscode_descr_ = new TTCN_Typedescriptor("PTC__exit_statuscode", PTC__exit_statuscode_raw_, null);
public static final TitanUniversalCharString PTC__exit_statuscode_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString PTC__exit_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor ParPort_descr_ = new TTCN_Typedescriptor("ParPort", null, null);
public static final TTCN_Typedescriptor ParPort_operation_descr_ = new TTCN_Typedescriptor("ParPort_operation", null, null);
public static final TitanUniversalCharString ParPort_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParPort_srcCompref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParPort_srcCompref_descr_ = new TTCN_Typedescriptor("ParPort_srcCompref", ParPort_srcCompref_raw_, null);
public static final TitanUniversalCharString ParPort_srcCompref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParPort_dstCompref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParPort_dstCompref_descr_ = new TTCN_Typedescriptor("ParPort_dstCompref", ParPort_dstCompref_raw_, null);
public static final TitanUniversalCharString ParPort_dstCompref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParPort_srcPort_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParPort_srcPort_descr_ = new TTCN_Typedescriptor("ParPort_srcPort", ParPort_srcPort_raw_, null);
public static final TitanUniversalCharString ParPort_srcPort_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor ParPort_dstPort_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor ParPort_dstPort_descr_ = new TTCN_Typedescriptor("ParPort_dstPort", ParPort_dstPort_raw_, null);
public static final TitanUniversalCharString ParPort_dstPort_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString ParPort_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Port__Queue_descr_ = new TTCN_Typedescriptor("Port__Queue", null, null);
public static final TTCN_Typedescriptor Port__Queue_operation_descr_ = new TTCN_Typedescriptor("Port__Queue_operation", null, null);
public static final TitanUniversalCharString Port__Queue_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Queue_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Queue_port__name_descr_ = new TTCN_Typedescriptor("Port__Queue_port__name", Port__Queue_port__name_raw_, null);
public static final TitanUniversalCharString Port__Queue_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Queue_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Queue_compref_descr_ = new TTCN_Typedescriptor("Port__Queue_compref", Port__Queue_compref_raw_, null);
public static final TitanUniversalCharString Port__Queue_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Queue_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Queue_msgid_descr_ = new TTCN_Typedescriptor("Port__Queue_msgid", Port__Queue_msgid_raw_, null);
public static final TitanUniversalCharString Port__Queue_msgid_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Queue_address___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Queue_address___descr_ = new TTCN_Typedescriptor("Port__Queue_address__", Port__Queue_address___raw_, null);
public static final TitanUniversalCharString Port__Queue_address___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Queue_param___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Queue_param___descr_ = new TTCN_Typedescriptor("Port__Queue_param__", Port__Queue_param___raw_, null);
public static final TitanUniversalCharString Port__Queue_param___default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Port__Queue_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Port__State_descr_ = new TTCN_Typedescriptor("Port__State", null, null);
public static final TTCN_Typedescriptor Port__State_operation_descr_ = new TTCN_Typedescriptor("Port__State_operation", null, null);
public static final TitanUniversalCharString Port__State_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__State_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__State_port__name_descr_ = new TTCN_Typedescriptor("Port__State_port__name", Port__State_port__name_raw_, null);
public static final TitanUniversalCharString Port__State_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Port__State_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Port__oper_descr_ = new TTCN_Typedescriptor("Port__oper", null, null);
public static final TitanUniversalCharString Port__oper_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Proc__port__out_descr_ = new TTCN_Typedescriptor("Proc__port__out", null, null);
public static final TTCN_RAWdescriptor Proc__port__out_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__out_port__name_descr_ = new TTCN_Typedescriptor("Proc__port__out_port__name", Proc__port__out_port__name_raw_, null);
public static final TitanUniversalCharString Proc__port__out_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Proc__port__out_operation_descr_ = new TTCN_Typedescriptor("Proc__port__out_operation", null, null);
public static final TitanUniversalCharString Proc__port__out_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__out_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__out_compref_descr_ = new TTCN_Typedescriptor("Proc__port__out_compref", Proc__port__out_compref_raw_, null);
public static final TitanUniversalCharString Proc__port__out_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__out_sys__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__out_sys__name_descr_ = new TTCN_Typedescriptor("Proc__port__out_sys__name", Proc__port__out_sys__name_raw_, null);
public static final TitanUniversalCharString Proc__port__out_sys__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__out_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__out_parameter_descr_ = new TTCN_Typedescriptor("Proc__port__out_parameter", Proc__port__out_parameter_raw_, null);
public static final TitanUniversalCharString Proc__port__out_parameter_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Proc__port__out_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Proc__port__in_descr_ = new TTCN_Typedescriptor("Proc__port__in", null, null);
public static final TTCN_RAWdescriptor Proc__port__in_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__in_port__name_descr_ = new TTCN_Typedescriptor("Proc__port__in_port__name", Proc__port__in_port__name_raw_, null);
public static final TitanUniversalCharString Proc__port__in_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Proc__port__in_operation_descr_ = new TTCN_Typedescriptor("Proc__port__in_operation", null, null);
public static final TitanUniversalCharString Proc__port__in_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__in_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__in_compref_descr_ = new TTCN_Typedescriptor("Proc__port__in_compref", Proc__port__in_compref_raw_, null);
public static final TitanUniversalCharString Proc__port__in_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__in_check___raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__in_check___descr_ = new TTCN_Typedescriptor("Proc__port__in_check__", Proc__port__in_check___raw_, null);
public static final TitanUniversalCharString Proc__port__in_check___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__in_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__in_parameter_descr_ = new TTCN_Typedescriptor("Proc__port__in_parameter", Proc__port__in_parameter_raw_, null);
public static final TitanUniversalCharString Proc__port__in_parameter_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Proc__port__in_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Proc__port__in_msgid_descr_ = new TTCN_Typedescriptor("Proc__port__in_msgid", Proc__port__in_msgid_raw_, null);
public static final TitanUniversalCharString Proc__port__in_msgid_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Proc__port__in_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Msg__port__recv_descr_ = new TTCN_Typedescriptor("Msg__port__recv", null, null);
public static final TTCN_RAWdescriptor Msg__port__recv_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__recv_port__name_descr_ = new TTCN_Typedescriptor("Msg__port__recv_port__name", Msg__port__recv_port__name_raw_, null);
public static final TitanUniversalCharString Msg__port__recv_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Msg__port__recv_operation_descr_ = new TTCN_Typedescriptor("Msg__port__recv_operation", null, null);
public static final TitanUniversalCharString Msg__port__recv_operation_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Msg__port__recv_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__recv_compref_descr_ = new TTCN_Typedescriptor("Msg__port__recv_compref", Msg__port__recv_compref_raw_, null);
public static final TitanUniversalCharString Msg__port__recv_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Msg__port__recv_sys__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__recv_sys__name_descr_ = new TTCN_Typedescriptor("Msg__port__recv_sys__name", Msg__port__recv_sys__name_raw_, null);
public static final TitanUniversalCharString Msg__port__recv_sys__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Msg__port__recv_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__recv_parameter_descr_ = new TTCN_Typedescriptor("Msg__port__recv_parameter", Msg__port__recv_parameter_raw_, null);
public static final TitanUniversalCharString Msg__port__recv_parameter_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Msg__port__recv_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__recv_msgid_descr_ = new TTCN_Typedescriptor("Msg__port__recv_msgid", Msg__port__recv_msgid_raw_, null);
public static final TitanUniversalCharString Msg__port__recv_msgid_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Msg__port__recv_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Msg__port__send_descr_ = new TTCN_Typedescriptor("Msg__port__send", null, null);
public static final TTCN_RAWdescriptor Msg__port__send_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__send_port__name_descr_ = new TTCN_Typedescriptor("Msg__port__send_port__name", Msg__port__send_port__name_raw_, null);
public static final TitanUniversalCharString Msg__port__send_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Msg__port__send_compref_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__send_compref_descr_ = new TTCN_Typedescriptor("Msg__port__send_compref", Msg__port__send_compref_raw_, null);
public static final TitanUniversalCharString Msg__port__send_compref_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Msg__port__send_parameter_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Msg__port__send_parameter_descr_ = new TTCN_Typedescriptor("Msg__port__send_parameter", Msg__port__send_parameter_raw_, null);
public static final TitanUniversalCharString Msg__port__send_parameter_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Msg__port__send_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Dualface__mapped_descr_ = new TTCN_Typedescriptor("Dualface__mapped", null, null);
public static final TTCN_RAWdescriptor Dualface__mapped_incoming_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__mapped_incoming_descr_ = new TTCN_Typedescriptor("Dualface__mapped_incoming", Dualface__mapped_incoming_raw_, null);
public static final TitanUniversalCharString Dualface__mapped_incoming_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Dualface__mapped_target__type_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__mapped_target__type_descr_ = new TTCN_Typedescriptor("Dualface__mapped_target__type", Dualface__mapped_target__type_raw_, null);
public static final TitanUniversalCharString Dualface__mapped_target__type_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Dualface__mapped_value___raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__mapped_value___descr_ = new TTCN_Typedescriptor("Dualface__mapped_value__", Dualface__mapped_value___raw_, null);
public static final TitanUniversalCharString Dualface__mapped_value___default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Dualface__mapped_msgid_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__mapped_msgid_descr_ = new TTCN_Typedescriptor("Dualface__mapped_msgid", Dualface__mapped_msgid_raw_, null);
public static final TitanUniversalCharString Dualface__mapped_msgid_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Dualface__mapped_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Dualface__discard_descr_ = new TTCN_Typedescriptor("Dualface__discard", null, null);
public static final TTCN_RAWdescriptor Dualface__discard_incoming_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__discard_incoming_descr_ = new TTCN_Typedescriptor("Dualface__discard_incoming", Dualface__discard_incoming_raw_, null);
public static final TitanUniversalCharString Dualface__discard_incoming_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Dualface__discard_target__type_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__discard_target__type_descr_ = new TTCN_Typedescriptor("Dualface__discard_target__type", Dualface__discard_target__type_raw_, null);
public static final TitanUniversalCharString Dualface__discard_target__type_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Dualface__discard_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__discard_port__name_descr_ = new TTCN_Typedescriptor("Dualface__discard_port__name", Dualface__discard_port__name_raw_, null);
public static final TitanUniversalCharString Dualface__discard_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Dualface__discard_unhandled_raw_ = new TTCN_RAWdescriptor(1,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Dualface__discard_unhandled_descr_ = new TTCN_Typedescriptor("Dualface__discard_unhandled", Dualface__discard_unhandled_raw_, null);
public static final TitanUniversalCharString Dualface__discard_unhandled_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Dualface__discard_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Setstate_descr_ = new TTCN_Typedescriptor("Setstate", null, null);
public static final TTCN_RAWdescriptor Setstate_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Setstate_port__name_descr_ = new TTCN_Typedescriptor("Setstate_port__name", Setstate_port__name_raw_, null);
public static final TitanUniversalCharString Setstate_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Setstate_state_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Setstate_state_descr_ = new TTCN_Typedescriptor("Setstate_state", Setstate_state_raw_, null);
public static final TitanUniversalCharString Setstate_state_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Setstate_info_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Setstate_info_descr_ = new TTCN_Typedescriptor("Setstate_info", Setstate_info_raw_, null);
public static final TitanUniversalCharString Setstate_info_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Setstate_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor Port__Misc_descr_ = new TTCN_Typedescriptor("Port__Misc", null, null);
public static final TTCN_Typedescriptor Port__Misc_reason_descr_ = new TTCN_Typedescriptor("Port__Misc_reason", null, null);
public static final TitanUniversalCharString Port__Misc_reason_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Misc_port__name_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Misc_port__name_descr_ = new TTCN_Typedescriptor("Port__Misc_port__name", Port__Misc_port__name_raw_, null);
public static final TitanUniversalCharString Port__Misc_port__name_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Misc_remote__component_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Misc_remote__component_descr_ = new TTCN_Typedescriptor("Port__Misc_remote__component", Port__Misc_remote__component_raw_, null);
public static final TitanUniversalCharString Port__Misc_remote__component_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Misc_remote__port_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Misc_remote__port_descr_ = new TTCN_Typedescriptor("Port__Misc_remote__port", Port__Misc_remote__port_raw_, null);
public static final TitanUniversalCharString Port__Misc_remote__port_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Misc_ip__address_raw_ = new TTCN_RAWdescriptor(0,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Misc_ip__address_descr_ = new TTCN_Typedescriptor("Port__Misc_ip__address", Port__Misc_ip__address_raw_, null);
public static final TitanUniversalCharString Port__Misc_ip__address_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Misc_tcp__port_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Misc_tcp__port_descr_ = new TTCN_Typedescriptor("Port__Misc_tcp__port", Port__Misc_tcp__port_raw_, null);
public static final TitanUniversalCharString Port__Misc_tcp__port_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_RAWdescriptor Port__Misc_new__size_raw_ = new TTCN_RAWdescriptor(8,raw_sign_t.SG_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,ext_bit_t.EXT_BIT_NO,raw_order_t.ORDER_LSB,raw_order_t.ORDER_LSB,top_bit_order_t.TOP_BIT_INHERITED,0,0,0,8,0,null,-1,CharCoding.UNKNOWN, null);
public static final TTCN_Typedescriptor Port__Misc_new__size_descr_ = new TTCN_Typedescriptor("Port__Misc_new__size", Port__Misc_new__size_raw_, null);
public static final TitanUniversalCharString Port__Misc_new__size_default_coding = new TitanUniversalCharString("XER");
public static final TitanUniversalCharString Port__Misc_default_coding = new TitanUniversalCharString("XER");
public static final TTCN_Typedescriptor anytype_descr_ = new TTCN_Typedescriptor("anytype", null, null);
public static final TitanUniversalCharString anytype_default_coding = new TitanUniversalCharString("XER");
public static void MatchingEvent_choice_matchingFailure_encoder(final MatchingFailureType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_choice_matchingFailure_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_choice_matchingFailure_decoder( final TitanOctetString input_stream, final MatchingFailureType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_choice_matchingFailure_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void VerdictOp_choice_getVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictOp_choice_getVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictOp_choice_getVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictOp_choice_getVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__mapped_incoming_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__mapped_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__mapped_incoming_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__mapped_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Categorized_text_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Categorized_text_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Categorized_text_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Categorized_text_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_portMisc_encoder(final Port__Misc input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_portMisc_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_portMisc_decoder( final TitanOctetString input_stream, final Port__Misc output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_portMisc_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_setState_encoder(final Setstate input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_setState_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_setState_decoder( final TitanOctetString input_stream, final Setstate output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_setState_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Parallel_dst__compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_dst__compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_dst__compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_dst__compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class DefaultOp extends Base_Type {
		private final TitanCharString name; //CharString_Type
		private final TitanInteger id; //Integer_Type
		private final DefaultEnd end; //Referenced_Type

		public DefaultOp() {
			name = new TitanCharString();
			id = new TitanInteger();
			end = new DefaultEnd();
		}

		public DefaultOp( final TitanCharString aName, final TitanInteger aId, final DefaultEnd aEnd ) {
			name = new TitanCharString( aName );
			id = new TitanInteger( aId );
			end = new DefaultEnd( aEnd );
		}

		public DefaultOp( final DefaultOp aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.DefaultOp.");
			}
			name = new TitanCharString();
			id = new TitanInteger();
			end = new DefaultEnd();
			assign( aOtherValue );
		}
		public DefaultOp assign(final DefaultOp aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.DefaultOp");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getName().isBound() ) {
					this.name.assign( aOtherValue.getName() );
				} else {
					this.name.cleanUp();
				}
				if ( aOtherValue.getId().isBound() ) {
					this.id.assign( aOtherValue.getId() );
				} else {
					this.id.cleanUp();
				}
				if ( aOtherValue.getEnd().isBound() ) {
					this.end.assign( aOtherValue.getEnd() );
				} else {
					this.end.cleanUp();
				}
			}

			return this;
		}

		@Override
		public DefaultOp assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultOp ) {
				return assign((DefaultOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultOp", otherValue));
		}

		public void cleanUp() {
			name.cleanUp();
			id.cleanUp();
			end.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( name.isBound() ) { return true; }
			if ( id.isBound() ) { return true; }
			if ( end.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !name.isValue() ) { return false; }
			if ( !id.isValue() ) { return false; }
			if ( !end.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final DefaultOp aOtherValue ) {
			if ( !this.name.operatorEquals( aOtherValue.name ) ) { return false; }
			if ( !this.id.operatorEquals( aOtherValue.id ) ) { return false; }
			if ( !this.end.operatorEquals( aOtherValue.end ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof DefaultOp ) {
				return operatorEquals((DefaultOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultOp", otherValue));
		}

		public TitanCharString getName() {
			return name;
		}

		public TitanCharString constGetName() {
			return name;
		}

		public TitanInteger getId() {
			return id;
		}

		public TitanInteger constGetId() {
			return id;
		}

		public DefaultEnd getEnd() {
			return end;
		}

		public DefaultEnd constGetEnd() {
			return end;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" id := ");
			id.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" end := ");
			end.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (id.isBound()) {
				id.set_implicit_omit();
			}
			if (end.isBound()) {
				end.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			name.encode_text(text_buf);
			id.encode_text(text_buf);
			end.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			name.decode_text(text_buf);
			id.decode_text(text_buf);
			end.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class DefaultOp_template extends Base_Template {

	private TitanCharString_template name; //CharString_Type
	private TitanInteger_template id; //Integer_Type
	private DefaultEnd_template end; //Referenced_Type
	//originally value_list/list_value
	List<DefaultOp_template> list_value;

	public TitanCharString_template getName() {
		setSpecific();
		return name;
	}

	public TitanCharString_template constGetName() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.DefaultOp.");
		}
		return name;
	}

	public TitanInteger_template getId() {
		setSpecific();
		return id;
	}

	public TitanInteger_template constGetId() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field id of a non-specific template of type @TitanLoggerApi.DefaultOp.");
		}
		return id;
	}

	public DefaultEnd_template getEnd() {
		setSpecific();
		return end;
	}

	public DefaultEnd_template constGetEnd() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field end of a non-specific template of type @TitanLoggerApi.DefaultOp.");
		}
		return end;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			name = new TitanCharString_template();
			id = new TitanInteger_template();
			end = new DefaultEnd_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				name.assign(template_sel.ANY_VALUE);
				id.assign(template_sel.ANY_VALUE);
				end.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public DefaultOp_template() {
	}

	public DefaultOp_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public DefaultOp_template( final DefaultOp otherValue ) {
		copyValue(otherValue);
	}

	public DefaultOp_template( final DefaultOp_template otherValue ) {
		copyTemplate( otherValue );
	}

	public DefaultOp_template( final Optional<DefaultOp> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.DefaultOp from an unbound optional field.");
		}
	}

	//originally operator=
	public DefaultOp_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public DefaultOp_template assign( final DefaultOp other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public DefaultOp_template assign( final DefaultOp_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public DefaultOp_template assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultOp) {
				return assign((DefaultOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultOp' can not be cast to {1}", otherValue));
		}

		@Override
		public DefaultOp_template assign(final Base_Template otherValue) {
			if (otherValue instanceof DefaultOp_template) {
				return assign((DefaultOp_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultOp' can not be cast to {1}_template", otherValue));
		}

	public DefaultOp_template assign( final Optional<DefaultOp> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.DefaultOp.");
		}
		return this;
	}

	private void copyValue(final DefaultOp other_value) {
		if (other_value.getName().isBound()) {
			getName().assign(other_value.getName());
		} else {
			getName().cleanUp();
		}
		if (other_value.getId().isBound()) {
			getId().assign(other_value.getId());
		} else {
			getId().cleanUp();
		}
		if (other_value.getEnd().isBound()) {
			getEnd().assign(other_value.getEnd());
		} else {
			getEnd().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final DefaultOp_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getName().get_selection()) {
				getName().cleanUp();
			} else {
				getName().assign(other_value.getName());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getId().get_selection()) {
				getId().cleanUp();
			} else {
				getId().assign(other_value.getId());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEnd().get_selection()) {
				getEnd().cleanUp();
			} else {
				getEnd().assign(other_value.getEnd());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<DefaultOp_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final DefaultOp_template temp = new DefaultOp_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.DefaultOp.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public DefaultOp valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.DefaultOp.");
			}
			final DefaultOp ret_val = new DefaultOp();
			 if (name.isBound()) {
				ret_val.name.assign(name.valueOf());
			}
			 if (id.isBound()) {
				ret_val.id.assign(id.valueOf());
			}
			 if (end.isBound()) {
				ret_val.end.assign(end.valueOf());
			}
			return ret_val;
		}

		public DefaultOp_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.DefaultOp.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.DefaultOp.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.DefaultOp.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<DefaultOp_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new DefaultOp_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (id.isBound()) {
				return true;
			}
			if (end.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!id.isValue()) {
				return false;
			}
			if (!end.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final DefaultOp other_value) {
			return match(other_value, false);
		}

		public boolean match(final DefaultOp other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getName().isBound()) {
					return false;
				}
				if(!name.match(other_value.getName(), legacy)) {
					return false;
				}
				if(!other_value.getId().isBound()) {
					return false;
				}
				if(!id.match(other_value.getId(), legacy)) {
					return false;
				}
				if(!other_value.getEnd().isBound()) {
					return false;
				}
				if(!end.match(other_value.getEnd(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.DefaultOp.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof DefaultOp) {
		return match((DefaultOp)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type DefaultOp.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultOp containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.DefaultOp.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" id := ");
				id.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" end := ");
				end.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final DefaultOp match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof DefaultOp) {
				log_match((DefaultOp)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultOp.");
		}

		public void log_match(final DefaultOp match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !name.match(match_value.constGetName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !id.match(match_value.constGetId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".id");
							id.log_match(match_value.constGetId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !end.match(match_value.constGetEnd(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".end");
							end.log_match(match_value.constGetEnd(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetName(), legacy);
				TTCN_Logger.log_event_str("{ id := ");
				id.log_match(match_value.constGetId(), legacy);
				TTCN_Logger.log_event_str("{ end := ");
				end.log_match(match_value.constGetEnd(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name.encode_text(text_buf);
				id.encode_text(text_buf);
				end.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.DefaultOp.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				id = new TitanInteger_template();
				id.decode_text(text_buf);
				end = new DefaultEnd_template();
				end.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<DefaultOp_template>(size);
				for(int i = 0; i < size; i++) {
					final DefaultOp_template temp = new DefaultOp_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.DefaultOp.");
			}
		}
}
public static void DefaultOp_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultOp_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultOp_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultOp_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_module___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_module___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_module___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_module___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_executorConfigdata_encoder(final ExecutorConfigdata input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_executorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_executorConfigdata_decoder( final TitanOctetString input_stream, final ExecutorConfigdata output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_executorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class VerdictOp_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_SetVerdict,  ALT_GetVerdict,  ALT_FinalVerdict };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public VerdictOp_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public VerdictOp_choice(final VerdictOp_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final VerdictOp_choice otherValue) {
switch (otherValue.union_selection){
case ALT_SetVerdict:
field = new SetVerdictType((SetVerdictType)otherValue.field);
break;
case ALT_GetVerdict:
field = new Verdict((Verdict)otherValue.field);
break;
case ALT_FinalVerdict:
field = new FinalVerdictType((FinalVerdictType)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.VerdictOp.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public VerdictOp_choice assign( final VerdictOp_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public VerdictOp_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof VerdictOp_choice) {
return assign((VerdictOp_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.VerdictOp.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_SetVerdict:
return field.isValue();
case ALT_GetVerdict:
return field.isValue();
case ALT_FinalVerdict:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final VerdictOp_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.VerdictOp.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.VerdictOp.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_SetVerdict:
return ((SetVerdictType)field).operatorEquals((SetVerdictType)otherValue.field);
case ALT_GetVerdict:
return ((Verdict)field).operatorEquals((Verdict)otherValue.field);
case ALT_FinalVerdict:
return ((FinalVerdictType)field).operatorEquals((FinalVerdictType)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof VerdictOp_choice) {
return operatorEquals((VerdictOp_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final VerdictOp_choice otherValue ) {
return !operatorEquals(otherValue);
}

public SetVerdictType getSetVerdict() {
if (union_selection != union_selection_type.ALT_SetVerdict) {
cleanUp();
field = new SetVerdictType();
union_selection = union_selection_type.ALT_SetVerdict;
}
return (SetVerdictType)field;
}

public SetVerdictType constGetSetVerdict() {
if (union_selection != union_selection_type.ALT_SetVerdict) {
throw new TtcnError("Using non-selected field setVerdict in a value of union type @TitanLoggerApi.VerdictOp.choice.");
}
return (SetVerdictType)field;
}

public Verdict getGetVerdict() {
if (union_selection != union_selection_type.ALT_GetVerdict) {
cleanUp();
field = new Verdict();
union_selection = union_selection_type.ALT_GetVerdict;
}
return (Verdict)field;
}

public Verdict constGetGetVerdict() {
if (union_selection != union_selection_type.ALT_GetVerdict) {
throw new TtcnError("Using non-selected field getVerdict in a value of union type @TitanLoggerApi.VerdictOp.choice.");
}
return (Verdict)field;
}

public FinalVerdictType getFinalVerdict() {
if (union_selection != union_selection_type.ALT_FinalVerdict) {
cleanUp();
field = new FinalVerdictType();
union_selection = union_selection_type.ALT_FinalVerdict;
}
return (FinalVerdictType)field;
}

public FinalVerdictType constGetFinalVerdict() {
if (union_selection != union_selection_type.ALT_FinalVerdict) {
throw new TtcnError("Using non-selected field finalVerdict in a value of union type @TitanLoggerApi.VerdictOp.choice.");
}
return (FinalVerdictType)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_SetVerdict:
TTCN_Logger.log_event_str("{ setVerdict := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_GetVerdict:
TTCN_Logger.log_event_str("{ getVerdict := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_FinalVerdict:
TTCN_Logger.log_event_str("{ finalVerdict := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_SetVerdict:
case ALT_GetVerdict:
case ALT_FinalVerdict:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_SetVerdict:
text_buf.push_int(0);
break;
case ALT_GetVerdict:
text_buf.push_int(1);
break;
case ALT_FinalVerdict:
text_buf.push_int(2);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.VerdictOp.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getSetVerdict().decode_text(text_buf);
break;
case 1:
getGetVerdict().decode_text(text_buf);
break;
case 2:
getFinalVerdict().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.VerdictOp.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class VerdictOp_choice_template extends Base_Template {
//if single value which value?
private VerdictOp_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<VerdictOp_choice_template> value_list;

private void copy_value(final VerdictOp_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_SetVerdict:
single_value = new SetVerdictType_template(other_value.constGetSetVerdict());
break;
case ALT_GetVerdict:
single_value = new Verdict_template(other_value.constGetGetVerdict());
break;
case ALT_FinalVerdict:
single_value = new FinalVerdictType_template(other_value.constGetFinalVerdict());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.VerdictOp.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final VerdictOp_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_SetVerdict:
single_value = new SetVerdictType_template(other_value.constGetSetVerdict());
break;
case ALT_GetVerdict:
single_value = new Verdict_template(other_value.constGetGetVerdict());
break;
case ALT_FinalVerdict:
single_value = new FinalVerdictType_template(other_value.constGetFinalVerdict());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.VerdictOp.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<VerdictOp_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final VerdictOp_choice_template temp = new VerdictOp_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.VerdictOp.choice.");
}
set_selection(other_value);
}

public VerdictOp_choice_template() {
}
public VerdictOp_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public VerdictOp_choice_template(final VerdictOp_choice other_value) {
copy_value(other_value);
}
public VerdictOp_choice_template(final VerdictOp_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_SetVerdict:
((SetVerdictType_template)single_value).cleanUp();
break;
case ALT_GetVerdict:
((Verdict_template)single_value).cleanUp();
break;
case ALT_FinalVerdict:
((FinalVerdictType_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public VerdictOp_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public VerdictOp_choice_template assign( final VerdictOp_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public VerdictOp_choice_template assign( final VerdictOp_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public VerdictOp_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof VerdictOp_choice) {
return assign((VerdictOp_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to VerdictOp_choice.");
}

@Override
public VerdictOp_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof VerdictOp_choice_template) {
return assign((VerdictOp_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to VerdictOp_choice_template.");
}

// originally match
public boolean match(final VerdictOp_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final VerdictOp_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final VerdictOp_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == VerdictOp_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_SetVerdict:
return ((SetVerdictType_template)single_value).match(other_value.getSetVerdict(), legacy);
case ALT_GetVerdict:
return ((Verdict_template)single_value).match(other_value.getGetVerdict(), legacy);
case ALT_FinalVerdict:
return ((FinalVerdictType_template)single_value).match(other_value.getFinalVerdict(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof VerdictOp_choice) {
		return match((VerdictOp_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type VerdictOp_choice.");
	}
public boolean isChosen(final VerdictOp_choice.union_selection_type checked_selection) {
if(checked_selection == VerdictOp_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.VerdictOp.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == VerdictOp_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.VerdictOp.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_SetVerdict:
return ((SetVerdictType_template)single_value).isValue();
case ALT_GetVerdict:
return ((Verdict_template)single_value).isValue();
case ALT_FinalVerdict:
return ((FinalVerdictType_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
}

public VerdictOp_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
}
final VerdictOp_choice ret_val = new VerdictOp_choice();
switch (single_value_union_selection) {
case ALT_SetVerdict:
ret_val.getSetVerdict().assign(((SetVerdictType_template)single_value).valueOf());
break;
case ALT_GetVerdict:
ret_val.getGetVerdict().assign(((Verdict_template)single_value).valueOf());
break;
case ALT_FinalVerdict:
ret_val.getFinalVerdict().assign(((FinalVerdictType_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<VerdictOp_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new VerdictOp_choice_template());
}
}

public VerdictOp_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.VerdictOp.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.VerdictOp.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.VerdictOp.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public SetVerdictType_template getSetVerdict() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_SetVerdict) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new SetVerdictType_template(template_sel.ANY_VALUE);
} else {
single_value = new SetVerdictType_template();
}
single_value_union_selection = VerdictOp_choice.union_selection_type.ALT_SetVerdict;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (SetVerdictType_template)single_value;
}

public SetVerdictType_template constGetSetVerdict() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field setVerdict in a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
}
if (single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_SetVerdict) {
throw new TtcnError("Accessing non-selected field setVerdict in a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
return (SetVerdictType_template)single_value;
}

public Verdict_template getGetVerdict() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_GetVerdict) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Verdict_template(template_sel.ANY_VALUE);
} else {
single_value = new Verdict_template();
}
single_value_union_selection = VerdictOp_choice.union_selection_type.ALT_GetVerdict;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Verdict_template)single_value;
}

public Verdict_template constGetGetVerdict() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field getVerdict in a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
}
if (single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_GetVerdict) {
throw new TtcnError("Accessing non-selected field getVerdict in a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
return (Verdict_template)single_value;
}

public FinalVerdictType_template getFinalVerdict() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_FinalVerdict) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new FinalVerdictType_template(template_sel.ANY_VALUE);
} else {
single_value = new FinalVerdictType_template();
}
single_value_union_selection = VerdictOp_choice.union_selection_type.ALT_FinalVerdict;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (FinalVerdictType_template)single_value;
}

public FinalVerdictType_template constGetFinalVerdict() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field finalVerdict in a non-specific template of union type @TitanLoggerApi.VerdictOp.choice.");
}
if (single_value_union_selection != VerdictOp_choice.union_selection_type.ALT_FinalVerdict) {
throw new TtcnError("Accessing non-selected field finalVerdict in a template of union type @TitanLoggerApi.VerdictOp.choice.");
}
return (FinalVerdictType_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof VerdictOp_choice) {
log_match((VerdictOp_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.choice.");
}

public void log_match(final VerdictOp_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_SetVerdict:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".setVerdict");
single_value.log_match(match_value.getSetVerdict(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ setVerdict := ");
single_value.log_match(match_value.getSetVerdict(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_GetVerdict:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".getVerdict");
single_value.log_match(match_value.getGetVerdict(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ getVerdict := ");
single_value.log_match(match_value.getGetVerdict(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_FinalVerdict:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".finalVerdict");
single_value.log_match(match_value.getFinalVerdict(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ finalVerdict := ");
single_value.log_match(match_value.getFinalVerdict(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.VerdictOp.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new SetVerdictType_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new Verdict_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new FinalVerdictType_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<VerdictOp_choice_template>(size);
for (int i = 0; i < size; i++) {
final VerdictOp_choice_template temp2 = new VerdictOp_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.VerdictOp.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void VerdictOp_choice_encoder(final VerdictOp_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictOp_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictOp_choice_decoder( final TitanOctetString input_stream, final VerdictOp_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictOp_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void DefaultEvent_choice_defaultopExit_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultEvent_choice_defaultopExit_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultEvent_choice_defaultopExit_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultEvent_choice_defaultopExit_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_controlpartStart_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_controlpartStart_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_controlpartStart_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_controlpartStart_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__mapped_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__mapped_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__mapped_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__mapped_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class FinalVerdictInfo extends Base_Type {
		private final TitanBoolean is__ptc; //Boolean_Type
		private final Verdict ptc__verdict; //Referenced_Type
		private final Verdict local__verdict; //Referenced_Type
		private final Verdict new__verdict; //Referenced_Type
		private final Optional<TitanCharString> verdict__reason; //CharString_Type
		private final Optional<TitanInteger> ptc__compref; //Integer_Type
		private final Optional<TitanCharString> ptc__name; //CharString_Type

		public FinalVerdictInfo() {
			is__ptc = new TitanBoolean();
			ptc__verdict = new Verdict();
			local__verdict = new Verdict();
			new__verdict = new Verdict();
			verdict__reason = new Optional<TitanCharString>(TitanCharString.class);
			ptc__compref = new Optional<TitanInteger>(TitanInteger.class);
			ptc__name = new Optional<TitanCharString>(TitanCharString.class);
		}

		public FinalVerdictInfo( final TitanBoolean aIs__ptc, final Verdict aPtc__verdict, final Verdict aLocal__verdict, final Verdict aNew__verdict, final Optional<TitanCharString> aVerdict__reason, final Optional<TitanInteger> aPtc__compref, final Optional<TitanCharString> aPtc__name ) {
			is__ptc = new TitanBoolean( aIs__ptc );
			ptc__verdict = new Verdict( aPtc__verdict );
			local__verdict = new Verdict( aLocal__verdict );
			new__verdict = new Verdict( aNew__verdict );
			verdict__reason = new Optional<TitanCharString>(TitanCharString.class);
			this.verdict__reason.assign( aVerdict__reason );
			ptc__compref = new Optional<TitanInteger>(TitanInteger.class);
			this.ptc__compref.assign( aPtc__compref );
			ptc__name = new Optional<TitanCharString>(TitanCharString.class);
			this.ptc__name.assign( aPtc__name );
		}

		public FinalVerdictInfo( final FinalVerdictInfo aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			is__ptc = new TitanBoolean();
			ptc__verdict = new Verdict();
			local__verdict = new Verdict();
			new__verdict = new Verdict();
			verdict__reason = new Optional<TitanCharString>(TitanCharString.class);
			ptc__compref = new Optional<TitanInteger>(TitanInteger.class);
			ptc__name = new Optional<TitanCharString>(TitanCharString.class);
			assign( aOtherValue );
		}
		public FinalVerdictInfo assign(final FinalVerdictInfo aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FinalVerdictInfo");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getIs__ptc().isBound() ) {
					this.is__ptc.assign( aOtherValue.getIs__ptc() );
				} else {
					this.is__ptc.cleanUp();
				}
				if ( aOtherValue.getPtc__verdict().isBound() ) {
					this.ptc__verdict.assign( aOtherValue.getPtc__verdict() );
				} else {
					this.ptc__verdict.cleanUp();
				}
				if ( aOtherValue.getLocal__verdict().isBound() ) {
					this.local__verdict.assign( aOtherValue.getLocal__verdict() );
				} else {
					this.local__verdict.cleanUp();
				}
				if ( aOtherValue.getNew__verdict().isBound() ) {
					this.new__verdict.assign( aOtherValue.getNew__verdict() );
				} else {
					this.new__verdict.cleanUp();
				}
				if ( aOtherValue.getVerdict__reason().isBound() ) {
					this.verdict__reason.assign( aOtherValue.getVerdict__reason() );
				} else {
					this.verdict__reason.cleanUp();
				}
				if ( aOtherValue.getPtc__compref().isBound() ) {
					this.ptc__compref.assign( aOtherValue.getPtc__compref() );
				} else {
					this.ptc__compref.cleanUp();
				}
				if ( aOtherValue.getPtc__name().isBound() ) {
					this.ptc__name.assign( aOtherValue.getPtc__name() );
				} else {
					this.ptc__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FinalVerdictInfo assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictInfo ) {
				return assign((FinalVerdictInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictInfo", otherValue));
		}

		public void cleanUp() {
			is__ptc.cleanUp();
			ptc__verdict.cleanUp();
			local__verdict.cleanUp();
			new__verdict.cleanUp();
			verdict__reason.cleanUp();
			ptc__compref.cleanUp();
			ptc__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( is__ptc.isBound() ) { return true; }
			if ( ptc__verdict.isBound() ) { return true; }
			if ( local__verdict.isBound() ) { return true; }
			if ( new__verdict.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(verdict__reason.get_selection()) || verdict__reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(ptc__compref.get_selection()) || ptc__compref.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(ptc__name.get_selection()) || ptc__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !is__ptc.isValue() ) { return false; }
			if ( !ptc__verdict.isValue() ) { return false; }
			if ( !local__verdict.isValue() ) { return false; }
			if ( !new__verdict.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(verdict__reason.get_selection()) && !verdict__reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(ptc__compref.get_selection()) && !ptc__compref.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(ptc__name.get_selection()) && !ptc__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FinalVerdictInfo aOtherValue ) {
			if ( !this.is__ptc.operatorEquals( aOtherValue.is__ptc ) ) { return false; }
			if ( !this.ptc__verdict.operatorEquals( aOtherValue.ptc__verdict ) ) { return false; }
			if ( !this.local__verdict.operatorEquals( aOtherValue.local__verdict ) ) { return false; }
			if ( !this.new__verdict.operatorEquals( aOtherValue.new__verdict ) ) { return false; }
			if ( !this.verdict__reason.operatorEquals( aOtherValue.verdict__reason ) ) { return false; }
			if ( !this.ptc__compref.operatorEquals( aOtherValue.ptc__compref ) ) { return false; }
			if ( !this.ptc__name.operatorEquals( aOtherValue.ptc__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictInfo ) {
				return operatorEquals((FinalVerdictInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictInfo", otherValue));
		}

		public TitanBoolean getIs__ptc() {
			return is__ptc;
		}

		public TitanBoolean constGetIs__ptc() {
			return is__ptc;
		}

		public Verdict getPtc__verdict() {
			return ptc__verdict;
		}

		public Verdict constGetPtc__verdict() {
			return ptc__verdict;
		}

		public Verdict getLocal__verdict() {
			return local__verdict;
		}

		public Verdict constGetLocal__verdict() {
			return local__verdict;
		}

		public Verdict getNew__verdict() {
			return new__verdict;
		}

		public Verdict constGetNew__verdict() {
			return new__verdict;
		}

		public Optional<TitanCharString> getVerdict__reason() {
			return verdict__reason;
		}

		public Optional<TitanCharString> constGetVerdict__reason() {
			return verdict__reason;
		}

		public Optional<TitanInteger> getPtc__compref() {
			return ptc__compref;
		}

		public Optional<TitanInteger> constGetPtc__compref() {
			return ptc__compref;
		}

		public Optional<TitanCharString> getPtc__name() {
			return ptc__name;
		}

		public Optional<TitanCharString> constGetPtc__name() {
			return ptc__name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			if (verdict__reason.isPresent()) {
				sizeof++;
			}
			if (ptc__compref.isPresent()) {
				sizeof++;
			}
			if (ptc__name.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" is_ptc := ");
			is__ptc.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc_verdict := ");
			ptc__verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" local_verdict := ");
			local__verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" new_verdict := ");
			new__verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" verdict_reason := ");
			verdict__reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc_compref := ");
			ptc__compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc_name := ");
			ptc__name.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (is__ptc.isBound()) {
				is__ptc.set_implicit_omit();
			}
			if (ptc__verdict.isBound()) {
				ptc__verdict.set_implicit_omit();
			}
			if (local__verdict.isBound()) {
				local__verdict.set_implicit_omit();
			}
			if (new__verdict.isBound()) {
				new__verdict.set_implicit_omit();
			}
			if (verdict__reason.isBound()) {
				verdict__reason.set_implicit_omit();
			} else {
				verdict__reason.assign(template_sel.OMIT_VALUE);
			}
			if (ptc__compref.isBound()) {
				ptc__compref.set_implicit_omit();
			} else {
				ptc__compref.assign(template_sel.OMIT_VALUE);
			}
			if (ptc__name.isBound()) {
				ptc__name.set_implicit_omit();
			} else {
				ptc__name.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			is__ptc.encode_text(text_buf);
			ptc__verdict.encode_text(text_buf);
			local__verdict.encode_text(text_buf);
			new__verdict.encode_text(text_buf);
			verdict__reason.encode_text(text_buf);
			ptc__compref.encode_text(text_buf);
			ptc__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			is__ptc.decode_text(text_buf);
			ptc__verdict.decode_text(text_buf);
			local__verdict.decode_text(text_buf);
			new__verdict.decode_text(text_buf);
			verdict__reason.decode_text(text_buf);
			ptc__compref.decode_text(text_buf);
			ptc__name.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class FinalVerdictInfo_template extends Base_Template {

	private TitanBoolean_template is__ptc; //Boolean_Type
	private Verdict_template ptc__verdict; //Referenced_Type
	private Verdict_template local__verdict; //Referenced_Type
	private Verdict_template new__verdict; //Referenced_Type
	private TitanCharString_template verdict__reason; //CharString_Type
	private TitanInteger_template ptc__compref; //Integer_Type
	private TitanCharString_template ptc__name; //CharString_Type
	//originally value_list/list_value
	List<FinalVerdictInfo_template> list_value;

	public TitanBoolean_template getIs__ptc() {
		setSpecific();
		return is__ptc;
	}

	public TitanBoolean_template constGetIs__ptc() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field is_ptc of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return is__ptc;
	}

	public Verdict_template getPtc__verdict() {
		setSpecific();
		return ptc__verdict;
	}

	public Verdict_template constGetPtc__verdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ptc_verdict of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return ptc__verdict;
	}

	public Verdict_template getLocal__verdict() {
		setSpecific();
		return local__verdict;
	}

	public Verdict_template constGetLocal__verdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field local_verdict of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return local__verdict;
	}

	public Verdict_template getNew__verdict() {
		setSpecific();
		return new__verdict;
	}

	public Verdict_template constGetNew__verdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field new_verdict of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return new__verdict;
	}

	public TitanCharString_template getVerdict__reason() {
		setSpecific();
		return verdict__reason;
	}

	public TitanCharString_template constGetVerdict__reason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field verdict_reason of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return verdict__reason;
	}

	public TitanInteger_template getPtc__compref() {
		setSpecific();
		return ptc__compref;
	}

	public TitanInteger_template constGetPtc__compref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ptc_compref of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return ptc__compref;
	}

	public TitanCharString_template getPtc__name() {
		setSpecific();
		return ptc__name;
	}

	public TitanCharString_template constGetPtc__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ptc_name of a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return ptc__name;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			is__ptc = new TitanBoolean_template();
			ptc__verdict = new Verdict_template();
			local__verdict = new Verdict_template();
			new__verdict = new Verdict_template();
			verdict__reason = new TitanCharString_template();
			ptc__compref = new TitanInteger_template();
			ptc__name = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				is__ptc.assign(template_sel.ANY_VALUE);
				ptc__verdict.assign(template_sel.ANY_VALUE);
				local__verdict.assign(template_sel.ANY_VALUE);
				new__verdict.assign(template_sel.ANY_VALUE);
				verdict__reason.assign(template_sel.ANY_OR_OMIT);
				ptc__compref.assign(template_sel.ANY_OR_OMIT);
				ptc__name.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public FinalVerdictInfo_template() {
	}

	public FinalVerdictInfo_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public FinalVerdictInfo_template( final FinalVerdictInfo otherValue ) {
		copyValue(otherValue);
	}

	public FinalVerdictInfo_template( final FinalVerdictInfo_template otherValue ) {
		copyTemplate( otherValue );
	}

	public FinalVerdictInfo_template( final Optional<FinalVerdictInfo> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.FinalVerdictInfo from an unbound optional field.");
		}
	}

	//originally operator=
	public FinalVerdictInfo_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public FinalVerdictInfo_template assign( final FinalVerdictInfo other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public FinalVerdictInfo_template assign( final FinalVerdictInfo_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public FinalVerdictInfo_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictInfo) {
				return assign((FinalVerdictInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictInfo' can not be cast to {1}", otherValue));
		}

		@Override
		public FinalVerdictInfo_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FinalVerdictInfo_template) {
				return assign((FinalVerdictInfo_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictInfo' can not be cast to {1}_template", otherValue));
		}

	public FinalVerdictInfo_template assign( final Optional<FinalVerdictInfo> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		return this;
	}

	private void copyValue(final FinalVerdictInfo other_value) {
		if (other_value.getIs__ptc().isBound()) {
			getIs__ptc().assign(other_value.getIs__ptc());
		} else {
			getIs__ptc().cleanUp();
		}
		if (other_value.getPtc__verdict().isBound()) {
			getPtc__verdict().assign(other_value.getPtc__verdict());
		} else {
			getPtc__verdict().cleanUp();
		}
		if (other_value.getLocal__verdict().isBound()) {
			getLocal__verdict().assign(other_value.getLocal__verdict());
		} else {
			getLocal__verdict().cleanUp();
		}
		if (other_value.getNew__verdict().isBound()) {
			getNew__verdict().assign(other_value.getNew__verdict());
		} else {
			getNew__verdict().cleanUp();
		}
		if (other_value.getVerdict__reason().isBound()) {
			if (other_value.getVerdict__reason().isPresent()) {
				getVerdict__reason().assign(other_value.getVerdict__reason().get());
			} else {
				getVerdict__reason().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getVerdict__reason().cleanUp();
		}
		if (other_value.getPtc__compref().isBound()) {
			if (other_value.getPtc__compref().isPresent()) {
				getPtc__compref().assign(other_value.getPtc__compref().get());
			} else {
				getPtc__compref().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getPtc__compref().cleanUp();
		}
		if (other_value.getPtc__name().isBound()) {
			if (other_value.getPtc__name().isPresent()) {
				getPtc__name().assign(other_value.getPtc__name().get());
			} else {
				getPtc__name().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getPtc__name().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final FinalVerdictInfo_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getIs__ptc().get_selection()) {
				getIs__ptc().cleanUp();
			} else {
				getIs__ptc().assign(other_value.getIs__ptc());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPtc__verdict().get_selection()) {
				getPtc__verdict().cleanUp();
			} else {
				getPtc__verdict().assign(other_value.getPtc__verdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getLocal__verdict().get_selection()) {
				getLocal__verdict().cleanUp();
			} else {
				getLocal__verdict().assign(other_value.getLocal__verdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNew__verdict().get_selection()) {
				getNew__verdict().cleanUp();
			} else {
				getNew__verdict().assign(other_value.getNew__verdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getVerdict__reason().get_selection()) {
				getVerdict__reason().cleanUp();
			} else {
				getVerdict__reason().assign(other_value.getVerdict__reason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPtc__compref().get_selection()) {
				getPtc__compref().cleanUp();
			} else {
				getPtc__compref().assign(other_value.getPtc__compref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPtc__name().get_selection()) {
				getPtc__name().cleanUp();
			} else {
				getPtc__name().assign(other_value.getPtc__name());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<FinalVerdictInfo_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final FinalVerdictInfo_template temp = new FinalVerdictInfo_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FinalVerdictInfo.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FinalVerdictInfo valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			final FinalVerdictInfo ret_val = new FinalVerdictInfo();
			 if (is__ptc.isBound()) {
				ret_val.is__ptc.assign(is__ptc.valueOf());
			}
			 if (ptc__verdict.isBound()) {
				ret_val.ptc__verdict.assign(ptc__verdict.valueOf());
			}
			 if (local__verdict.isBound()) {
				ret_val.local__verdict.assign(local__verdict.valueOf());
			}
			 if (new__verdict.isBound()) {
				ret_val.new__verdict.assign(new__verdict.valueOf());
			}
			if (verdict__reason.isOmit()) {
				ret_val.verdict__reason.assign(template_sel.OMIT_VALUE);
			} else if (verdict__reason.isBound()) {
				ret_val.verdict__reason.assign(verdict__reason.valueOf());
			}
			if (ptc__compref.isOmit()) {
				ret_val.ptc__compref.assign(template_sel.OMIT_VALUE);
			} else if (ptc__compref.isBound()) {
				ret_val.ptc__compref.assign(ptc__compref.valueOf());
			}
			if (ptc__name.isOmit()) {
				ret_val.ptc__name.assign(template_sel.OMIT_VALUE);
			} else if (ptc__name.isBound()) {
				ret_val.ptc__name.assign(ptc__name.valueOf());
			}
			return ret_val;
		}

		public FinalVerdictInfo_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FinalVerdictInfo_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FinalVerdictInfo_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (is__ptc.isBound()) {
				return true;
			}
			if (ptc__verdict.isBound()) {
				return true;
			}
			if (local__verdict.isBound()) {
				return true;
			}
			if (new__verdict.isBound()) {
				return true;
			}
			if (verdict__reason.isOmit() || verdict__reason.isBound()) {
				return true;
			}
			if (ptc__compref.isOmit() || ptc__compref.isBound()) {
				return true;
			}
			if (ptc__name.isOmit() || ptc__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!is__ptc.isValue()) {
				return false;
			}
			if (!ptc__verdict.isValue()) {
				return false;
			}
			if (!local__verdict.isValue()) {
				return false;
			}
			if (!new__verdict.isValue()) {
				return false;
			}
			if (!verdict__reason.isOmit() && !verdict__reason.isValue()) {
				return false;
			}
			if (!ptc__compref.isOmit() && !ptc__compref.isValue()) {
				return false;
			}
			if (!ptc__name.isOmit() && !ptc__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FinalVerdictInfo other_value) {
			return match(other_value, false);
		}

		public boolean match(final FinalVerdictInfo other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getIs__ptc().isBound()) {
					return false;
				}
				if(!is__ptc.match(other_value.getIs__ptc(), legacy)) {
					return false;
				}
				if(!other_value.getPtc__verdict().isBound()) {
					return false;
				}
				if(!ptc__verdict.match(other_value.getPtc__verdict(), legacy)) {
					return false;
				}
				if(!other_value.getLocal__verdict().isBound()) {
					return false;
				}
				if(!local__verdict.match(other_value.getLocal__verdict(), legacy)) {
					return false;
				}
				if(!other_value.getNew__verdict().isBound()) {
					return false;
				}
				if(!new__verdict.match(other_value.getNew__verdict(), legacy)) {
					return false;
				}
				if(!other_value.getVerdict__reason().isBound()) {
					return false;
				}
				if((other_value.getVerdict__reason().isPresent() ? !verdict__reason.match(other_value.getVerdict__reason().get(), legacy) : !verdict__reason.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getPtc__compref().isBound()) {
					return false;
				}
				if((other_value.getPtc__compref().isPresent() ? !ptc__compref.match(other_value.getPtc__compref().get(), legacy) : !ptc__compref.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getPtc__name().isBound()) {
					return false;
				}
				if((other_value.getPtc__name().isPresent() ? !ptc__name.match(other_value.getPtc__name().get(), legacy) : !ptc__name.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof FinalVerdictInfo) {
		return match((FinalVerdictInfo)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type FinalVerdictInfo.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				if (verdict__reason.isPresent()) {
					sizeof++;
				}
				if (ptc__compref.isPresent()) {
					sizeof++;
				}
				if (ptc__name.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictInfo containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" is_ptc := ");
				is__ptc.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc_verdict := ");
				ptc__verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" local_verdict := ");
				local__verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" new_verdict := ");
				new__verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" verdict_reason := ");
				verdict__reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc_compref := ");
				ptc__compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc_name := ");
				ptc__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FinalVerdictInfo match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FinalVerdictInfo) {
				log_match((FinalVerdictInfo)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictInfo.");
		}

		public void log_match(final FinalVerdictInfo match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !is__ptc.match(match_value.constGetIs__ptc(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".is_ptc");
							is__ptc.log_match(match_value.constGetIs__ptc(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ptc__verdict.match(match_value.constGetPtc__verdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ptc_verdict");
							ptc__verdict.log_match(match_value.constGetPtc__verdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !local__verdict.match(match_value.constGetLocal__verdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".local_verdict");
							local__verdict.log_match(match_value.constGetLocal__verdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !new__verdict.match(match_value.constGetNew__verdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".new_verdict");
							new__verdict.log_match(match_value.constGetNew__verdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetVerdict__reason().isPresent()) {
							if( !verdict__reason.match(match_value.constGetVerdict__reason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".verdict_reason");
								verdict__reason.log_match(match_value.constGetVerdict__reason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!verdict__reason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".verdict_reason := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								verdict__reason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetPtc__compref().isPresent()) {
							if( !ptc__compref.match(match_value.constGetPtc__compref().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ptc_compref");
								ptc__compref.log_match(match_value.constGetPtc__compref().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ptc__compref.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ptc_compref := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								ptc__compref.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetPtc__name().isPresent()) {
							if( !ptc__name.match(match_value.constGetPtc__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".ptc_name");
								ptc__name.log_match(match_value.constGetPtc__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!ptc__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".ptc_name := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								ptc__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ is_ptc := ");
				is__ptc.log_match(match_value.constGetIs__ptc(), legacy);
				TTCN_Logger.log_event_str("{ ptc_verdict := ");
				ptc__verdict.log_match(match_value.constGetPtc__verdict(), legacy);
				TTCN_Logger.log_event_str("{ local_verdict := ");
				local__verdict.log_match(match_value.constGetLocal__verdict(), legacy);
				TTCN_Logger.log_event_str("{ new_verdict := ");
				new__verdict.log_match(match_value.constGetNew__verdict(), legacy);
				TTCN_Logger.log_event_str("{ verdict_reason := ");
				verdict__reason.log_match(match_value.constGetVerdict__reason(), legacy);
				TTCN_Logger.log_event_str("{ ptc_compref := ");
				ptc__compref.log_match(match_value.constGetPtc__compref(), legacy);
				TTCN_Logger.log_event_str("{ ptc_name := ");
				ptc__name.log_match(match_value.constGetPtc__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				is__ptc.encode_text(text_buf);
				ptc__verdict.encode_text(text_buf);
				local__verdict.encode_text(text_buf);
				new__verdict.encode_text(text_buf);
				verdict__reason.encode_text(text_buf);
				ptc__compref.encode_text(text_buf);
				ptc__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				is__ptc = new TitanBoolean_template();
				is__ptc.decode_text(text_buf);
				ptc__verdict = new Verdict_template();
				ptc__verdict.decode_text(text_buf);
				local__verdict = new Verdict_template();
				local__verdict.decode_text(text_buf);
				new__verdict = new Verdict_template();
				new__verdict.decode_text(text_buf);
				verdict__reason = new TitanCharString_template();
				verdict__reason.decode_text(text_buf);
				ptc__compref = new TitanInteger_template();
				ptc__compref.decode_text(text_buf);
				ptc__name = new TitanCharString_template();
				ptc__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FinalVerdictInfo_template>(size);
				for(int i = 0; i < size; i++) {
					final FinalVerdictInfo_template temp = new FinalVerdictInfo_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FinalVerdictInfo.");
			}
		}
}
public static void FinalVerdictInfo_encoder(final FinalVerdictInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_decoder( final TitanOctetString input_stream, final FinalVerdictInfo output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TimerEvent extends Base_Type {
		private final TimerEvent_choice choice; //TTCN3_Choice_Type

		public TimerEvent() {
			choice = new TimerEvent_choice();
		}

		public TimerEvent( final TimerEvent_choice aChoice ) {
			choice = new TimerEvent_choice( aChoice );
		}

		public TimerEvent( final TimerEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerEvent.");
			}
			choice = new TimerEvent_choice();
			assign( aOtherValue );
		}
		public TimerEvent assign(final TimerEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimerEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimerEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerEvent ) {
				return assign((TimerEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimerEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimerEvent ) {
				return operatorEquals((TimerEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerEvent", otherValue));
		}

		public TimerEvent_choice getChoice() {
			return choice;
		}

		public TimerEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TimerEvent_template extends Base_Template {

	private TimerEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<TimerEvent_template> list_value;

	public TimerEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public TimerEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.TimerEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new TimerEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TimerEvent_template() {
	}

	public TimerEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TimerEvent_template( final TimerEvent otherValue ) {
		copyValue(otherValue);
	}

	public TimerEvent_template( final TimerEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TimerEvent_template( final Optional<TimerEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public TimerEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TimerEvent_template assign( final TimerEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TimerEvent_template assign( final TimerEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TimerEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerEvent) {
				return assign((TimerEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TimerEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimerEvent_template) {
				return assign((TimerEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerEvent' can not be cast to {1}_template", otherValue));
		}

	public TimerEvent_template assign( final Optional<TimerEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerEvent.");
		}
		return this;
	}

	private void copyValue(final TimerEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TimerEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TimerEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TimerEvent_template temp = new TimerEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerEvent.");
			}
			final TimerEvent ret_val = new TimerEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public TimerEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimerEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TimerEvent) {
		return match((TimerEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimerEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerEvent) {
				log_match((TimerEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.");
		}

		public void log_match(final TimerEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new TimerEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final TimerEvent_template temp = new TimerEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerEvent.");
			}
		}
}
public static void TimerEvent_encoder(final TimerEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_decoder( final TitanOctetString input_stream, final TimerEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class MatchingSuccessType extends Base_Type {
		private final PortType port__type; //Referenced_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanCharString info; //CharString_Type

		public MatchingSuccessType() {
			port__type = new PortType();
			port__name = new TitanCharString();
			info = new TitanCharString();
		}

		public MatchingSuccessType( final PortType aPort__type, final TitanCharString aPort__name, final TitanCharString aInfo ) {
			port__type = new PortType( aPort__type );
			port__name = new TitanCharString( aPort__name );
			info = new TitanCharString( aInfo );
		}

		public MatchingSuccessType( final MatchingSuccessType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingSuccessType.");
			}
			port__type = new PortType();
			port__name = new TitanCharString();
			info = new TitanCharString();
			assign( aOtherValue );
		}
		public MatchingSuccessType assign(final MatchingSuccessType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingSuccessType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__type().isBound() ) {
					this.port__type.assign( aOtherValue.getPort__type() );
				} else {
					this.port__type.cleanUp();
				}
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getInfo().isBound() ) {
					this.info.assign( aOtherValue.getInfo() );
				} else {
					this.info.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingSuccessType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingSuccessType ) {
				return assign((MatchingSuccessType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingSuccessType", otherValue));
		}

		public void cleanUp() {
			port__type.cleanUp();
			port__name.cleanUp();
			info.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__type.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( info.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__type.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !info.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingSuccessType aOtherValue ) {
			if ( !this.port__type.operatorEquals( aOtherValue.port__type ) ) { return false; }
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.info.operatorEquals( aOtherValue.info ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingSuccessType ) {
				return operatorEquals((MatchingSuccessType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingSuccessType", otherValue));
		}

		public PortType getPort__type() {
			return port__type;
		}

		public PortType constGetPort__type() {
			return port__type;
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanCharString getInfo() {
			return info;
		}

		public TitanCharString constGetInfo() {
			return info;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_type := ");
			port__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" info := ");
			info.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__type.isBound()) {
				port__type.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (info.isBound()) {
				info.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__type.encode_text(text_buf);
			port__name.encode_text(text_buf);
			info.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__type.decode_text(text_buf);
			port__name.decode_text(text_buf);
			info.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class MatchingSuccessType_template extends Base_Template {

	private PortType_template port__type; //Referenced_Type
	private TitanCharString_template port__name; //CharString_Type
	private TitanCharString_template info; //CharString_Type
	//originally value_list/list_value
	List<MatchingSuccessType_template> list_value;

	public PortType_template getPort__type() {
		setSpecific();
		return port__type;
	}

	public PortType_template constGetPort__type() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_type of a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
		}
		return port__type;
	}

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
		}
		return port__name;
	}

	public TitanCharString_template getInfo() {
		setSpecific();
		return info;
	}

	public TitanCharString_template constGetInfo() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field info of a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
		}
		return info;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__type = new PortType_template();
			port__name = new TitanCharString_template();
			info = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__type.assign(template_sel.ANY_VALUE);
				port__name.assign(template_sel.ANY_VALUE);
				info.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public MatchingSuccessType_template() {
	}

	public MatchingSuccessType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public MatchingSuccessType_template( final MatchingSuccessType otherValue ) {
		copyValue(otherValue);
	}

	public MatchingSuccessType_template( final MatchingSuccessType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public MatchingSuccessType_template( final Optional<MatchingSuccessType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingSuccessType from an unbound optional field.");
		}
	}

	//originally operator=
	public MatchingSuccessType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public MatchingSuccessType_template assign( final MatchingSuccessType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public MatchingSuccessType_template assign( final MatchingSuccessType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public MatchingSuccessType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingSuccessType) {
				return assign((MatchingSuccessType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingSuccessType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingSuccessType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingSuccessType_template) {
				return assign((MatchingSuccessType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingSuccessType' can not be cast to {1}_template", otherValue));
		}

	public MatchingSuccessType_template assign( final Optional<MatchingSuccessType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingSuccessType.");
		}
		return this;
	}

	private void copyValue(final MatchingSuccessType other_value) {
		if (other_value.getPort__type().isBound()) {
			getPort__type().assign(other_value.getPort__type());
		} else {
			getPort__type().cleanUp();
		}
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getInfo().isBound()) {
			getInfo().assign(other_value.getInfo());
		} else {
			getInfo().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final MatchingSuccessType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__type().get_selection()) {
				getPort__type().cleanUp();
			} else {
				getPort__type().assign(other_value.getPort__type());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getInfo().get_selection()) {
				getInfo().cleanUp();
			} else {
				getInfo().assign(other_value.getInfo());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<MatchingSuccessType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final MatchingSuccessType_template temp = new MatchingSuccessType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingSuccessType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingSuccessType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			final MatchingSuccessType ret_val = new MatchingSuccessType();
			 if (port__type.isBound()) {
				ret_val.port__type.assign(port__type.valueOf());
			}
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (info.isBound()) {
				ret_val.info.assign(info.valueOf());
			}
			return ret_val;
		}

		public MatchingSuccessType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingSuccessType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingSuccessType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingSuccessType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__type.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (info.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__type.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!info.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingSuccessType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingSuccessType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__type().isBound()) {
					return false;
				}
				if(!port__type.match(other_value.getPort__type(), legacy)) {
					return false;
				}
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getInfo().isBound()) {
					return false;
				}
				if(!info.match(other_value.getInfo(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingSuccessType) {
		return match((MatchingSuccessType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingSuccessType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingSuccessType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_type := ");
				port__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" info := ");
				info.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingSuccessType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingSuccessType) {
				log_match((MatchingSuccessType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingSuccessType.");
		}

		public void log_match(final MatchingSuccessType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__type.match(match_value.constGetPort__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_type");
							port__type.log_match(match_value.constGetPort__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !info.match(match_value.constGetInfo(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".info");
							info.log_match(match_value.constGetInfo(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_type := ");
				port__type.log_match(match_value.constGetPort__type(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ info := ");
				info.log_match(match_value.constGetInfo(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type.encode_text(text_buf);
				port__name.encode_text(text_buf);
				info.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type = new PortType_template();
				port__type.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				info = new TitanCharString_template();
				info.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingSuccessType_template>(size);
				for(int i = 0; i < size; i++) {
					final MatchingSuccessType_template temp = new MatchingSuccessType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingSuccessType.");
			}
		}
}
public static void MatchingSuccessType_encoder(final MatchingSuccessType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingSuccessType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingSuccessType_decoder( final TitanOctetString input_stream, final MatchingSuccessType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingSuccessType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Proc__port__out extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final Port__oper operation; //Referenced_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString sys__name; //CharString_Type
		private final TitanCharString parameter; //CharString_Type

		public Proc__port__out() {
			port__name = new TitanCharString();
			operation = new Port__oper();
			compref = new TitanInteger();
			sys__name = new TitanCharString();
			parameter = new TitanCharString();
		}

		public Proc__port__out( final TitanCharString aPort__name, final Port__oper aOperation, final TitanInteger aCompref, final TitanCharString aSys__name, final TitanCharString aParameter ) {
			port__name = new TitanCharString( aPort__name );
			operation = new Port__oper( aOperation );
			compref = new TitanInteger( aCompref );
			sys__name = new TitanCharString( aSys__name );
			parameter = new TitanCharString( aParameter );
		}

		public Proc__port__out( final Proc__port__out aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Proc_port_out.");
			}
			port__name = new TitanCharString();
			operation = new Port__oper();
			compref = new TitanInteger();
			sys__name = new TitanCharString();
			parameter = new TitanCharString();
			assign( aOtherValue );
		}
		public Proc__port__out assign(final Proc__port__out aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Proc_port_out");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getSys__name().isBound() ) {
					this.sys__name.assign( aOtherValue.getSys__name() );
				} else {
					this.sys__name.cleanUp();
				}
				if ( aOtherValue.getParameter().isBound() ) {
					this.parameter.assign( aOtherValue.getParameter() );
				} else {
					this.parameter.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Proc__port__out assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__out ) {
				return assign((Proc__port__out) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_out", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			operation.cleanUp();
			compref.cleanUp();
			sys__name.cleanUp();
			parameter.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( sys__name.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !sys__name.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Proc__port__out aOtherValue ) {
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.sys__name.operatorEquals( aOtherValue.sys__name ) ) { return false; }
			if ( !this.parameter.operatorEquals( aOtherValue.parameter ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__out ) {
				return operatorEquals((Proc__port__out) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_out", otherValue));
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public Port__oper getOperation() {
			return operation;
		}

		public Port__oper constGetOperation() {
			return operation;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanCharString getSys__name() {
			return sys__name;
		}

		public TitanCharString constGetSys__name() {
			return sys__name;
		}

		public TitanCharString getParameter() {
			return parameter;
		}

		public TitanCharString constGetParameter() {
			return parameter;
		}

		public TitanInteger sizeOf() {
			int sizeof = 5;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sys_name := ");
			sys__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (sys__name.isBound()) {
				sys__name.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			operation.encode_text(text_buf);
			compref.encode_text(text_buf);
			sys__name.encode_text(text_buf);
			parameter.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			operation.decode_text(text_buf);
			compref.decode_text(text_buf);
			sys__name.decode_text(text_buf);
			parameter.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Proc__port__out_template extends Base_Template {

	private TitanCharString_template port__name; //CharString_Type
	private Port__oper_template operation; //Referenced_Type
	private TitanInteger_template compref; //Integer_Type
	private TitanCharString_template sys__name; //CharString_Type
	private TitanCharString_template parameter; //CharString_Type
	//originally value_list/list_value
	List<Proc__port__out_template> list_value;

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
		}
		return port__name;
	}

	public Port__oper_template getOperation() {
		setSpecific();
		return operation;
	}

	public Port__oper_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
		}
		return operation;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
		}
		return compref;
	}

	public TitanCharString_template getSys__name() {
		setSpecific();
		return sys__name;
	}

	public TitanCharString_template constGetSys__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field sys_name of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
		}
		return sys__name;
	}

	public TitanCharString_template getParameter() {
		setSpecific();
		return parameter;
	}

	public TitanCharString_template constGetParameter() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Proc_port_out.");
		}
		return parameter;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__name = new TitanCharString_template();
			operation = new Port__oper_template();
			compref = new TitanInteger_template();
			sys__name = new TitanCharString_template();
			parameter = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__name.assign(template_sel.ANY_VALUE);
				operation.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				sys__name.assign(template_sel.ANY_VALUE);
				parameter.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Proc__port__out_template() {
	}

	public Proc__port__out_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Proc__port__out_template( final Proc__port__out otherValue ) {
		copyValue(otherValue);
	}

	public Proc__port__out_template( final Proc__port__out_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Proc__port__out_template( final Optional<Proc__port__out> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Proc_port_out from an unbound optional field.");
		}
	}

	//originally operator=
	public Proc__port__out_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Proc__port__out_template assign( final Proc__port__out other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Proc__port__out_template assign( final Proc__port__out_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Proc__port__out_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__out) {
				return assign((Proc__port__out) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__out' can not be cast to {1}", otherValue));
		}

		@Override
		public Proc__port__out_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Proc__port__out_template) {
				return assign((Proc__port__out_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__out' can not be cast to {1}_template", otherValue));
		}

	public Proc__port__out_template assign( final Optional<Proc__port__out> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Proc_port_out.");
		}
		return this;
	}

	private void copyValue(final Proc__port__out other_value) {
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getSys__name().isBound()) {
			getSys__name().assign(other_value.getSys__name());
		} else {
			getSys__name().cleanUp();
		}
		if (other_value.getParameter().isBound()) {
			getParameter().assign(other_value.getParameter());
		} else {
			getParameter().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Proc__port__out_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSys__name().get_selection()) {
				getSys__name().cleanUp();
			} else {
				getSys__name().assign(other_value.getSys__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParameter().get_selection()) {
				getParameter().cleanUp();
			} else {
				getParameter().assign(other_value.getParameter());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Proc__port__out_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Proc__port__out_template temp = new Proc__port__out_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Proc_port_out.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Proc__port__out valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Proc_port_out.");
			}
			final Proc__port__out ret_val = new Proc__port__out();
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (sys__name.isBound()) {
				ret_val.sys__name.assign(sys__name.valueOf());
			}
			 if (parameter.isBound()) {
				ret_val.parameter.assign(parameter.valueOf());
			}
			return ret_val;
		}

		public Proc__port__out_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Proc_port_out.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Proc_port_out.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Proc_port_out.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Proc__port__out_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Proc__port__out_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (sys__name.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!sys__name.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Proc__port__out other_value) {
			return match(other_value, false);
		}

		public boolean match(final Proc__port__out other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getSys__name().isBound()) {
					return false;
				}
				if(!sys__name.match(other_value.getSys__name(), legacy)) {
					return false;
				}
				if(!other_value.getParameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getParameter(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Proc__port__out) {
		return match((Proc__port__out)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Proc__port__out.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 5;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_out containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sys_name := ");
				sys__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Proc__port__out match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Proc__port__out) {
				log_match((Proc__port__out)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Proc_port_out.");
		}

		public void log_match(final Proc__port__out match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !sys__name.match(match_value.constGetSys__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sys_name");
							sys__name.log_match(match_value.constGetSys__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetParameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetParameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ sys_name := ");
				sys__name.log_match(match_value.constGetSys__name(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetParameter(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				operation.encode_text(text_buf);
				compref.encode_text(text_buf);
				sys__name.encode_text(text_buf);
				parameter.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_out.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				operation = new Port__oper_template();
				operation.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				sys__name = new TitanCharString_template();
				sys__name.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Proc__port__out_template>(size);
				for(int i = 0; i < size; i++) {
					final Proc__port__out_template temp = new Proc__port__out_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Proc_port_out.");
			}
		}
}
public static void Proc__port__out_encoder(final Proc__port__out input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__out_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__out_decoder( final TitanOctetString input_stream, final Proc__port__out output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__out_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void VerdictOp_choice_setVerdict_encoder(final SetVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictOp_choice_setVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictOp_choice_setVerdict_decoder( final TitanOctetString input_stream, final SetVerdictType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictOp_choice_setVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Strings_str__list extends Base_Type {

	private List<TitanCharString> valueElements;

	public Strings_str__list() {
	}

	public Strings_str__list( final Strings_str__list otherValue ) {
		otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.Strings.str_list.");
		valueElements = copyList( otherValue.valueElements );
	}

	public Strings_str__list(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanCharString>();
	}

	private static final List<TitanCharString> copyList( final List<TitanCharString> srcList ) {
		if ( srcList == null ) {
			return null;
		}

		final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
		for (final TitanCharString srcElem : srcList) {
			final TitanCharString newElem = getUnboundElem();
			if (srcElem.isBound()) {
				newElem.assign( srcElem );
			}
			newList.add( ( newElem ) );
		}
		return newList;
	}

	@Override
	public boolean isPresent() {
		return isBound();
	}

	@Override
	public boolean isBound() {
		return valueElements != null;
	}

	public void mustBound( final String aErrorMessage ) {
		if ( !isBound() ) {
			throw new TtcnError( aErrorMessage );
		}
	}

	@Override
	public boolean isValue() {
		if (valueElements == null) {
			return false;
		}
		for (int i=0; i < valueElements.size(); i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem == null || !elem.isValue()) {
				return false;
			}
		}
		return true;
	}


	@Override
	public boolean operatorEquals(final Base_Type otherValue) {
		if (otherValue instanceof Strings_str__list) {
			return operatorEquals((Strings_str__list)otherValue);
		}
		throw new TtcnError("Internal Error: The left operand of comparison is not of type Strings_str__list.");
	}

	//originally operator==
	public boolean operatorEquals( final Strings_str__list otherValue ) {
		mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.Strings.str_list.");
		otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.Strings.str_list.");

		final int size = valueElements.size();
		if ( size != otherValue.valueElements.size() ) {
			return false;
		}

		for ( int i = 0; i < size; i++ ) {
			final TitanCharString leftElem = valueElements.get( i );
			final TitanCharString rightElem = otherValue.valueElements.get( i );
			if (leftElem.isBound()) {
				if (rightElem.isBound()) {
					if ( !leftElem.operatorEquals( rightElem ) ) {
						return false;
					}
				} else {
					return false;
				}
			} else if (rightElem.isBound()) {
				return false;
			}
		}

		return true;
	}

	@Override
	public Strings_str__list assign(final Base_Type otherValue) {
	if (otherValue instanceof Strings_str__list) {
		return assign((Strings_str__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list.");
	}

	//originally operator=
	public Strings_str__list assign( final Strings_str__list aOtherValue ) {
		aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.Strings.str_list." );

		valueElements = copyList( aOtherValue.valueElements );
		return this;
	}

	public Strings_str__list assign(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanCharString>();
		return this;
	}

	//originally operator+
	public Strings_str__list concatenate(final Strings_str__list other_value) {
		if (valueElements == null || other_value.valueElements == null) {
			throw new TtcnError("Unbound operand of @TitanLoggerApi.Strings.str_list concatenation.");
		}
		final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i < valueElements.size(); i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < other_value.valueElements.size(); i++) {
			final TitanCharString elem = other_value.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}

	public Strings_str__list concatenate(final TitanNull_Type nullValue) {
		return new Strings_str__list(this);
	}

	//originally operator<<=
	public Strings_str__list rotateLeft(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate left operator.");
		return rotateLeft(rotate_count.getInt());
	}

	//originally operator<<=
	public Strings_str__list rotateLeft(final int rotate_count) {
		return rotateRight(-rotate_count);
	}

	//originally operator>>=
	public Strings_str__list rotateRight(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate right operator.");
		return rotateRight(rotate_count.getInt());
	}

	//originally operator>>=
	public Strings_str__list rotateRight(final int rotate_count) {
		if (valueElements == null) {
			throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.Strings.str_list.");
		}
		final int size = valueElements.size();
		if (size == 0) {
			return new Strings_str__list(TitanNull_Type.NULL_VALUE);
		}
		int rc;
		if (rotate_count >= 0) {
			rc = rotate_count % size;
		} else {
			rc = size - ((-rotate_count) % size);
		}
		if (rc == 0) {
			return new Strings_str__list(this);
		}
		final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
		for (int i = size - rc; i < size; i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < size - rc; i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}

	//originally clean_up
	public void cleanUp() {
		valueElements = null;
	}

	//originally get_at(int)
	public TitanCharString getAt( final int index_value ) {
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.Strings.str_list using a negative index: "+index_value+".");
		}

		if (valueElements == null || index_value >= valueElements.size() ) {
			//increase list size
			setSize(index_value + 1);
		}

		if ( valueElements.get( index_value ) == null ) {
			final TitanCharString newElem = getUnboundElem();
			valueElements.set( index_value, newElem );
		}
		return valueElements.get( index_value );
	}

	//originally get_at(const INTEGER&)
	public TitanCharString getAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.Strings.str_list." );
		return getAt( index_value.getInt() );
	}

	//originally get_at(int) const
	public TitanCharString constGetAt( final int index_value ) {
		if ( !isBound() ) {
			throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.Strings.str_list." );
		}
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.Strings.str_list using a negative index: "+index_value+".");
		}
		final int nofElements = n_elem().getInt();
		if ( index_value >= nofElements ) {
			throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.Strings.str_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
		}

		final TitanCharString elem = valueElements.get( index_value );
		return ( elem != null ) ? elem : getUnboundElem();
	}

	//originally get_at(const INTEGER&) const
	public TitanCharString constGetAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.Strings.str_list." );
		return constGetAt( index_value.getInt() );
	}

	public TitanInteger sizeOf() {
		mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.Strings.str_list.");
		return new TitanInteger(valueElements.size());
	}

	public TitanInteger n_elem() {
		return sizeOf();
	}

	public TitanInteger lengthOf() {
		mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.Strings.str_list.");
		for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
			final TitanCharString elem = valueElements.get( i );
			if ( elem != null && elem.isBound() ) {
				return new TitanInteger(i + 1);
			}
		}
		return new TitanInteger(0);
	}

	public void setSize(final int newSize) {
		if (newSize < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.Strings.str_list.");
		}
		if ( valueElements == null ) {
			valueElements = new ArrayList<TitanCharString>();
		}
		if (newSize > valueElements.size()) {
			for ( int i = valueElements.size(); i < newSize; i++ ) {
				valueElements.add( new TitanCharString() );
			}
		} else if (newSize < valueElements.size()) {
			while(valueElements.size() > newSize) {
				valueElements.remove(valueElements.size()-1);
			}
		}
	}

	private static TitanCharString getUnboundElem() {
		return new TitanCharString();
	}
/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */

	@Override
	public String toString() {
		if (!isBound()) {
			return "<unbound>";
		}
		final StringBuilder sb = new StringBuilder();
		sb.append('{');
		final int size = ( valueElements == null ) ? 0 : valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				sb.append(',');
			}
			sb.append(valueElements.get(i).toString());
		}
		sb.append('}');
		return sb.toString();
	}

	public Strings_str__list substr(final int index, final int returncount) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.Strings.str_list.");
		}
		AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.Strings.str_list","element");
		final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i<returncount; i++) {
			if (valueElements.get(i+index) != null) {
				ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
			}
		}
		return ret_val;
	}

	public Strings_str__list replace(final int index, final int len, final Strings_str__list repl) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.Strings.str_list.");
		}
		if (repl.valueElements == null) {
			throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.Strings.str_list.");
		}
		AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.Strings.str_list","element");
		final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
		for (int i = 0; i < index; i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < repl.valueElements.size(); i++) {
			final TitanCharString elem = repl.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < valueElements.size() - index - len; i++) {
			final TitanCharString elem = valueElements.get(index + i + len);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}

	public Strings_str__list replace(final int index, final int len, final Strings_str__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len, repl.valueOf());
	}

	public Strings_str__list replace(final int index, final TitanInteger len, final Strings_str__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len.getInt(), repl.valueOf());
	}

	public Strings_str__list replace(final TitanInteger index, final int len, final Strings_str__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len, repl.valueOf());
	}

	public Strings_str__list replace(final TitanInteger index, final TitanInteger len, final Strings_str__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len.getInt(), repl.valueOf());
	}
	public void log() {
		if (valueElements == null) {
			TTCN_Logger.log_event_unbound();
			return;
		}
		TTCN_Logger.log_event_str("{ ");
		final int size = valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				TTCN_Logger.log_event_str(", ");
			}
		valueElements.get(i).log();
		}
		TTCN_Logger.log_event_str(" }");
	}
		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.Strings.str_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

}
public static class Strings_str__list_template extends Record_Of_Template {

	//originally single_value/value_elements
	List<TitanCharString_template> value_elements;

	//originally value_list/list_value
	List<Strings_str__list_template> list_value;

	private final match_function_t match_function_specific = new match_function_t() {
		@Override
		public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
			return match_index((Strings_str__list)value_ptr, value_index, (Strings_str__list_template)template_ptr, template_index, legacy);
		}
	};

	public Strings_str__list_template() {
	}

	public Strings_str__list_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Strings_str__list_template( final Strings_str__list otherValue ) {
		copy_value( otherValue );
	}

	public Strings_str__list_template( final Strings_str__list_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Strings_str__list_template( final Optional<Strings_str__list> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Strings.str_list from an unbound optional field.");
		}
	}

	public Strings_str__list_template( final TitanNull_Type nullValue ) {
		super( template_sel.SPECIFIC_VALUE );
		value_elements = new ArrayList<TitanCharString_template>();
	}

	private void copy_value(final Strings_str__list other_value) {
		if (!other_value.isBound()) {
			throw new TtcnError("Initialization of a template of type @TitanLoggerApi.Strings.str_list with an unbound value.");
		}
		value_elements = new ArrayList<TitanCharString_template>();
		final int otherSize = other_value.valueElements.size();
		for (int elem_count = 0; elem_count < otherSize; elem_count++) {
			if (other_value.constGetAt(elem_count).isBound()) {
				value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
			} else {
				value_elements.add( new TitanCharString_template() );
			}
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Strings_str__list_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.value_elements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Strings_str__list_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Strings_str__list_template temp = new Strings_str__list_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Strings.str_list.");
		}
		set_selection(other_value);
	}

	public boolean isPresent() {
		return isPresent(false);
	}

	public boolean isPresent(final boolean legacy) {
		if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
			return false;
		}
		return !match_omit(legacy);
	}

	// originally match
	public boolean match(final Strings_str__list other_value) {
		return match(other_value, false);
	}

	// originally match
	public boolean match(final Strings_str__list other_value, final boolean legacy) {
		if(!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case OMIT_VALUE:
			return false;
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for(int i = 0 ; i < list_value.size(); i++) {
				if(list_value.get(i).match(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
				}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.Strings.str_list.");
		}
	}

	private boolean match_index(final Strings_str__list value_ptr, final int value_index, final Strings_str__list_template template_ptr, final int template_index, final boolean legacy) {
		if (value_index >= 0) {
			return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
		} else {
			return template_ptr.value_elements.get(template_index).is_any_or_omit();
		}
	}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
		if (otherValue instanceof Strings_str__list) {
			return match((Strings_str__list)otherValue, legacy);
		}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list.");
	}

	public boolean match_omit(final boolean legacy) {
		if (is_ifPresent) {
			return true;
		}
		switch (templateSelection) {
		case OMIT_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			if (legacy) {
				for (int i = 0 ; i < list_value.size(); i++) {
					if (list_value.get(i).match_omit(legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			}
			return false;
		default:
			return false;
		}
	}

	//originally operator=
	public Strings_str__list_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Strings_str__list_template assign( final Strings_str__list other_value ) {
		cleanUp();
		copy_value(other_value);
		return this;
	}

	//originally operator=
	public Strings_str__list_template assign( final Strings_str__list_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

	@Override
	public Strings_str__list_template assign(final Base_Type otherValue) {
	if (otherValue instanceof Strings_str__list) {
		return assign((Strings_str__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list.");
	}

	@Override
	public Strings_str__list_template assign(final Base_Template otherValue) {
	if (otherValue instanceof Strings_str__list_template) {
		return assign((Strings_str__list_template)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings_str__list_template.");
	}

	public Strings_str__list_template assign( final Optional<Strings_str__list> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Strings.str_list.");
		}
		return this;
	}

	@Override
	public void cleanUp() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			value_elements.clear();
			value_elements = null;
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value.clear();
			list_value = null;
			break;
		default:
			break;
		}
		templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
	}

	public Strings_str__list replace(final int index, final int len, final Strings_str__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl.valueOf());
	}

	public Strings_str__list replace(final TitanInteger index, final TitanInteger len, final Strings_str__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
	}

	public Strings_str__list replace(final int index, final int len, final Strings_str__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl);
	}

	public Strings_str__list replace(final TitanInteger index, final TitanInteger len, final Strings_str__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl);
	}

	public TitanCharString_template getAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.Strings.str_list using a negative index: {0}.", index_value ) );
		}

		switch (templateSelection) {
		case SPECIFIC_VALUE:
			if(index_value < value_elements.size()) {

				break;
			}
			// no break
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case UNINITIALIZED_TEMPLATE:
			setSize(index_value + 1);
			break;
		default:
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.Strings.str_list.");
		}
		return value_elements.get(index_value);
	}

	public TitanCharString_template getAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.Strings.str_list.");
		}

		return getAt(index_value.getInt());
	}

	public TitanCharString_template constGetAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.Strings.str_list using a negative index: {0}.", index_value ) );
		}

		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.Strings.str_list.");
		}

		if (index_value >= value_elements.size()) {
			throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.Strings.str_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
		}

		return value_elements.get(index_value);
	}

	public TitanCharString_template constGetAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.Strings.str_list.");
		}

		return constGetAt(index_value.getInt());
	}

	private int get_length_for_concat(final AtomicBoolean is_any_value) {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return value_elements.size();
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				if (templateSelection == template_sel.ANY_VALUE) {
					// ? => { * }
					is_any_value.set( true );
					return 1;
				}
				throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
			case RANGE_LENGTH_RESTRICTION:
				if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
					throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
				}
				// else fall through (range length restriction is allowed if the minimum
				// and maximum value are the same)
			case SINGLE_LENGTH_RESTRICTION:
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
			}
		default:
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}
	}

	private int get_length_for_concat(final Strings_str__list operand) {
		operand.mustBound("Operand of record of template concatenation is an unbound value.");
		return operand.valueElements.size();
	}


	private int get_length_for_concat(final template_sel operand) {
		if (operand == template_sel.ANY_VALUE) {
			// ? => { * }
			return 1;
		}
		throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
	}

			//TODO: simplify, just use value_elements.add()
	private void concat(final AtomicInteger pos, final Strings_str__list_template operand) {
		// all errors should have already been caught by the operand's
		// get_length_for_concat() call;
		// the result template (this) should already be set to SPECIFIC_VALUE and
		// single_value.value_elements should already be allocated
		switch (operand.templateSelection) {
		case SPECIFIC_VALUE:
			for (int i = 0; i < operand.value_elements.size(); ++i) {
				value_elements.set( pos.get() + i, new TitanCharString_template(operand.value_elements.get(i)) );
			}
			pos.addAndGet( operand.value_elements.size() );
			break;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (operand.length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				// ? => { * }
				value_elements.set( pos.get(), new TitanCharString_template( template_sel.ANY_OR_OMIT ) );
				pos.incrementAndGet();
				break;
			case RANGE_LENGTH_RESTRICTION:
			case SINGLE_LENGTH_RESTRICTION: {
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
				for (int i = 0; i < N; ++i) {
					value_elements.set( pos.get() + i, new TitanCharString_template( template_sel.ANY_VALUE ) );
				}
				pos.addAndGet( N );
				break; }
			}
		default:
			break;
		}
	}

	public void setSize(final int new_size) {
		if (new_size < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.Strings.str_list.");
		}
		final template_sel old_selection = templateSelection;
		if (old_selection != template_sel.SPECIFIC_VALUE) {
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = null;
		}
		if (value_elements == null) {
			value_elements = new ArrayList<TitanCharString_template>();
		}
		if (new_size > value_elements.size()) {
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
				}
			} else {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanCharString_template() );
				}
			}
		} else if (new_size < value_elements.size()) {
			final int oldSize = value_elements.size();
			for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
				value_elements.remove( new_size );
			}
		}
	}

	public TitanInteger sizeOf() {
		return sizeOf(true);
	}

	public TitanInteger lengthOf() {
		return sizeOf(false);
	}

	public TitanInteger sizeOf(final boolean is_size) {
		final String op_name = is_size ? "size" : "length";
		if (is_ifPresent) {
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list which has an ifpresent attribute.", op_name ) );
		}
		int min_size;
		boolean has_any_or_none;
		switch (templateSelection)
		{
		case SPECIFIC_VALUE: {
			min_size = 0;
			has_any_or_none = false;
			int elem_count = value_elements.size();
			if (!is_size) {
				while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
					elem_count--;
				}
			}
			for (int i=0; i<elem_count; i++)
			{
			switch (value_elements.get(i).get_selection())
				{
				case OMIT_VALUE:
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing omit element.", op_name ) );
				case ANY_OR_OMIT:
					has_any_or_none = true;
					break;
				default:
					min_size++;
					break;
				}
			}
		} break;
		case OMIT_VALUE:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing omit value.", op_name ) );
		case ANY_VALUE:
		case ANY_OR_OMIT:
			min_size = 0;
			has_any_or_none = true;
			break;
		case VALUE_LIST:
		{
			if (list_value.size()<1) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing an empty list.", op_name ) );
			}
			final int item_size = list_value.get(0).sizeOf(is_size).getInt();
			for (int i = 1; i < list_value.size(); i++) {
				if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing a value list with different sizes.", op_name ) );
				}
			}
			min_size = item_size;
			has_any_or_none = false;
			break;
		}
		case COMPLEMENTED_LIST:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.Strings.str_list containing complemented list.", op_name ) );
		default:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type Strings_str__list.", op_name ) );
		}
		return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
	}

	public TitanInteger n_elem() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return new TitanInteger(value_elements.size());
		case COMPLEMENTED_LIST:
			throw new TtcnError("Performing n_elem() operation on a template of type Strings_str__list containing complemented list.");
		case UNINITIALIZED_TEMPLATE:
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case VALUE_LIST:
		case VALUE_RANGE:
		case STRING_PATTERN:
		case SUPERSET_MATCH:
		case SUBSET_MATCH:
		case DECODE_MATCH:
			break;
		}
		throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type Strings_str__list.");
	}

	private boolean matchv(final Strings_str__list other_value, final boolean legacy) {
		if (!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case OMIT_VALUE:
			return false;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for (int list_count = 0; list_count < list_value.size(); list_count++) {
				if (list_value.get(list_count).matchv(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
		}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type Strings_str__list.");
		}
	}

	@Override
	public boolean isValue() {
		if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
			return false;
		}
		for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
			if (!value_elements.get(elem_count).isValue()) {
				return false;
			}
		}
		return true;
	}

	public void setType(final template_sel template_type, final int list_length) {
		cleanUp();
		switch (template_type) {
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Strings_str__list_template>( list_length );
			for (int list_count = 0; list_count < list_length; list_count++) {
				list_value.add( new Strings_str__list_template() );
			}
			break;
		default:
			throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.Strings.str_list.");
		}
		set_selection(template_type);
	}

		public Strings_str__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Strings.str_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Strings.str_list.");
			}
			return list_value.get(list_index);
		}

	public Strings_str__list_template get_list_item(final int list_index) {
		if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
			throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.Strings.str_list.");
		}
		if (list_index < 0) {
			throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.Strings.str_list using a negative index ({0}).", list_index ) );
		}
		if (list_index >= list_value.size()) {
			throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.Strings.str_list.");
		}
		return list_value.get( list_index );
	}

		public Strings_str__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Strings.str_list.");
			}
			final Strings_str__list ret_val = new Strings_str__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public Strings_str__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

	public void log_match(final Strings_str__list match_value) {
		log_match(match_value, false);
	}

	@Override
	public void log_match(final Base_Type match_value, final boolean legacy) {
		if (match_value instanceof Strings_str__list) {
			log_match((Strings_str__list)match_value, legacy);
			return;
		}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Strings.str_list.");
	}

	public void log_match(final Strings_str__list match_value, final boolean legacy) {
		if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
			if(match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
			} else {
				if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
						TTCN_Logger.log_logmatch_info("[%d]", elem_count);
							value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					}
					log_match_length(value_elements.size());
				} else {
					TTCN_Logger.print_logmatch_buffer();
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
			return;
		}
		if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
			TTCN_Logger.log_event_str("{ ");
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (elem_count > 0) {
					TTCN_Logger.log_event_str(", ");
				}
				value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
			}
			TTCN_Logger.log_event_str(" }");
			log_match_length(value_elements.size());
		} else {
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if ( match(match_value, legacy) ) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}
	}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Strings.str_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.Strings.str_list.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Strings_str__list_template>(size);
				for (int i = 0; i < size; i++) {
					final Strings_str__list_template temp2 = new Strings_str__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.Strings.str_list.");
			}
		}

	@Override
	public boolean get_istemplate_kind(final String type) {
		if ("AnyElement".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
			return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
					return true;
				}
			}
			return false;
		} else if ("AnyElementsOrNone".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
					return true;
				}
			}
			return false;
		} else if ("permutation".equals(type)) {
			return get_number_of_permutations() != 0;
		} else if ("length".equals(type)) {
			return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
		} else {
			return super.get_istemplate_kind(type);
		}
	}
}
public static void Strings_str__list_encoder(final Strings_str__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings.str_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Strings_str__list_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Strings_str__list_decoder( final TitanOctetString input_stream, final Strings_str__list output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings.str_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Strings_str__list_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ExecutorEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_ExecutorRuntime,  ALT_ExecutorConfigdata,  ALT_ExtcommandStart,  ALT_ExtcommandSuccess,  ALT_ExecutorComponent,  ALT_LogOptions,  ALT_ExecutorMisc };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public ExecutorEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public ExecutorEvent_choice(final ExecutorEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final ExecutorEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_ExecutorRuntime:
field = new ExecutorRuntime((ExecutorRuntime)otherValue.field);
break;
case ALT_ExecutorConfigdata:
field = new ExecutorConfigdata((ExecutorConfigdata)otherValue.field);
break;
case ALT_ExtcommandStart:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_ExtcommandSuccess:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_ExecutorComponent:
field = new ExecutorComponent((ExecutorComponent)otherValue.field);
break;
case ALT_LogOptions:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_ExecutorMisc:
field = new ExecutorUnqualified((ExecutorUnqualified)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.ExecutorEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public ExecutorEvent_choice assign( final ExecutorEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public ExecutorEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof ExecutorEvent_choice) {
return assign((ExecutorEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_ExecutorRuntime:
return field.isValue();
case ALT_ExecutorConfigdata:
return field.isValue();
case ALT_ExtcommandStart:
return field.isValue();
case ALT_ExtcommandSuccess:
return field.isValue();
case ALT_ExecutorComponent:
return field.isValue();
case ALT_LogOptions:
return field.isValue();
case ALT_ExecutorMisc:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final ExecutorEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.ExecutorEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.ExecutorEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_ExecutorRuntime:
return ((ExecutorRuntime)field).operatorEquals((ExecutorRuntime)otherValue.field);
case ALT_ExecutorConfigdata:
return ((ExecutorConfigdata)field).operatorEquals((ExecutorConfigdata)otherValue.field);
case ALT_ExtcommandStart:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_ExtcommandSuccess:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_ExecutorComponent:
return ((ExecutorComponent)field).operatorEquals((ExecutorComponent)otherValue.field);
case ALT_LogOptions:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_ExecutorMisc:
return ((ExecutorUnqualified)field).operatorEquals((ExecutorUnqualified)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof ExecutorEvent_choice) {
return operatorEquals((ExecutorEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final ExecutorEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public ExecutorRuntime getExecutorRuntime() {
if (union_selection != union_selection_type.ALT_ExecutorRuntime) {
cleanUp();
field = new ExecutorRuntime();
union_selection = union_selection_type.ALT_ExecutorRuntime;
}
return (ExecutorRuntime)field;
}

public ExecutorRuntime constGetExecutorRuntime() {
if (union_selection != union_selection_type.ALT_ExecutorRuntime) {
throw new TtcnError("Using non-selected field executorRuntime in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorRuntime)field;
}

public ExecutorConfigdata getExecutorConfigdata() {
if (union_selection != union_selection_type.ALT_ExecutorConfigdata) {
cleanUp();
field = new ExecutorConfigdata();
union_selection = union_selection_type.ALT_ExecutorConfigdata;
}
return (ExecutorConfigdata)field;
}

public ExecutorConfigdata constGetExecutorConfigdata() {
if (union_selection != union_selection_type.ALT_ExecutorConfigdata) {
throw new TtcnError("Using non-selected field executorConfigdata in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorConfigdata)field;
}

public TitanCharString getExtcommandStart() {
if (union_selection != union_selection_type.ALT_ExtcommandStart) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_ExtcommandStart;
}
return (TitanCharString)field;
}

public TitanCharString constGetExtcommandStart() {
if (union_selection != union_selection_type.ALT_ExtcommandStart) {
throw new TtcnError("Using non-selected field extcommandStart in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (TitanCharString)field;
}

public TitanCharString getExtcommandSuccess() {
if (union_selection != union_selection_type.ALT_ExtcommandSuccess) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_ExtcommandSuccess;
}
return (TitanCharString)field;
}

public TitanCharString constGetExtcommandSuccess() {
if (union_selection != union_selection_type.ALT_ExtcommandSuccess) {
throw new TtcnError("Using non-selected field extcommandSuccess in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (TitanCharString)field;
}

public ExecutorComponent getExecutorComponent() {
if (union_selection != union_selection_type.ALT_ExecutorComponent) {
cleanUp();
field = new ExecutorComponent();
union_selection = union_selection_type.ALT_ExecutorComponent;
}
return (ExecutorComponent)field;
}

public ExecutorComponent constGetExecutorComponent() {
if (union_selection != union_selection_type.ALT_ExecutorComponent) {
throw new TtcnError("Using non-selected field executorComponent in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorComponent)field;
}

public TitanCharString getLogOptions() {
if (union_selection != union_selection_type.ALT_LogOptions) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_LogOptions;
}
return (TitanCharString)field;
}

public TitanCharString constGetLogOptions() {
if (union_selection != union_selection_type.ALT_LogOptions) {
throw new TtcnError("Using non-selected field logOptions in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (TitanCharString)field;
}

public ExecutorUnqualified getExecutorMisc() {
if (union_selection != union_selection_type.ALT_ExecutorMisc) {
cleanUp();
field = new ExecutorUnqualified();
union_selection = union_selection_type.ALT_ExecutorMisc;
}
return (ExecutorUnqualified)field;
}

public ExecutorUnqualified constGetExecutorMisc() {
if (union_selection != union_selection_type.ALT_ExecutorMisc) {
throw new TtcnError("Using non-selected field executorMisc in a value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorUnqualified)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_ExecutorRuntime:
TTCN_Logger.log_event_str("{ executorRuntime := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExecutorConfigdata:
TTCN_Logger.log_event_str("{ executorConfigdata := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExtcommandStart:
TTCN_Logger.log_event_str("{ extcommandStart := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExtcommandSuccess:
TTCN_Logger.log_event_str("{ extcommandSuccess := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExecutorComponent:
TTCN_Logger.log_event_str("{ executorComponent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_LogOptions:
TTCN_Logger.log_event_str("{ logOptions := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExecutorMisc:
TTCN_Logger.log_event_str("{ executorMisc := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_ExecutorRuntime:
case ALT_ExecutorConfigdata:
case ALT_ExtcommandStart:
case ALT_ExtcommandSuccess:
case ALT_ExecutorComponent:
case ALT_LogOptions:
case ALT_ExecutorMisc:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_ExecutorRuntime:
text_buf.push_int(0);
break;
case ALT_ExecutorConfigdata:
text_buf.push_int(1);
break;
case ALT_ExtcommandStart:
text_buf.push_int(2);
break;
case ALT_ExtcommandSuccess:
text_buf.push_int(3);
break;
case ALT_ExecutorComponent:
text_buf.push_int(4);
break;
case ALT_LogOptions:
text_buf.push_int(5);
break;
case ALT_ExecutorMisc:
text_buf.push_int(6);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getExecutorRuntime().decode_text(text_buf);
break;
case 1:
getExecutorConfigdata().decode_text(text_buf);
break;
case 2:
getExtcommandStart().decode_text(text_buf);
break;
case 3:
getExtcommandSuccess().decode_text(text_buf);
break;
case 4:
getExecutorComponent().decode_text(text_buf);
break;
case 5:
getLogOptions().decode_text(text_buf);
break;
case 6:
getExecutorMisc().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.ExecutorEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class ExecutorEvent_choice_template extends Base_Template {
//if single value which value?
private ExecutorEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<ExecutorEvent_choice_template> value_list;

private void copy_value(final ExecutorEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_ExecutorRuntime:
single_value = new ExecutorRuntime_template(other_value.constGetExecutorRuntime());
break;
case ALT_ExecutorConfigdata:
single_value = new ExecutorConfigdata_template(other_value.constGetExecutorConfigdata());
break;
case ALT_ExtcommandStart:
single_value = new TitanCharString_template(other_value.constGetExtcommandStart());
break;
case ALT_ExtcommandSuccess:
single_value = new TitanCharString_template(other_value.constGetExtcommandSuccess());
break;
case ALT_ExecutorComponent:
single_value = new ExecutorComponent_template(other_value.constGetExecutorComponent());
break;
case ALT_LogOptions:
single_value = new TitanCharString_template(other_value.constGetLogOptions());
break;
case ALT_ExecutorMisc:
single_value = new ExecutorUnqualified_template(other_value.constGetExecutorMisc());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.ExecutorEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final ExecutorEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_ExecutorRuntime:
single_value = new ExecutorRuntime_template(other_value.constGetExecutorRuntime());
break;
case ALT_ExecutorConfigdata:
single_value = new ExecutorConfigdata_template(other_value.constGetExecutorConfigdata());
break;
case ALT_ExtcommandStart:
single_value = new TitanCharString_template(other_value.constGetExtcommandStart());
break;
case ALT_ExtcommandSuccess:
single_value = new TitanCharString_template(other_value.constGetExtcommandSuccess());
break;
case ALT_ExecutorComponent:
single_value = new ExecutorComponent_template(other_value.constGetExecutorComponent());
break;
case ALT_LogOptions:
single_value = new TitanCharString_template(other_value.constGetLogOptions());
break;
case ALT_ExecutorMisc:
single_value = new ExecutorUnqualified_template(other_value.constGetExecutorMisc());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.ExecutorEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ExecutorEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final ExecutorEvent_choice_template temp = new ExecutorEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
set_selection(other_value);
}

public ExecutorEvent_choice_template() {
}
public ExecutorEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public ExecutorEvent_choice_template(final ExecutorEvent_choice other_value) {
copy_value(other_value);
}
public ExecutorEvent_choice_template(final ExecutorEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_ExecutorRuntime:
((ExecutorRuntime_template)single_value).cleanUp();
break;
case ALT_ExecutorConfigdata:
((ExecutorConfigdata_template)single_value).cleanUp();
break;
case ALT_ExtcommandStart:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_ExtcommandSuccess:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_ExecutorComponent:
((ExecutorComponent_template)single_value).cleanUp();
break;
case ALT_LogOptions:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_ExecutorMisc:
((ExecutorUnqualified_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public ExecutorEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public ExecutorEvent_choice_template assign( final ExecutorEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public ExecutorEvent_choice_template assign( final ExecutorEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public ExecutorEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof ExecutorEvent_choice) {
return assign((ExecutorEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to ExecutorEvent_choice.");
}

@Override
public ExecutorEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof ExecutorEvent_choice_template) {
return assign((ExecutorEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to ExecutorEvent_choice_template.");
}

// originally match
public boolean match(final ExecutorEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final ExecutorEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final ExecutorEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == ExecutorEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_ExecutorRuntime:
return ((ExecutorRuntime_template)single_value).match(other_value.getExecutorRuntime(), legacy);
case ALT_ExecutorConfigdata:
return ((ExecutorConfigdata_template)single_value).match(other_value.getExecutorConfigdata(), legacy);
case ALT_ExtcommandStart:
return ((TitanCharString_template)single_value).match(other_value.getExtcommandStart(), legacy);
case ALT_ExtcommandSuccess:
return ((TitanCharString_template)single_value).match(other_value.getExtcommandSuccess(), legacy);
case ALT_ExecutorComponent:
return ((ExecutorComponent_template)single_value).match(other_value.getExecutorComponent(), legacy);
case ALT_LogOptions:
return ((TitanCharString_template)single_value).match(other_value.getLogOptions(), legacy);
case ALT_ExecutorMisc:
return ((ExecutorUnqualified_template)single_value).match(other_value.getExecutorMisc(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutorEvent_choice) {
		return match((ExecutorEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorEvent_choice.");
	}
public boolean isChosen(final ExecutorEvent_choice.union_selection_type checked_selection) {
if(checked_selection == ExecutorEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == ExecutorEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_ExecutorRuntime:
return ((ExecutorRuntime_template)single_value).isValue();
case ALT_ExecutorConfigdata:
return ((ExecutorConfigdata_template)single_value).isValue();
case ALT_ExtcommandStart:
return ((TitanCharString_template)single_value).isValue();
case ALT_ExtcommandSuccess:
return ((TitanCharString_template)single_value).isValue();
case ALT_ExecutorComponent:
return ((ExecutorComponent_template)single_value).isValue();
case ALT_LogOptions:
return ((TitanCharString_template)single_value).isValue();
case ALT_ExecutorMisc:
return ((ExecutorUnqualified_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
}

public ExecutorEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
final ExecutorEvent_choice ret_val = new ExecutorEvent_choice();
switch (single_value_union_selection) {
case ALT_ExecutorRuntime:
ret_val.getExecutorRuntime().assign(((ExecutorRuntime_template)single_value).valueOf());
break;
case ALT_ExecutorConfigdata:
ret_val.getExecutorConfigdata().assign(((ExecutorConfigdata_template)single_value).valueOf());
break;
case ALT_ExtcommandStart:
ret_val.getExtcommandStart().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_ExtcommandSuccess:
ret_val.getExtcommandSuccess().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_ExecutorComponent:
ret_val.getExecutorComponent().assign(((ExecutorComponent_template)single_value).valueOf());
break;
case ALT_LogOptions:
ret_val.getLogOptions().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_ExecutorMisc:
ret_val.getExecutorMisc().assign(((ExecutorUnqualified_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<ExecutorEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ExecutorEvent_choice_template());
}
}

public ExecutorEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public ExecutorRuntime_template getExecutorRuntime() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorRuntime) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ExecutorRuntime_template(template_sel.ANY_VALUE);
} else {
single_value = new ExecutorRuntime_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_ExecutorRuntime;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ExecutorRuntime_template)single_value;
}

public ExecutorRuntime_template constGetExecutorRuntime() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field executorRuntime in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorRuntime) {
throw new TtcnError("Accessing non-selected field executorRuntime in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorRuntime_template)single_value;
}

public ExecutorConfigdata_template getExecutorConfigdata() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorConfigdata) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ExecutorConfigdata_template(template_sel.ANY_VALUE);
} else {
single_value = new ExecutorConfigdata_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_ExecutorConfigdata;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ExecutorConfigdata_template)single_value;
}

public ExecutorConfigdata_template constGetExecutorConfigdata() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field executorConfigdata in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorConfigdata) {
throw new TtcnError("Accessing non-selected field executorConfigdata in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorConfigdata_template)single_value;
}

public TitanCharString_template getExtcommandStart() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExtcommandStart) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_ExtcommandStart;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetExtcommandStart() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field extcommandStart in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExtcommandStart) {
throw new TtcnError("Accessing non-selected field extcommandStart in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template getExtcommandSuccess() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExtcommandSuccess) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_ExtcommandSuccess;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetExtcommandSuccess() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field extcommandSuccess in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExtcommandSuccess) {
throw new TtcnError("Accessing non-selected field extcommandSuccess in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (TitanCharString_template)single_value;
}

public ExecutorComponent_template getExecutorComponent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorComponent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ExecutorComponent_template(template_sel.ANY_VALUE);
} else {
single_value = new ExecutorComponent_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_ExecutorComponent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ExecutorComponent_template)single_value;
}

public ExecutorComponent_template constGetExecutorComponent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field executorComponent in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorComponent) {
throw new TtcnError("Accessing non-selected field executorComponent in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorComponent_template)single_value;
}

public TitanCharString_template getLogOptions() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_LogOptions) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_LogOptions;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetLogOptions() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field logOptions in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_LogOptions) {
throw new TtcnError("Accessing non-selected field logOptions in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (TitanCharString_template)single_value;
}

public ExecutorUnqualified_template getExecutorMisc() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorMisc) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ExecutorUnqualified_template(template_sel.ANY_VALUE);
} else {
single_value = new ExecutorUnqualified_template();
}
single_value_union_selection = ExecutorEvent_choice.union_selection_type.ALT_ExecutorMisc;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ExecutorUnqualified_template)single_value;
}

public ExecutorUnqualified_template constGetExecutorMisc() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field executorMisc in a non-specific template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
if (single_value_union_selection != ExecutorEvent_choice.union_selection_type.ALT_ExecutorMisc) {
throw new TtcnError("Accessing non-selected field executorMisc in a template of union type @TitanLoggerApi.ExecutorEvent.choice.");
}
return (ExecutorUnqualified_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ExecutorEvent_choice) {
log_match((ExecutorEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.choice.");
}

public void log_match(final ExecutorEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_ExecutorRuntime:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".executorRuntime");
single_value.log_match(match_value.getExecutorRuntime(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ executorRuntime := ");
single_value.log_match(match_value.getExecutorRuntime(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExecutorConfigdata:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".executorConfigdata");
single_value.log_match(match_value.getExecutorConfigdata(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ executorConfigdata := ");
single_value.log_match(match_value.getExecutorConfigdata(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExtcommandStart:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".extcommandStart");
single_value.log_match(match_value.getExtcommandStart(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ extcommandStart := ");
single_value.log_match(match_value.getExtcommandStart(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExtcommandSuccess:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".extcommandSuccess");
single_value.log_match(match_value.getExtcommandSuccess(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ extcommandSuccess := ");
single_value.log_match(match_value.getExtcommandSuccess(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExecutorComponent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".executorComponent");
single_value.log_match(match_value.getExecutorComponent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ executorComponent := ");
single_value.log_match(match_value.getExecutorComponent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_LogOptions:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".logOptions");
single_value.log_match(match_value.getLogOptions(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ logOptions := ");
single_value.log_match(match_value.getLogOptions(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExecutorMisc:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".executorMisc");
single_value.log_match(match_value.getExecutorMisc(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ executorMisc := ");
single_value.log_match(match_value.getExecutorMisc(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.ExecutorEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new ExecutorRuntime_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new ExecutorConfigdata_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 3:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 4:
single_value = new ExecutorComponent_template();
single_value.decode_text(text_buf);
break;
case 5:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 6:
single_value = new ExecutorUnqualified_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ExecutorEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final ExecutorEvent_choice_template temp2 = new ExecutorEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.ExecutorEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void ExecutorEvent_choice_encoder(final ExecutorEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_decoder( final TitanOctetString input_stream, final ExecutorEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class TimerAnyTimeoutType extends Base_Type {
private boolean bound_flag;

public TimerAnyTimeoutType() {
bound_flag = false;
}

public TimerAnyTimeoutType( final TitanNull_Type otherValue ) {
bound_flag = true;
}

public TimerAnyTimeoutType( final TimerAnyTimeoutType otherValue ) {
if ( !otherValue.isBound() ) {
		throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
bound_flag = true;
}

//originally operator=
public TimerAnyTimeoutType assign( final TitanNull_Type otherValue ) {
bound_flag = true;
return this;
}

//originally operator=
public TimerAnyTimeoutType assign( final TimerAnyTimeoutType otherValue ) {
if ( !otherValue.isBound() ) {
		throw new TtcnError("Assignment of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
bound_flag = true;
return this;
}

@Override
public TimerAnyTimeoutType assign( final Base_Type otherValue ) {
if (otherValue instanceof TimerAnyTimeoutType) {
return assign((TimerAnyTimeoutType)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to TimerAnyTimeoutType.");
}

//originally clean_up
public void cleanUp() {
bound_flag = false;
}

//originally is_bound
public boolean isBound() {
return bound_flag;
}

//originally is_present
public boolean isPresent() {
return isBound();
}

//originally is_value
public boolean isValue() {
return bound_flag;
}

public void mustBound( final String aErrorMessage ) {
if ( !bound_flag ) {
throw new TtcnError( aErrorMessage );
}
}

//originally operator==
public boolean operatorEquals( final TitanNull_Type otherValue ) {
if (!isBound()) {
throw new TtcnError("Comparison of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
return true;
}

//originally operator==
public boolean operatorEquals( final TimerAnyTimeoutType otherValue ) {
if (!isBound()) {
throw new TtcnError("Comparison of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
if (!otherValue.isBound()) {
throw new TtcnError("Comparison of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
return true;
}

@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof TimerAnyTimeoutType) {
return operatorEquals((TimerAnyTimeoutType)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerAnyTimeoutType.");
}

//originally operator!=
public boolean operatorNotEquals( final TitanNull_Type otherValue ) {
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals( final TimerAnyTimeoutType otherValue ) {
return !operatorEquals(otherValue);
}

public boolean operatorNotEquals( final Base_Type otherValue ) {
return !operatorEquals(otherValue);
}

public void log() {
if (bound_flag) {
TTCN_Logger.log_event_str("{ }");
return;
}
TTCN_Logger.log_event_unbound();
}

@Override
public void encode_text(final Text_Buf text_buf) {
mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}

@Override
public void decode_text(final Text_Buf text_buf) {
bound_flag = true;
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}

public static class TimerAnyTimeoutType_template extends Base_Template {
//originally value_list/list_value
List<TimerAnyTimeoutType_template> list_value;
public TimerAnyTimeoutType_template() {
}

public TimerAnyTimeoutType_template(final template_sel other_value) {
super( other_value );
checkSingleSelection( other_value );
}

public TimerAnyTimeoutType_template(final TitanNull_Type other_value) {
super(template_sel.SPECIFIC_VALUE);
}

public TimerAnyTimeoutType_template(final TimerAnyTimeoutType other_value) {
super(template_sel.SPECIFIC_VALUE);
if (!other_value.isBound()) {
throw new TtcnError("Creating a template from an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
}

public TimerAnyTimeoutType_template(final TimerAnyTimeoutType_template other_value) {
copyTemplate( other_value );
}

public TimerAnyTimeoutType_template(final Optional<TimerAnyTimeoutType> other_value) {
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(template_sel.SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(template_sel.OMIT_VALUE);
break;
default:
throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerAnyTimeoutType from an unbound optional field.");
}
}

//originally operator=
public TimerAnyTimeoutType_template assign(final template_sel other_value) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public TimerAnyTimeoutType_template assign(final TitanNull_Type other_value) {
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public TimerAnyTimeoutType_template assign(final TimerAnyTimeoutType other_value) {
if (!other_value.isBound()) {
throw new TtcnError("Assignment of an unbound value of type @TitanLoggerApi.TimerAnyTimeoutType to a template.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public TimerAnyTimeoutType_template assign(final TimerAnyTimeoutType_template other_value) {
if (other_value != this) {
cleanUp();
copyTemplate(other_value);
}
return this;
}

@Override
public TimerAnyTimeoutType_template assign(final Base_Type other_value) {
if (other_value instanceof TimerAnyTimeoutType) {
return assign((TimerAnyTimeoutType) other_value);
}
			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerAnyTimeoutType' can not be cast to {1}", other_value));
}

@Override
public TimerAnyTimeoutType_template assign(final Base_Template other_value) {
if (other_value instanceof TimerAnyTimeoutType_template) {
return assign((TimerAnyTimeoutType_template) other_value);
}
			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerAnyTimeoutType' can not be cast to {1}_template", other_value));
}

public TimerAnyTimeoutType_template assign(final Optional<TimerAnyTimeoutType> other_value) {
cleanUp();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(template_sel.SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(template_sel.OMIT_VALUE);
break;
default:
throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerAnyTimeoutType .");
}
return this;
}

public void copyTemplate(final TimerAnyTimeoutType_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
			list_value = new ArrayList<TimerAnyTimeoutType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TimerAnyTimeoutType_template temp = new TimerAnyTimeoutType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
break;
default:
throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
set_selection(other_value);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
return isPresent_(legacy);
}

private boolean isPresent_(final boolean legacy) {
if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit_(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
return match_omit_(legacy);
}

private boolean match_omit_(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
if (list_value.get(l_idx).match_omit_(legacy)) {
return templateSelection==template_sel.VALUE_LIST;
}
}
return templateSelection==template_sel.COMPLEMENTED_LIST;
} // else fall through
default:
return false;
}
}

public TimerAnyTimeoutType valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
final TimerAnyTimeoutType ret_val = new TimerAnyTimeoutType(TitanNull_Type.NULL_VALUE);
return ret_val;
}

		public TimerAnyTimeoutType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerAnyTimeoutType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerAnyTimeoutType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerAnyTimeoutType_template());
			}
		}

public boolean match(final TimerAnyTimeoutType other_value) {
return match(other_value, false);
}

public boolean match(final TimerAnyTimeoutType other_value, final boolean legacy) {
if (!other_value.isBound()) {
return false;
}
return match(TitanNull_Type.NULL_VALUE, legacy);
}

private boolean match(final TitanNull_Type other_value, final boolean legacy) {
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (int list_count = 0; list_count < list_value.size(); list_count++) {
if (list_value.get(list_count).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
}

@Override
public boolean match(final Base_Type other_value, final boolean legacy) {
if (other_value instanceof TimerAnyTimeoutType) {
return match((TimerAnyTimeoutType)other_value, legacy);
}
throw new TtcnError("Internal Error: The left operand of assignment is not of type @TitanLoggerApi.TimerAnyTimeoutType.");
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < list_value.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
list_value.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

public void log_match(final TimerAnyTimeoutType match_value) {
log_match(match_value, false);
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof TimerAnyTimeoutType) {
log_match((TimerAnyTimeoutType)match_value, legacy);
return;
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerAnyTimeoutType.");
}

public void log_match(final TimerAnyTimeoutType match_value, final boolean legacy) {
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if ( match(match_value, legacy) ) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(list_value.size());
for (int i = 0; i < list_value.size(); i++) {
list_value.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
list_value = new ArrayList<TimerAnyTimeoutType_template>(size);
for(int i = 0; i < size; i++) {
final TimerAnyTimeoutType_template temp = new TimerAnyTimeoutType_template();
temp.decode_text(text_buf);
list_value.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerAnyTimeoutType.");
}
}

}

public static void TimerAnyTimeoutType_encoder(final TimerAnyTimeoutType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerAnyTimeoutType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerAnyTimeoutType_decoder( final TitanOctetString input_stream, final TimerAnyTimeoutType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerAnyTimeoutType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_nonePercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_nonePercent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_nonePercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_nonePercent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorRuntime_testcase__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorRuntime_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorRuntime_testcase__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorRuntime_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingFailureType_port__type_encoder(final PortType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_port__type_decoder( final TitanOctetString input_stream, final PortType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Parallel_alive___encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_alive___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_alive___decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_alive___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanSingleLogEvent_event_encoder(final TitanLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanSingleLogEvent_event_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanSingleLogEvent_event_decoder( final TitanOctetString input_stream, final TitanLogEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanSingleLogEvent_event_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingProblemType_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingProblemType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingProblemType_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingProblemType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class SetVerdictType extends Base_Type {
		private final Verdict newVerdict; //Referenced_Type
		private final Verdict oldVerdict; //Referenced_Type
		private final Verdict localVerdict; //Referenced_Type
		private final Optional<TitanCharString> oldReason; //CharString_Type
		private final Optional<TitanCharString> newReason; //CharString_Type

		public SetVerdictType() {
			newVerdict = new Verdict();
			oldVerdict = new Verdict();
			localVerdict = new Verdict();
			oldReason = new Optional<TitanCharString>(TitanCharString.class);
			newReason = new Optional<TitanCharString>(TitanCharString.class);
		}

		public SetVerdictType( final Verdict aNewVerdict, final Verdict aOldVerdict, final Verdict aLocalVerdict, final Optional<TitanCharString> aOldReason, final Optional<TitanCharString> aNewReason ) {
			newVerdict = new Verdict( aNewVerdict );
			oldVerdict = new Verdict( aOldVerdict );
			localVerdict = new Verdict( aLocalVerdict );
			oldReason = new Optional<TitanCharString>(TitanCharString.class);
			this.oldReason.assign( aOldReason );
			newReason = new Optional<TitanCharString>(TitanCharString.class);
			this.newReason.assign( aNewReason );
		}

		public SetVerdictType( final SetVerdictType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.SetVerdictType.");
			}
			newVerdict = new Verdict();
			oldVerdict = new Verdict();
			localVerdict = new Verdict();
			oldReason = new Optional<TitanCharString>(TitanCharString.class);
			newReason = new Optional<TitanCharString>(TitanCharString.class);
			assign( aOtherValue );
		}
		public SetVerdictType assign(final SetVerdictType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.SetVerdictType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getNewVerdict().isBound() ) {
					this.newVerdict.assign( aOtherValue.getNewVerdict() );
				} else {
					this.newVerdict.cleanUp();
				}
				if ( aOtherValue.getOldVerdict().isBound() ) {
					this.oldVerdict.assign( aOtherValue.getOldVerdict() );
				} else {
					this.oldVerdict.cleanUp();
				}
				if ( aOtherValue.getLocalVerdict().isBound() ) {
					this.localVerdict.assign( aOtherValue.getLocalVerdict() );
				} else {
					this.localVerdict.cleanUp();
				}
				if ( aOtherValue.getOldReason().isBound() ) {
					this.oldReason.assign( aOtherValue.getOldReason() );
				} else {
					this.oldReason.cleanUp();
				}
				if ( aOtherValue.getNewReason().isBound() ) {
					this.newReason.assign( aOtherValue.getNewReason() );
				} else {
					this.newReason.cleanUp();
				}
			}

			return this;
		}

		@Override
		public SetVerdictType assign(final Base_Type otherValue) {
			if (otherValue instanceof SetVerdictType ) {
				return assign((SetVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.SetVerdictType", otherValue));
		}

		public void cleanUp() {
			newVerdict.cleanUp();
			oldVerdict.cleanUp();
			localVerdict.cleanUp();
			oldReason.cleanUp();
			newReason.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( newVerdict.isBound() ) { return true; }
			if ( oldVerdict.isBound() ) { return true; }
			if ( localVerdict.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(oldReason.get_selection()) || oldReason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(newReason.get_selection()) || newReason.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !newVerdict.isValue() ) { return false; }
			if ( !oldVerdict.isValue() ) { return false; }
			if ( !localVerdict.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(oldReason.get_selection()) && !oldReason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(newReason.get_selection()) && !newReason.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final SetVerdictType aOtherValue ) {
			if ( !this.newVerdict.operatorEquals( aOtherValue.newVerdict ) ) { return false; }
			if ( !this.oldVerdict.operatorEquals( aOtherValue.oldVerdict ) ) { return false; }
			if ( !this.localVerdict.operatorEquals( aOtherValue.localVerdict ) ) { return false; }
			if ( !this.oldReason.operatorEquals( aOtherValue.oldReason ) ) { return false; }
			if ( !this.newReason.operatorEquals( aOtherValue.newReason ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof SetVerdictType ) {
				return operatorEquals((SetVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.SetVerdictType", otherValue));
		}

		public Verdict getNewVerdict() {
			return newVerdict;
		}

		public Verdict constGetNewVerdict() {
			return newVerdict;
		}

		public Verdict getOldVerdict() {
			return oldVerdict;
		}

		public Verdict constGetOldVerdict() {
			return oldVerdict;
		}

		public Verdict getLocalVerdict() {
			return localVerdict;
		}

		public Verdict constGetLocalVerdict() {
			return localVerdict;
		}

		public Optional<TitanCharString> getOldReason() {
			return oldReason;
		}

		public Optional<TitanCharString> constGetOldReason() {
			return oldReason;
		}

		public Optional<TitanCharString> getNewReason() {
			return newReason;
		}

		public Optional<TitanCharString> constGetNewReason() {
			return newReason;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			if (oldReason.isPresent()) {
				sizeof++;
			}
			if (newReason.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" newVerdict := ");
			newVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" oldVerdict := ");
			oldVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" localVerdict := ");
			localVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" oldReason := ");
			oldReason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" newReason := ");
			newReason.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (newVerdict.isBound()) {
				newVerdict.set_implicit_omit();
			}
			if (oldVerdict.isBound()) {
				oldVerdict.set_implicit_omit();
			}
			if (localVerdict.isBound()) {
				localVerdict.set_implicit_omit();
			}
			if (oldReason.isBound()) {
				oldReason.set_implicit_omit();
			} else {
				oldReason.assign(template_sel.OMIT_VALUE);
			}
			if (newReason.isBound()) {
				newReason.set_implicit_omit();
			} else {
				newReason.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			newVerdict.encode_text(text_buf);
			oldVerdict.encode_text(text_buf);
			localVerdict.encode_text(text_buf);
			oldReason.encode_text(text_buf);
			newReason.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			newVerdict.decode_text(text_buf);
			oldVerdict.decode_text(text_buf);
			localVerdict.decode_text(text_buf);
			oldReason.decode_text(text_buf);
			newReason.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class SetVerdictType_template extends Base_Template {

	private Verdict_template newVerdict; //Referenced_Type
	private Verdict_template oldVerdict; //Referenced_Type
	private Verdict_template localVerdict; //Referenced_Type
	private TitanCharString_template oldReason; //CharString_Type
	private TitanCharString_template newReason; //CharString_Type
	//originally value_list/list_value
	List<SetVerdictType_template> list_value;

	public Verdict_template getNewVerdict() {
		setSpecific();
		return newVerdict;
	}

	public Verdict_template constGetNewVerdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field newVerdict of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
		}
		return newVerdict;
	}

	public Verdict_template getOldVerdict() {
		setSpecific();
		return oldVerdict;
	}

	public Verdict_template constGetOldVerdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field oldVerdict of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
		}
		return oldVerdict;
	}

	public Verdict_template getLocalVerdict() {
		setSpecific();
		return localVerdict;
	}

	public Verdict_template constGetLocalVerdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field localVerdict of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
		}
		return localVerdict;
	}

	public TitanCharString_template getOldReason() {
		setSpecific();
		return oldReason;
	}

	public TitanCharString_template constGetOldReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field oldReason of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
		}
		return oldReason;
	}

	public TitanCharString_template getNewReason() {
		setSpecific();
		return newReason;
	}

	public TitanCharString_template constGetNewReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field newReason of a non-specific template of type @TitanLoggerApi.SetVerdictType.");
		}
		return newReason;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			newVerdict = new Verdict_template();
			oldVerdict = new Verdict_template();
			localVerdict = new Verdict_template();
			oldReason = new TitanCharString_template();
			newReason = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				newVerdict.assign(template_sel.ANY_VALUE);
				oldVerdict.assign(template_sel.ANY_VALUE);
				localVerdict.assign(template_sel.ANY_VALUE);
				oldReason.assign(template_sel.ANY_OR_OMIT);
				newReason.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public SetVerdictType_template() {
	}

	public SetVerdictType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public SetVerdictType_template( final SetVerdictType otherValue ) {
		copyValue(otherValue);
	}

	public SetVerdictType_template( final SetVerdictType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public SetVerdictType_template( final Optional<SetVerdictType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.SetVerdictType from an unbound optional field.");
		}
	}

	//originally operator=
	public SetVerdictType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public SetVerdictType_template assign( final SetVerdictType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public SetVerdictType_template assign( final SetVerdictType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public SetVerdictType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof SetVerdictType) {
				return assign((SetVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SetVerdictType' can not be cast to {1}", otherValue));
		}

		@Override
		public SetVerdictType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof SetVerdictType_template) {
				return assign((SetVerdictType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `SetVerdictType' can not be cast to {1}_template", otherValue));
		}

	public SetVerdictType_template assign( final Optional<SetVerdictType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.SetVerdictType.");
		}
		return this;
	}

	private void copyValue(final SetVerdictType other_value) {
		if (other_value.getNewVerdict().isBound()) {
			getNewVerdict().assign(other_value.getNewVerdict());
		} else {
			getNewVerdict().cleanUp();
		}
		if (other_value.getOldVerdict().isBound()) {
			getOldVerdict().assign(other_value.getOldVerdict());
		} else {
			getOldVerdict().cleanUp();
		}
		if (other_value.getLocalVerdict().isBound()) {
			getLocalVerdict().assign(other_value.getLocalVerdict());
		} else {
			getLocalVerdict().cleanUp();
		}
		if (other_value.getOldReason().isBound()) {
			if (other_value.getOldReason().isPresent()) {
				getOldReason().assign(other_value.getOldReason().get());
			} else {
				getOldReason().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getOldReason().cleanUp();
		}
		if (other_value.getNewReason().isBound()) {
			if (other_value.getNewReason().isPresent()) {
				getNewReason().assign(other_value.getNewReason().get());
			} else {
				getNewReason().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getNewReason().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final SetVerdictType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNewVerdict().get_selection()) {
				getNewVerdict().cleanUp();
			} else {
				getNewVerdict().assign(other_value.getNewVerdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOldVerdict().get_selection()) {
				getOldVerdict().cleanUp();
			} else {
				getOldVerdict().assign(other_value.getOldVerdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getLocalVerdict().get_selection()) {
				getLocalVerdict().cleanUp();
			} else {
				getLocalVerdict().assign(other_value.getLocalVerdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOldReason().get_selection()) {
				getOldReason().cleanUp();
			} else {
				getOldReason().assign(other_value.getOldReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNewReason().get_selection()) {
				getNewReason().cleanUp();
			} else {
				getNewReason().assign(other_value.getNewReason());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<SetVerdictType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final SetVerdictType_template temp = new SetVerdictType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.SetVerdictType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public SetVerdictType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.SetVerdictType.");
			}
			final SetVerdictType ret_val = new SetVerdictType();
			 if (newVerdict.isBound()) {
				ret_val.newVerdict.assign(newVerdict.valueOf());
			}
			 if (oldVerdict.isBound()) {
				ret_val.oldVerdict.assign(oldVerdict.valueOf());
			}
			 if (localVerdict.isBound()) {
				ret_val.localVerdict.assign(localVerdict.valueOf());
			}
			if (oldReason.isOmit()) {
				ret_val.oldReason.assign(template_sel.OMIT_VALUE);
			} else if (oldReason.isBound()) {
				ret_val.oldReason.assign(oldReason.valueOf());
			}
			if (newReason.isOmit()) {
				ret_val.newReason.assign(template_sel.OMIT_VALUE);
			} else if (newReason.isBound()) {
				ret_val.newReason.assign(newReason.valueOf());
			}
			return ret_val;
		}

		public SetVerdictType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.SetVerdictType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.SetVerdictType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.SetVerdictType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<SetVerdictType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new SetVerdictType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (newVerdict.isBound()) {
				return true;
			}
			if (oldVerdict.isBound()) {
				return true;
			}
			if (localVerdict.isBound()) {
				return true;
			}
			if (oldReason.isOmit() || oldReason.isBound()) {
				return true;
			}
			if (newReason.isOmit() || newReason.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!newVerdict.isValue()) {
				return false;
			}
			if (!oldVerdict.isValue()) {
				return false;
			}
			if (!localVerdict.isValue()) {
				return false;
			}
			if (!oldReason.isOmit() && !oldReason.isValue()) {
				return false;
			}
			if (!newReason.isOmit() && !newReason.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final SetVerdictType other_value) {
			return match(other_value, false);
		}

		public boolean match(final SetVerdictType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getNewVerdict().isBound()) {
					return false;
				}
				if(!newVerdict.match(other_value.getNewVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getOldVerdict().isBound()) {
					return false;
				}
				if(!oldVerdict.match(other_value.getOldVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getLocalVerdict().isBound()) {
					return false;
				}
				if(!localVerdict.match(other_value.getLocalVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getOldReason().isBound()) {
					return false;
				}
				if((other_value.getOldReason().isPresent() ? !oldReason.match(other_value.getOldReason().get(), legacy) : !oldReason.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getNewReason().isBound()) {
					return false;
				}
				if((other_value.getNewReason().isPresent() ? !newReason.match(other_value.getNewReason().get(), legacy) : !newReason.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof SetVerdictType) {
		return match((SetVerdictType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type SetVerdictType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				if (oldReason.isPresent()) {
					sizeof++;
				}
				if (newReason.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.SetVerdictType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" newVerdict := ");
				newVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" oldVerdict := ");
				oldVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" localVerdict := ");
				localVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" oldReason := ");
				oldReason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" newReason := ");
				newReason.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final SetVerdictType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof SetVerdictType) {
				log_match((SetVerdictType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.SetVerdictType.");
		}

		public void log_match(final SetVerdictType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !newVerdict.match(match_value.constGetNewVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".newVerdict");
							newVerdict.log_match(match_value.constGetNewVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !oldVerdict.match(match_value.constGetOldVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".oldVerdict");
							oldVerdict.log_match(match_value.constGetOldVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !localVerdict.match(match_value.constGetLocalVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".localVerdict");
							localVerdict.log_match(match_value.constGetLocalVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetOldReason().isPresent()) {
							if( !oldReason.match(match_value.constGetOldReason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".oldReason");
								oldReason.log_match(match_value.constGetOldReason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!oldReason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".oldReason := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								oldReason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetNewReason().isPresent()) {
							if( !newReason.match(match_value.constGetNewReason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".newReason");
								newReason.log_match(match_value.constGetNewReason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!newReason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".newReason := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								newReason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ newVerdict := ");
				newVerdict.log_match(match_value.constGetNewVerdict(), legacy);
				TTCN_Logger.log_event_str("{ oldVerdict := ");
				oldVerdict.log_match(match_value.constGetOldVerdict(), legacy);
				TTCN_Logger.log_event_str("{ localVerdict := ");
				localVerdict.log_match(match_value.constGetLocalVerdict(), legacy);
				TTCN_Logger.log_event_str("{ oldReason := ");
				oldReason.log_match(match_value.constGetOldReason(), legacy);
				TTCN_Logger.log_event_str("{ newReason := ");
				newReason.log_match(match_value.constGetNewReason(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				newVerdict.encode_text(text_buf);
				oldVerdict.encode_text(text_buf);
				localVerdict.encode_text(text_buf);
				oldReason.encode_text(text_buf);
				newReason.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.SetVerdictType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				newVerdict = new Verdict_template();
				newVerdict.decode_text(text_buf);
				oldVerdict = new Verdict_template();
				oldVerdict.decode_text(text_buf);
				localVerdict = new Verdict_template();
				localVerdict.decode_text(text_buf);
				oldReason = new TitanCharString_template();
				oldReason.decode_text(text_buf);
				newReason = new TitanCharString_template();
				newReason.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<SetVerdictType_template>(size);
				for(int i = 0; i < size; i++) {
					final SetVerdictType_template temp = new SetVerdictType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.SetVerdictType.");
			}
		}
}
public static void SetVerdictType_encoder(final SetVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(SetVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger SetVerdictType_decoder( final TitanOctetString input_stream, final SetVerdictType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.SetVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(SetVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_alive__pid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_alive__pid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_alive__pid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_alive__pid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__recv_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_unhandledEvent_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_unhandledEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_unhandledEvent_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_unhandledEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorUnqualified_addr_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorUnqualified_addr_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorUnqualified_addr_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorUnqualified_addr_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Parallel_reason extends Base_Type {
public enum enum_type {
creating__new__ptc (0),
function__stopped (1),
terminating__test__component__exec (2),
stopping__ptc (3),
stop__no__effect (4),
stopping__all__ptcs (5),
stop__all__no__effect (6),
killing__ptc (7),
kill__no__effect (8),
killing__all__ptcs (9),
kill__all__no__effect (10),
connecting__ports (11),
disconnecting__ports (12),
mapping__ports (13),
unmapping__ports (14),
kill__request__from__mc (15),
killing__component (16),
process__already__terminated (17),
compref__not__exist (18),
UNKNOWN_VALUE(19),
UNBOUND_VALUE(20);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return creating__new__ptc;
case 1:  return function__stopped;
case 2:  return terminating__test__component__exec;
case 3:  return stopping__ptc;
case 4:  return stop__no__effect;
case 5:  return stopping__all__ptcs;
case 6:  return stop__all__no__effect;
case 7:  return killing__ptc;
case 8:  return kill__no__effect;
case 9:  return killing__all__ptcs;
case 10:  return kill__all__no__effect;
case 11:  return connecting__ports;
case 12:  return disconnecting__ports;
case 13:  return mapping__ports;
case 14:  return unmapping__ports;
case 15:  return kill__request__from__mc;
case 16:  return killing__component;
case 17:  return process__already__terminated;
case 18:  return compref__not__exist;
case 19:  return UNKNOWN_VALUE;
case 20:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Parallel_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Parallel_reason(final Parallel_reason otherValue) {
enum_value = otherValue.enum_value;
}

public Parallel_reason(final Parallel_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public Parallel_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Parallel_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Parallel_reason assign(final Parallel_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Parallel_reason assign(final Base_Type otherValue){
if( otherValue instanceof Parallel_reason ) {
return assign((Parallel_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public Parallel_reason assign(final Parallel_reason.enum_type otherValue){
return assign( new Parallel_reason(otherValue) );
}

//originally operator=
public Parallel_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Parallel_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Parallel_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Parallel_reason) {
return operatorEquals( (Parallel_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Parallel.reason.");
}
}

//originally operator==
public boolean operatorEquals(final Parallel_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Parallel_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Parallel_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Parallel_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Parallel_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Parallel_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Parallel_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Parallel_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Parallel_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Parallel_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Parallel_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Parallel_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Parallel_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Parallel_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("creating__new__ptc".equals(strPar) || "creating_new_ptc".equals(strPar)) {
return enum_type.creating__new__ptc;
}
if ("function__stopped".equals(strPar) || "function_stopped".equals(strPar)) {
return enum_type.function__stopped;
}
if ("terminating__test__component__exec".equals(strPar) || "terminating_test_component_exec".equals(strPar)) {
return enum_type.terminating__test__component__exec;
}
if ("stopping__ptc".equals(strPar) || "stopping_ptc".equals(strPar)) {
return enum_type.stopping__ptc;
}
if ("stop__no__effect".equals(strPar) || "stop_no_effect".equals(strPar)) {
return enum_type.stop__no__effect;
}
if ("stopping__all__ptcs".equals(strPar) || "stopping_all_ptcs".equals(strPar)) {
return enum_type.stopping__all__ptcs;
}
if ("stop__all__no__effect".equals(strPar) || "stop_all_no_effect".equals(strPar)) {
return enum_type.stop__all__no__effect;
}
if ("killing__ptc".equals(strPar) || "killing_ptc".equals(strPar)) {
return enum_type.killing__ptc;
}
if ("kill__no__effect".equals(strPar) || "kill_no_effect".equals(strPar)) {
return enum_type.kill__no__effect;
}
if ("killing__all__ptcs".equals(strPar) || "killing_all_ptcs".equals(strPar)) {
return enum_type.killing__all__ptcs;
}
if ("kill__all__no__effect".equals(strPar) || "kill_all_no_effect".equals(strPar)) {
return enum_type.kill__all__no__effect;
}
if ("connecting__ports".equals(strPar) || "connecting_ports".equals(strPar)) {
return enum_type.connecting__ports;
}
if ("disconnecting__ports".equals(strPar) || "disconnecting_ports".equals(strPar)) {
return enum_type.disconnecting__ports;
}
if ("mapping__ports".equals(strPar) || "mapping_ports".equals(strPar)) {
return enum_type.mapping__ports;
}
if ("unmapping__ports".equals(strPar) || "unmapping_ports".equals(strPar)) {
return enum_type.unmapping__ports;
}
if ("kill__request__from__mc".equals(strPar) || "kill_request_from_mc".equals(strPar)) {
return enum_type.kill__request__from__mc;
}
if ("killing__component".equals(strPar) || "killing_component".equals(strPar)) {
return enum_type.killing__component;
}
if ("process__already__terminated".equals(strPar) || "process_already_terminated".equals(strPar)) {
return enum_type.process__already__terminated;
}
if ("compref__not__exist".equals(strPar) || "compref_not_exist".equals(strPar)) {
return enum_type.compref__not__exist;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Parallel.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Parallel.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Parallel_reason_template extends Base_Template {
// single_value
private Parallel_reason.enum_type single_value;
// value_list part
private ArrayList<Parallel_reason_template> value_list;

private void copy_template(final Parallel_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Parallel_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Parallel_reason_template temp = new Parallel_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Parallel_reason.");
}
}

public Parallel_reason_template() {
}

public Parallel_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Parallel_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Parallel_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Parallel_reason with unknown numeric value "+ otherValue +".");
}
single_value = Parallel_reason.enum_type.getValue(otherValue);
}

public Parallel_reason_template(final Parallel_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Parallel_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Parallel_reason. ");
}
single_value = otherValue.enum_value;
}

public Parallel_reason_template(final Parallel_reason_template otherValue) {
copy_template(otherValue);
}

public Parallel_reason_template(final Parallel_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Parallel_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Parallel_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Parallel_reason_template assign(final int otherValue) {
if (!Parallel_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Parallel_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Parallel_reason_template assign(final Parallel_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Parallel_reason_template assign(final Parallel_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Parallel_reason_template assign(final Parallel_reason otherValue){
if (otherValue.enum_value == Parallel_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Parallel_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Parallel_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof Parallel_reason ) {
return assign((Parallel_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason' can not be cast to {1}", otherValue));
}

@Override
public Parallel_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof Parallel_reason_template ) {
return assign((Parallel_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Parallel_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Parallel_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Parallel_reason.");
}
}

// originally match
public boolean match(final Parallel_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Parallel_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Parallel_reason ) {
return match((Parallel_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel_reason' can not be cast to {1}", otherValue));
}

public Parallel_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Parallel_reason.");
}
return new Parallel_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Parallel_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Parallel_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Parallel_reason_template());
}
}

public Parallel_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Parallel_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Parallel_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Parallel_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Parallel_reason.enum2str(single_value), Parallel_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Parallel_reason) {
log_match((Parallel_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Parallel.reason.");
}
public void log_match(final Parallel_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Parallel.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Parallel_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Parallel.reason.", temp));
}
single_value = Parallel_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Parallel_reason_template>(size);
for(int i = 0; i < size; i++) {
final Parallel_reason_template temp = new Parallel_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Parallel.reason.");
}
}
}
public static void Parallel_reason_encoder(final Parallel_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_reason_decoder( final TitanOctetString input_stream, final Parallel_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_userLog_encoder(final Strings input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_userLog_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_userLog_decoder( final TitanOctetString input_stream, final Strings output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_userLog_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutionSummaryType_numberOfTestcases_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutionSummaryType_numberOfTestcases_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutionSummaryType_numberOfTestcases_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutionSummaryType_numberOfTestcases_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_procPortSend_encoder(final Proc__port__out input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_procPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_procPortSend_decoder( final TitanOctetString input_stream, final Proc__port__out output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_out' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_procPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Misc_new__size_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_new__size_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_new__size_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_new__size_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_pass___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_pass___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_pass___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_pass___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_msgPortRecv_encoder(final Msg__port__recv input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_msgPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_msgPortRecv_decoder( final TitanOctetString input_stream, final Msg__port__recv output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_msgPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class PortType extends Base_Type {
public enum enum_type {
message__ (0),
procedure__ (1),
UNKNOWN_VALUE(2),
UNBOUND_VALUE(3);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return message__;
case 1:  return procedure__;
case 2:  return UNKNOWN_VALUE;
case 3:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public PortType() {
enum_value = enum_type.UNBOUND_VALUE;
}

public PortType(final PortType otherValue) {
enum_value = otherValue.enum_value;
}

public PortType(final PortType.enum_type otherValue ) {
enum_value = otherValue;
}

public PortType(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `PortType' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public PortType assign(final PortType otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public PortType assign(final Base_Type otherValue){
if( otherValue instanceof PortType ) {
return assign((PortType) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `PortType' can not be cast to {1}", otherValue));
}

//originally operator=
public PortType assign(final PortType.enum_type otherValue){
return assign( new PortType(otherValue) );
}

//originally operator=
public PortType assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `PortType'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final PortType otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof PortType) {
return operatorEquals( (PortType) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortType.");
}
}

//originally operator==
public boolean operatorEquals(final PortType.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final PortType otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final PortType.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final PortType.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final PortType otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final PortType.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final PortType otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final PortType.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final PortType otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final PortType.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final PortType otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type PortType. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type PortType. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final PortType.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final PortType enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("message__".equals(strPar) || "message_".equals(strPar)) {
return enum_type.message__;
}
if ("procedure__".equals(strPar) || "procedure_".equals(strPar)) {
return enum_type.procedure__;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.PortType.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.PortType.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class PortType_template extends Base_Template {
// single_value
private PortType.enum_type single_value;
// value_list part
private ArrayList<PortType_template> value_list;

private void copy_template(final PortType_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<PortType_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final PortType_template temp = new PortType_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type PortType.");
}
}

public PortType_template() {
}

public PortType_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public PortType_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!PortType.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type PortType with unknown numeric value "+ otherValue +".");
}
single_value = PortType.enum_type.getValue(otherValue);
}

public PortType_template(final PortType otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == PortType.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type PortType. ");
}
single_value = otherValue.enum_value;
}

public PortType_template(final PortType_template otherValue) {
copy_template(otherValue);
}

public PortType_template(final PortType.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != PortType.enum_type.UNBOUND_VALUE;
}

//originally operator=
public PortType_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public PortType_template assign(final int otherValue) {
if (!PortType.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type PortType.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public PortType_template assign(final PortType.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public PortType_template assign(final PortType_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public PortType_template assign(final PortType otherValue){
if (otherValue.enum_value == PortType.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type PortType to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public PortType_template assign(final Base_Type otherValue){
if( otherValue instanceof PortType ) {
return assign((PortType) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `PortType' can not be cast to {1}", otherValue));
}

@Override
public PortType_template assign(final Base_Template otherValue){
if( otherValue instanceof PortType_template ) {
return assign((PortType_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `PortType'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final PortType.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final PortType.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type PortType.");
}
}

// originally match
public boolean match(final PortType otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final PortType otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof PortType ) {
return match((PortType) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `PortType' can not be cast to {1}", otherValue));
}

public PortType valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type PortType.");
}
return new PortType(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type PortType.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<PortType_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new PortType_template());
}
}

public PortType_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type PortType.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type PortType.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type PortType.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(PortType.enum2str(single_value), PortType.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof PortType) {
log_match((PortType)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortType.");
}
public void log_match(final PortType match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.PortType.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!PortType.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.PortType.", temp));
}
single_value = PortType.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<PortType_template>(size);
for(int i = 0; i < size; i++) {
final PortType_template temp = new PortType_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.PortType.");
}
}
}
public static void PortType_encoder(final PortType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortType_decoder( final TitanOctetString input_stream, final PortType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingFailureType_choice_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_choice_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_choice_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_choice_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorComponent_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorComponent_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorComponent_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorComponent_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_portState_encoder(final Port__State input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_portState_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_portState_decoder( final TitanOctetString input_stream, final Port__State output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_portState_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_dualDiscard_encoder(final Dualface__discard input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_dualDiscard_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_dualDiscard_decoder( final TitanOctetString input_stream, final Dualface__discard output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_dualDiscard_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_is__ptc_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_is__ptc_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_is__ptc_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_is__ptc_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_verdict__reason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_verdict__reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_verdict__reason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_verdict__reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class WarningEvent extends Base_Type {
		private final TitanCharString text; //CharString_Type

		public WarningEvent() {
			text = new TitanCharString();
		}

		public WarningEvent( final TitanCharString aText ) {
			text = new TitanCharString( aText );
		}

		public WarningEvent( final WarningEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.WarningEvent.");
			}
			text = new TitanCharString();
			assign( aOtherValue );
		}
		public WarningEvent assign(final WarningEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.WarningEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getText().isBound() ) {
					this.text.assign( aOtherValue.getText() );
				} else {
					this.text.cleanUp();
				}
			}

			return this;
		}

		@Override
		public WarningEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof WarningEvent ) {
				return assign((WarningEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.WarningEvent", otherValue));
		}

		public void cleanUp() {
			text.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( text.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !text.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final WarningEvent aOtherValue ) {
			if ( !this.text.operatorEquals( aOtherValue.text ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof WarningEvent ) {
				return operatorEquals((WarningEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.WarningEvent", otherValue));
		}

		public TitanCharString getText() {
			return text;
		}

		public TitanCharString constGetText() {
			return text;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" text := ");
			text.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (text.isBound()) {
				text.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			text.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			text.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class WarningEvent_template extends Base_Template {

	private TitanCharString_template text; //CharString_Type
	//originally value_list/list_value
	List<WarningEvent_template> list_value;

	public TitanCharString_template getText() {
		setSpecific();
		return text;
	}

	public TitanCharString_template constGetText() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field text of a non-specific template of type @TitanLoggerApi.WarningEvent.");
		}
		return text;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			text = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				text.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public WarningEvent_template() {
	}

	public WarningEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public WarningEvent_template( final WarningEvent otherValue ) {
		copyValue(otherValue);
	}

	public WarningEvent_template( final WarningEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public WarningEvent_template( final Optional<WarningEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.WarningEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public WarningEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public WarningEvent_template assign( final WarningEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public WarningEvent_template assign( final WarningEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public WarningEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof WarningEvent) {
				return assign((WarningEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `WarningEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public WarningEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof WarningEvent_template) {
				return assign((WarningEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `WarningEvent' can not be cast to {1}_template", otherValue));
		}

	public WarningEvent_template assign( final Optional<WarningEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.WarningEvent.");
		}
		return this;
	}

	private void copyValue(final WarningEvent other_value) {
		if (other_value.getText().isBound()) {
			getText().assign(other_value.getText());
		} else {
			getText().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final WarningEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getText().get_selection()) {
				getText().cleanUp();
			} else {
				getText().assign(other_value.getText());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<WarningEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final WarningEvent_template temp = new WarningEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.WarningEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public WarningEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.WarningEvent.");
			}
			final WarningEvent ret_val = new WarningEvent();
			 if (text.isBound()) {
				ret_val.text.assign(text.valueOf());
			}
			return ret_val;
		}

		public WarningEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.WarningEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.WarningEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.WarningEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<WarningEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new WarningEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (text.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!text.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final WarningEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final WarningEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getText().isBound()) {
					return false;
				}
				if(!text.match(other_value.getText(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.WarningEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof WarningEvent) {
		return match((WarningEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type WarningEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.WarningEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.WarningEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" text := ");
				text.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final WarningEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof WarningEvent) {
				log_match((WarningEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.WarningEvent.");
		}

		public void log_match(final WarningEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !text.match(match_value.constGetText(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".text");
							text.log_match(match_value.constGetText(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ text := ");
				text.log_match(match_value.constGetText(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.WarningEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text = new TitanCharString_template();
				text.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<WarningEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final WarningEvent_template temp = new WarningEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.WarningEvent.");
			}
		}
}
public static void WarningEvent_encoder(final WarningEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.WarningEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(WarningEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger WarningEvent_decoder( final TitanOctetString input_stream, final WarningEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.WarningEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(WarningEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void SetVerdictType_newReason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(SetVerdictType_newReason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger SetVerdictType_newReason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(SetVerdictType_newReason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ParPort_operation extends Base_Type {
public enum enum_type {
connect__ (0),
disconnect__ (1),
map__ (2),
unmap__ (3),
UNKNOWN_VALUE(4),
UNBOUND_VALUE(5);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return connect__;
case 1:  return disconnect__;
case 2:  return map__;
case 3:  return unmap__;
case 4:  return UNKNOWN_VALUE;
case 5:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public ParPort_operation() {
enum_value = enum_type.UNBOUND_VALUE;
}

public ParPort_operation(final ParPort_operation otherValue) {
enum_value = otherValue.enum_value;
}

public ParPort_operation(final ParPort_operation.enum_type otherValue ) {
enum_value = otherValue;
}

public ParPort_operation(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ParPort_operation' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public ParPort_operation assign(final ParPort_operation otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public ParPort_operation assign(final Base_Type otherValue){
if( otherValue instanceof ParPort_operation ) {
return assign((ParPort_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation' can not be cast to {1}", otherValue));
}

//originally operator=
public ParPort_operation assign(final ParPort_operation.enum_type otherValue){
return assign( new ParPort_operation(otherValue) );
}

//originally operator=
public ParPort_operation assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ParPort_operation'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final ParPort_operation otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof ParPort_operation) {
return operatorEquals( (ParPort_operation) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParPort.operation.");
}
}

//originally operator==
public boolean operatorEquals(final ParPort_operation.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final ParPort_operation otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final ParPort_operation.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final ParPort_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final ParPort_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final ParPort_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final ParPort_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final ParPort_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final ParPort_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ParPort_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ParPort_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParPort_operation. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final ParPort_operation.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final ParPort_operation enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("connect__".equals(strPar) || "connect_".equals(strPar)) {
return enum_type.connect__;
}
if ("disconnect__".equals(strPar) || "disconnect_".equals(strPar)) {
return enum_type.disconnect__;
}
if ("map__".equals(strPar) || "map_".equals(strPar)) {
return enum_type.map__;
}
if ("unmap__".equals(strPar) || "unmap_".equals(strPar)) {
return enum_type.unmap__;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ParPort.operation.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParPort.operation.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class ParPort_operation_template extends Base_Template {
// single_value
private ParPort_operation.enum_type single_value;
// value_list part
private ArrayList<ParPort_operation_template> value_list;

private void copy_template(final ParPort_operation_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ParPort_operation_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final ParPort_operation_template temp = new ParPort_operation_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ParPort_operation.");
}
}

public ParPort_operation_template() {
}

public ParPort_operation_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public ParPort_operation_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!ParPort_operation.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type ParPort_operation with unknown numeric value "+ otherValue +".");
}
single_value = ParPort_operation.enum_type.getValue(otherValue);
}

public ParPort_operation_template(final ParPort_operation otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == ParPort_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type ParPort_operation. ");
}
single_value = otherValue.enum_value;
}

public ParPort_operation_template(final ParPort_operation_template otherValue) {
copy_template(otherValue);
}

public ParPort_operation_template(final ParPort_operation.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != ParPort_operation.enum_type.UNBOUND_VALUE;
}

//originally operator=
public ParPort_operation_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public ParPort_operation_template assign(final int otherValue) {
if (!ParPort_operation.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ParPort_operation.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public ParPort_operation_template assign(final ParPort_operation.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public ParPort_operation_template assign(final ParPort_operation_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public ParPort_operation_template assign(final ParPort_operation otherValue){
if (otherValue.enum_value == ParPort_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type ParPort_operation to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public ParPort_operation_template assign(final Base_Type otherValue){
if( otherValue instanceof ParPort_operation ) {
return assign((ParPort_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation' can not be cast to {1}", otherValue));
}

@Override
public ParPort_operation_template assign(final Base_Template otherValue){
if( otherValue instanceof ParPort_operation_template ) {
return assign((ParPort_operation_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final ParPort_operation.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final ParPort_operation.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ParPort_operation.");
}
}

// originally match
public boolean match(final ParPort_operation otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final ParPort_operation otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof ParPort_operation ) {
return match((ParPort_operation) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort_operation' can not be cast to {1}", otherValue));
}

public ParPort_operation valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ParPort_operation.");
}
return new ParPort_operation(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type ParPort_operation.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<ParPort_operation_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ParPort_operation_template());
}
}

public ParPort_operation_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type ParPort_operation.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type ParPort_operation.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type ParPort_operation.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(ParPort_operation.enum2str(single_value), ParPort_operation.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ParPort_operation) {
log_match((ParPort_operation)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParPort.operation.");
}
public void log_match(final ParPort_operation match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ParPort.operation.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!ParPort_operation.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParPort.operation.", temp));
}
single_value = ParPort_operation.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ParPort_operation_template>(size);
for(int i = 0; i < size; i++) {
final ParPort_operation_template temp = new ParPort_operation_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ParPort.operation.");
}
}
}
public static void ParPort_operation_encoder(final ParPort_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParPort_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParPort_operation_decoder( final TitanOctetString input_stream, final ParPort_operation output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParPort_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ComponentIDType extends Base_Type {
		private final TitanInteger id; //Integer_Type
		private final TitanCharString name; //CharString_Type

		public ComponentIDType() {
			id = new TitanInteger();
			name = new TitanCharString();
		}

		public ComponentIDType( final TitanInteger aId, final TitanCharString aName ) {
			id = new TitanInteger( aId );
			name = new TitanCharString( aName );
		}

		public ComponentIDType( final ComponentIDType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ComponentIDType.");
			}
			id = new TitanInteger();
			name = new TitanCharString();
			assign( aOtherValue );
		}
		public ComponentIDType assign(final ComponentIDType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ComponentIDType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getId().isBound() ) {
					this.id.assign( aOtherValue.getId() );
				} else {
					this.id.cleanUp();
				}
				if ( aOtherValue.getName().isBound() ) {
					this.name.assign( aOtherValue.getName() );
				} else {
					this.name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ComponentIDType assign(final Base_Type otherValue) {
			if (otherValue instanceof ComponentIDType ) {
				return assign((ComponentIDType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ComponentIDType", otherValue));
		}

		public void cleanUp() {
			id.cleanUp();
			name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( id.isBound() ) { return true; }
			if ( name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !id.isValue() ) { return false; }
			if ( !name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ComponentIDType aOtherValue ) {
			if ( !this.id.operatorEquals( aOtherValue.id ) ) { return false; }
			if ( !this.name.operatorEquals( aOtherValue.name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ComponentIDType ) {
				return operatorEquals((ComponentIDType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ComponentIDType", otherValue));
		}

		public TitanInteger getId() {
			return id;
		}

		public TitanInteger constGetId() {
			return id;
		}

		public TitanCharString getName() {
			return name;
		}

		public TitanCharString constGetName() {
			return name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" id := ");
			id.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (id.isBound()) {
				id.set_implicit_omit();
			}
			if (name.isBound()) {
				name.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			id.encode_text(text_buf);
			name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			id.decode_text(text_buf);
			name.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ComponentIDType_template extends Base_Template {

	private TitanInteger_template id; //Integer_Type
	private TitanCharString_template name; //CharString_Type
	//originally value_list/list_value
	List<ComponentIDType_template> list_value;

	public TitanInteger_template getId() {
		setSpecific();
		return id;
	}

	public TitanInteger_template constGetId() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field id of a non-specific template of type @TitanLoggerApi.ComponentIDType.");
		}
		return id;
	}

	public TitanCharString_template getName() {
		setSpecific();
		return name;
	}

	public TitanCharString_template constGetName() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.ComponentIDType.");
		}
		return name;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			id = new TitanInteger_template();
			name = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				id.assign(template_sel.ANY_VALUE);
				name.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ComponentIDType_template() {
	}

	public ComponentIDType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ComponentIDType_template( final ComponentIDType otherValue ) {
		copyValue(otherValue);
	}

	public ComponentIDType_template( final ComponentIDType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ComponentIDType_template( final Optional<ComponentIDType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ComponentIDType from an unbound optional field.");
		}
	}

	//originally operator=
	public ComponentIDType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ComponentIDType_template assign( final ComponentIDType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ComponentIDType_template assign( final ComponentIDType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ComponentIDType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ComponentIDType) {
				return assign((ComponentIDType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ComponentIDType' can not be cast to {1}", otherValue));
		}

		@Override
		public ComponentIDType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ComponentIDType_template) {
				return assign((ComponentIDType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ComponentIDType' can not be cast to {1}_template", otherValue));
		}

	public ComponentIDType_template assign( final Optional<ComponentIDType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ComponentIDType.");
		}
		return this;
	}

	private void copyValue(final ComponentIDType other_value) {
		if (other_value.getId().isBound()) {
			getId().assign(other_value.getId());
		} else {
			getId().cleanUp();
		}
		if (other_value.getName().isBound()) {
			getName().assign(other_value.getName());
		} else {
			getName().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ComponentIDType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getId().get_selection()) {
				getId().cleanUp();
			} else {
				getId().assign(other_value.getId());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getName().get_selection()) {
				getName().cleanUp();
			} else {
				getName().assign(other_value.getName());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ComponentIDType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ComponentIDType_template temp = new ComponentIDType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ComponentIDType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ComponentIDType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ComponentIDType.");
			}
			final ComponentIDType ret_val = new ComponentIDType();
			 if (id.isBound()) {
				ret_val.id.assign(id.valueOf());
			}
			 if (name.isBound()) {
				ret_val.name.assign(name.valueOf());
			}
			return ret_val;
		}

		public ComponentIDType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ComponentIDType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ComponentIDType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ComponentIDType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ComponentIDType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ComponentIDType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (id.isBound()) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!id.isValue()) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ComponentIDType other_value) {
			return match(other_value, false);
		}

		public boolean match(final ComponentIDType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getId().isBound()) {
					return false;
				}
				if(!id.match(other_value.getId(), legacy)) {
					return false;
				}
				if(!other_value.getName().isBound()) {
					return false;
				}
				if(!name.match(other_value.getName(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ComponentIDType) {
		return match((ComponentIDType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ComponentIDType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ComponentIDType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" id := ");
				id.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ComponentIDType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ComponentIDType) {
				log_match((ComponentIDType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ComponentIDType.");
		}

		public void log_match(final ComponentIDType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !id.match(match_value.constGetId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".id");
							id.log_match(match_value.constGetId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !name.match(match_value.constGetName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ id := ");
				id.log_match(match_value.constGetId(), legacy);
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetName(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				id.encode_text(text_buf);
				name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ComponentIDType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				id = new TitanInteger_template();
				id.decode_text(text_buf);
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ComponentIDType_template>(size);
				for(int i = 0; i < size; i++) {
					final ComponentIDType_template temp = new ComponentIDType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ComponentIDType.");
			}
		}
}
public static void ComponentIDType_encoder(final ComponentIDType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ComponentIDType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ComponentIDType_decoder( final TitanOctetString input_stream, final ComponentIDType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ComponentIDType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StartFunction_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StartFunction_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StartFunction_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StartFunction_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_controlpartErrors_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_controlpartErrors_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_controlpartErrors_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_controlpartErrors_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void SetVerdictType_localVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(SetVerdictType_localVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger SetVerdictType_localVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(SetVerdictType_localVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class TitanLog_sequence__list_0_event__list extends Base_Type {

	private List<TitanLogEvent> valueElements;

	public TitanLog_sequence__list_0_event__list() {
	}

	public TitanLog_sequence__list_0_event__list( final TitanLog_sequence__list_0_event__list otherValue ) {
		otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		valueElements = copyList( otherValue.valueElements );
	}

	public TitanLog_sequence__list_0_event__list(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanLogEvent>();
	}

	private static final List<TitanLogEvent> copyList( final List<TitanLogEvent> srcList ) {
		if ( srcList == null ) {
			return null;
		}

		final List<TitanLogEvent> newList = new ArrayList<TitanLogEvent>( srcList.size() );
		for (final TitanLogEvent srcElem : srcList) {
			final TitanLogEvent newElem = getUnboundElem();
			if (srcElem.isBound()) {
				newElem.assign( srcElem );
			}
			newList.add( ( newElem ) );
		}
		return newList;
	}

	@Override
	public boolean isPresent() {
		return isBound();
	}

	@Override
	public boolean isBound() {
		return valueElements != null;
	}

	public void mustBound( final String aErrorMessage ) {
		if ( !isBound() ) {
			throw new TtcnError( aErrorMessage );
		}
	}

	@Override
	public boolean isValue() {
		if (valueElements == null) {
			return false;
		}
		for (int i=0; i < valueElements.size(); i++) {
			final TitanLogEvent elem = valueElements.get(i);
			if (elem == null || !elem.isValue()) {
				return false;
			}
		}
		return true;
	}


	@Override
	public boolean operatorEquals(final Base_Type otherValue) {
		if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
			return operatorEquals((TitanLog_sequence__list_0_event__list)otherValue);
		}
		throw new TtcnError("Internal Error: The left operand of comparison is not of type TitanLog_sequence__list_0_event__list.");
	}

	//originally operator==
	public boolean operatorEquals( final TitanLog_sequence__list_0_event__list otherValue ) {
		mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");

		final int size = valueElements.size();
		if ( size != otherValue.valueElements.size() ) {
			return false;
		}

		for ( int i = 0; i < size; i++ ) {
			final TitanLogEvent leftElem = valueElements.get( i );
			final TitanLogEvent rightElem = otherValue.valueElements.get( i );
			if (leftElem.isBound()) {
				if (rightElem.isBound()) {
					if ( !leftElem.operatorEquals( rightElem ) ) {
						return false;
					}
				} else {
					return false;
				}
			} else if (rightElem.isBound()) {
				return false;
			}
		}

		return true;
	}

	@Override
	public TitanLog_sequence__list_0_event__list assign(final Base_Type otherValue) {
	if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
		return assign((TitanLog_sequence__list_0_event__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list.");
	}

	//originally operator=
	public TitanLog_sequence__list_0_event__list assign( final TitanLog_sequence__list_0_event__list aOtherValue ) {
		aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );

		valueElements = copyList( aOtherValue.valueElements );
		return this;
	}

	public TitanLog_sequence__list_0_event__list assign(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanLogEvent>();
		return this;
	}

	//originally operator+
	public TitanLog_sequence__list_0_event__list concatenate(final TitanLog_sequence__list_0_event__list other_value) {
		if (valueElements == null || other_value.valueElements == null) {
			throw new TtcnError("Unbound operand of @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list concatenation.");
		}
		final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i < valueElements.size(); i++) {
			final TitanLogEvent elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		for (int i = 0; i < other_value.valueElements.size(); i++) {
			final TitanLogEvent elem = other_value.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		return ret_val;
	}

	public TitanLog_sequence__list_0_event__list concatenate(final TitanNull_Type nullValue) {
		return new TitanLog_sequence__list_0_event__list(this);
	}

	//originally operator<<=
	public TitanLog_sequence__list_0_event__list rotateLeft(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate left operator.");
		return rotateLeft(rotate_count.getInt());
	}

	//originally operator<<=
	public TitanLog_sequence__list_0_event__list rotateLeft(final int rotate_count) {
		return rotateRight(-rotate_count);
	}

	//originally operator>>=
	public TitanLog_sequence__list_0_event__list rotateRight(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate right operator.");
		return rotateRight(rotate_count.getInt());
	}

	//originally operator>>=
	public TitanLog_sequence__list_0_event__list rotateRight(final int rotate_count) {
		if (valueElements == null) {
			throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		final int size = valueElements.size();
		if (size == 0) {
			return new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
		}
		int rc;
		if (rotate_count >= 0) {
			rc = rotate_count % size;
		} else {
			rc = size - ((-rotate_count) % size);
		}
		if (rc == 0) {
			return new TitanLog_sequence__list_0_event__list(this);
		}
		final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
		for (int i = size - rc; i < size; i++) {
			final TitanLogEvent elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		for (int i = 0; i < size - rc; i++) {
			final TitanLogEvent elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		return ret_val;
	}

	//originally clean_up
	public void cleanUp() {
		valueElements = null;
	}

	//originally get_at(int)
	public TitanLogEvent getAt( final int index_value ) {
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: "+index_value+".");
		}

		if (valueElements == null || index_value >= valueElements.size() ) {
			//increase list size
			setSize(index_value + 1);
		}

		if ( valueElements.get( index_value ) == null ) {
			final TitanLogEvent newElem = getUnboundElem();
			valueElements.set( index_value, newElem );
		}
		return valueElements.get( index_value );
	}

	//originally get_at(const INTEGER&)
	public TitanLogEvent getAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );
		return getAt( index_value.getInt() );
	}

	//originally get_at(int) const
	public TitanLogEvent constGetAt( final int index_value ) {
		if ( !isBound() ) {
			throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );
		}
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: "+index_value+".");
		}
		final int nofElements = n_elem().getInt();
		if ( index_value >= nofElements ) {
			throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
		}

		final TitanLogEvent elem = valueElements.get( index_value );
		return ( elem != null ) ? elem : getUnboundElem();
	}

	//originally get_at(const INTEGER&) const
	public TitanLogEvent constGetAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list." );
		return constGetAt( index_value.getInt() );
	}

	public TitanInteger sizeOf() {
		mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		return new TitanInteger(valueElements.size());
	}

	public TitanInteger n_elem() {
		return sizeOf();
	}

	public TitanInteger lengthOf() {
		mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
			final TitanLogEvent elem = valueElements.get( i );
			if ( elem != null && elem.isBound() ) {
				return new TitanInteger(i + 1);
			}
		}
		return new TitanInteger(0);
	}

	public void setSize(final int newSize) {
		if (newSize < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		if ( valueElements == null ) {
			valueElements = new ArrayList<TitanLogEvent>();
		}
		if (newSize > valueElements.size()) {
			for ( int i = valueElements.size(); i < newSize; i++ ) {
				valueElements.add( new TitanLogEvent() );
			}
		} else if (newSize < valueElements.size()) {
			while(valueElements.size() > newSize) {
				valueElements.remove(valueElements.size()-1);
			}
		}
	}

	private static TitanLogEvent getUnboundElem() {
		return new TitanLogEvent();
	}
/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */

	@Override
	public String toString() {
		if (!isBound()) {
			return "<unbound>";
		}
		final StringBuilder sb = new StringBuilder();
		sb.append('{');
		final int size = ( valueElements == null ) ? 0 : valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				sb.append(',');
			}
			sb.append(valueElements.get(i).toString());
		}
		sb.append('}');
		return sb.toString();
	}

	public TitanLog_sequence__list_0_event__list substr(final int index, final int returncount) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list","element");
		final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i<returncount; i++) {
			if (valueElements.get(i+index) != null) {
				ret_val.valueElements.add(new TitanLogEvent(valueElements.get(i+index)));
			}
		}
		return ret_val;
	}

	public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list repl) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		if (repl.valueElements == null) {
			throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list","element");
		final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
		for (int i = 0; i < index; i++) {
			final TitanLogEvent elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		for (int i = 0; i < repl.valueElements.size(); i++) {
			final TitanLogEvent elem = repl.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		for (int i = 0; i < valueElements.size() - index - len; i++) {
			final TitanLogEvent elem = valueElements.get(index + i + len);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLogEvent(elem));
			}
		}
		return ret_val;
	}

	public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len, repl.valueOf());
	}

	public TitanLog_sequence__list_0_event__list replace(final int index, final TitanInteger len, final TitanLog_sequence__list_0_event__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len.getInt(), repl.valueOf());
	}

	public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final int len, final TitanLog_sequence__list_0_event__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len, repl.valueOf());
	}

	public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_0_event__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len.getInt(), repl.valueOf());
	}
	public void log() {
		if (valueElements == null) {
			TTCN_Logger.log_event_unbound();
			return;
		}
		TTCN_Logger.log_event_str("{ ");
		final int size = valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				TTCN_Logger.log_event_str(", ");
			}
		valueElements.get(i).log();
		}
		TTCN_Logger.log_event_str(" }");
	}
		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanLogEvent>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanLogEvent temp2 = new TitanLogEvent();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

}
public static class TitanLog_sequence__list_0_event__list_template extends Record_Of_Template {

	//originally single_value/value_elements
	List<TitanLogEvent_template> value_elements;

	//originally value_list/list_value
	List<TitanLog_sequence__list_0_event__list_template> list_value;

	private final match_function_t match_function_specific = new match_function_t() {
		@Override
		public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
			return match_index((TitanLog_sequence__list_0_event__list)value_ptr, value_index, (TitanLog_sequence__list_0_event__list_template)template_ptr, template_index, legacy);
		}
	};

	public TitanLog_sequence__list_0_event__list_template() {
	}

	public TitanLog_sequence__list_0_event__list_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanLog_sequence__list_0_event__list_template( final TitanLog_sequence__list_0_event__list otherValue ) {
		copy_value( otherValue );
	}

	public TitanLog_sequence__list_0_event__list_template( final TitanLog_sequence__list_0_event__list_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanLog_sequence__list_0_event__list_template( final Optional<TitanLog_sequence__list_0_event__list> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list from an unbound optional field.");
		}
	}

	public TitanLog_sequence__list_0_event__list_template( final TitanNull_Type nullValue ) {
		super( template_sel.SPECIFIC_VALUE );
		value_elements = new ArrayList<TitanLogEvent_template>();
	}

	private void copy_value(final TitanLog_sequence__list_0_event__list other_value) {
		if (!other_value.isBound()) {
			throw new TtcnError("Initialization of a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list with an unbound value.");
		}
		value_elements = new ArrayList<TitanLogEvent_template>();
		final int otherSize = other_value.valueElements.size();
		for (int elem_count = 0; elem_count < otherSize; elem_count++) {
			if (other_value.constGetAt(elem_count).isBound()) {
				value_elements.add( new TitanLogEvent_template(other_value.constGetAt(elem_count)) );
			} else {
				value_elements.add( new TitanLogEvent_template() );
			}
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanLog_sequence__list_0_event__list_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			value_elements = new ArrayList<TitanLogEvent_template>();
			final int otherSize = other_value.value_elements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanLogEvent_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanLogEvent_template() );
				}
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLog_sequence__list_0_event__list_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanLog_sequence__list_0_event__list_template temp = new TitanLog_sequence__list_0_event__list_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		set_selection(other_value);
	}

	public boolean isPresent() {
		return isPresent(false);
	}

	public boolean isPresent(final boolean legacy) {
		if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
			return false;
		}
		return !match_omit(legacy);
	}

	// originally match
	public boolean match(final TitanLog_sequence__list_0_event__list other_value) {
		return match(other_value, false);
	}

	// originally match
	public boolean match(final TitanLog_sequence__list_0_event__list other_value, final boolean legacy) {
		if(!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case OMIT_VALUE:
			return false;
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for(int i = 0 ; i < list_value.size(); i++) {
				if(list_value.get(i).match(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
				}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
	}

	private boolean match_index(final TitanLog_sequence__list_0_event__list value_ptr, final int value_index, final TitanLog_sequence__list_0_event__list_template template_ptr, final int template_index, final boolean legacy) {
		if (value_index >= 0) {
			return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
		} else {
			return template_ptr.value_elements.get(template_index).is_any_or_omit();
		}
	}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
		if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
			return match((TitanLog_sequence__list_0_event__list)otherValue, legacy);
		}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list.");
	}

	public boolean match_omit(final boolean legacy) {
		if (is_ifPresent) {
			return true;
		}
		switch (templateSelection) {
		case OMIT_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			if (legacy) {
				for (int i = 0 ; i < list_value.size(); i++) {
					if (list_value.get(i).match_omit(legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			}
			return false;
		default:
			return false;
		}
	}

	//originally operator=
	public TitanLog_sequence__list_0_event__list_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_sequence__list_0_event__list_template assign( final TitanLog_sequence__list_0_event__list other_value ) {
		cleanUp();
		copy_value(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_sequence__list_0_event__list_template assign( final TitanLog_sequence__list_0_event__list_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

	@Override
	public TitanLog_sequence__list_0_event__list_template assign(final Base_Type otherValue) {
	if (otherValue instanceof TitanLog_sequence__list_0_event__list) {
		return assign((TitanLog_sequence__list_0_event__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list.");
	}

	@Override
	public TitanLog_sequence__list_0_event__list_template assign(final Base_Template otherValue) {
	if (otherValue instanceof TitanLog_sequence__list_0_event__list_template) {
		return assign((TitanLog_sequence__list_0_event__list_template)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0_event__list_template.");
	}

	public TitanLog_sequence__list_0_event__list_template assign( final Optional<TitanLog_sequence__list_0_event__list> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		return this;
	}

	@Override
	public void cleanUp() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			value_elements.clear();
			value_elements = null;
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value.clear();
			list_value = null;
			break;
		default:
			break;
		}
		templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
	}

	public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl.valueOf());
	}

	public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_0_event__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
	}

	public TitanLog_sequence__list_0_event__list replace(final int index, final int len, final TitanLog_sequence__list_0_event__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl);
	}

	public TitanLog_sequence__list_0_event__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_0_event__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl);
	}

	public TitanLogEvent_template getAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: {0}.", index_value ) );
		}

		switch (templateSelection) {
		case SPECIFIC_VALUE:
			if(index_value < value_elements.size()) {

				break;
			}
			// no break
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case UNINITIALIZED_TEMPLATE:
			setSize(index_value + 1);
			break;
		default:
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		return value_elements.get(index_value);
	}

	public TitanLogEvent_template getAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}

		return getAt(index_value.getInt());
	}

	public TitanLogEvent_template constGetAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index: {0}.", index_value ) );
		}

		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}

		if (index_value >= value_elements.size()) {
			throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
		}

		return value_elements.get(index_value);
	}

	public TitanLogEvent_template constGetAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}

		return constGetAt(index_value.getInt());
	}

	private int get_length_for_concat(final AtomicBoolean is_any_value) {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return value_elements.size();
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				if (templateSelection == template_sel.ANY_VALUE) {
					// ? => { * }
					is_any_value.set( true );
					return 1;
				}
				throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
			case RANGE_LENGTH_RESTRICTION:
				if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
					throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
				}
				// else fall through (range length restriction is allowed if the minimum
				// and maximum value are the same)
			case SINGLE_LENGTH_RESTRICTION:
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
			}
		default:
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}
	}

	private int get_length_for_concat(final TitanLog_sequence__list_0_event__list operand) {
		operand.mustBound("Operand of record of template concatenation is an unbound value.");
		return operand.valueElements.size();
	}


	private int get_length_for_concat(final template_sel operand) {
		if (operand == template_sel.ANY_VALUE) {
			// ? => { * }
			return 1;
		}
		throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
	}

			//TODO: simplify, just use value_elements.add()
	private void concat(final AtomicInteger pos, final TitanLog_sequence__list_0_event__list_template operand) {
		// all errors should have already been caught by the operand's
		// get_length_for_concat() call;
		// the result template (this) should already be set to SPECIFIC_VALUE and
		// single_value.value_elements should already be allocated
		switch (operand.templateSelection) {
		case SPECIFIC_VALUE:
			for (int i = 0; i < operand.value_elements.size(); ++i) {
				value_elements.set( pos.get() + i, new TitanLogEvent_template(operand.value_elements.get(i)) );
			}
			pos.addAndGet( operand.value_elements.size() );
			break;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (operand.length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				// ? => { * }
				value_elements.set( pos.get(), new TitanLogEvent_template( template_sel.ANY_OR_OMIT ) );
				pos.incrementAndGet();
				break;
			case RANGE_LENGTH_RESTRICTION:
			case SINGLE_LENGTH_RESTRICTION: {
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
				for (int i = 0; i < N; ++i) {
					value_elements.set( pos.get() + i, new TitanLogEvent_template( template_sel.ANY_VALUE ) );
				}
				pos.addAndGet( N );
				break; }
			}
		default:
			break;
		}
	}

	public void setSize(final int new_size) {
		if (new_size < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		final template_sel old_selection = templateSelection;
		if (old_selection != template_sel.SPECIFIC_VALUE) {
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = null;
		}
		if (value_elements == null) {
			value_elements = new ArrayList<TitanLogEvent_template>();
		}
		if (new_size > value_elements.size()) {
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanLogEvent_template(template_sel.ANY_VALUE) );
				}
			} else {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanLogEvent_template() );
				}
			}
		} else if (new_size < value_elements.size()) {
			final int oldSize = value_elements.size();
			for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
				value_elements.remove( new_size );
			}
		}
	}

	public TitanInteger sizeOf() {
		return sizeOf(true);
	}

	public TitanInteger lengthOf() {
		return sizeOf(false);
	}

	public TitanInteger sizeOf(final boolean is_size) {
		final String op_name = is_size ? "size" : "length";
		if (is_ifPresent) {
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list which has an ifpresent attribute.", op_name ) );
		}
		int min_size;
		boolean has_any_or_none;
		switch (templateSelection)
		{
		case SPECIFIC_VALUE: {
			min_size = 0;
			has_any_or_none = false;
			int elem_count = value_elements.size();
			if (!is_size) {
				while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
					elem_count--;
				}
			}
			for (int i=0; i<elem_count; i++)
			{
			switch (value_elements.get(i).get_selection())
				{
				case OMIT_VALUE:
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing omit element.", op_name ) );
				case ANY_OR_OMIT:
					has_any_or_none = true;
					break;
				default:
					min_size++;
					break;
				}
			}
		} break;
		case OMIT_VALUE:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing omit value.", op_name ) );
		case ANY_VALUE:
		case ANY_OR_OMIT:
			min_size = 0;
			has_any_or_none = true;
			break;
		case VALUE_LIST:
		{
			if (list_value.size()<1) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing an empty list.", op_name ) );
			}
			final int item_size = list_value.get(0).sizeOf(is_size).getInt();
			for (int i = 1; i < list_value.size(); i++) {
				if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing a value list with different sizes.", op_name ) );
				}
			}
			min_size = item_size;
			has_any_or_none = false;
			break;
		}
		case COMPLEMENTED_LIST:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list containing complemented list.", op_name ) );
		default:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type TitanLog_sequence__list_0_event__list.", op_name ) );
		}
		return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanLogEvent_template"));
	}

	public TitanInteger n_elem() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return new TitanInteger(value_elements.size());
		case COMPLEMENTED_LIST:
			throw new TtcnError("Performing n_elem() operation on a template of type TitanLog_sequence__list_0_event__list containing complemented list.");
		case UNINITIALIZED_TEMPLATE:
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case VALUE_LIST:
		case VALUE_RANGE:
		case STRING_PATTERN:
		case SUPERSET_MATCH:
		case SUBSET_MATCH:
		case DECODE_MATCH:
			break;
		}
		throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type TitanLog_sequence__list_0_event__list.");
	}

	private boolean matchv(final TitanLog_sequence__list_0_event__list other_value, final boolean legacy) {
		if (!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case OMIT_VALUE:
			return false;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for (int list_count = 0; list_count < list_value.size(); list_count++) {
				if (list_value.get(list_count).matchv(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
		}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type TitanLog_sequence__list_0_event__list.");
		}
	}

	@Override
	public boolean isValue() {
		if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
			return false;
		}
		for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
			if (!value_elements.get(elem_count).isValue()) {
				return false;
			}
		}
		return true;
	}

	public void setType(final template_sel template_type, final int list_length) {
		cleanUp();
		switch (template_type) {
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLog_sequence__list_0_event__list_template>( list_length );
			for (int list_count = 0; list_count < list_length; list_count++) {
				list_value.add( new TitanLog_sequence__list_0_event__list_template() );
			}
			break;
		default:
			throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		set_selection(template_type);
	}

		public TitanLog_sequence__list_0_event__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			return list_value.get(list_index);
		}

	public TitanLog_sequence__list_0_event__list_template get_list_item(final int list_index) {
		if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
			throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		if (list_index < 0) {
			throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list using a negative index ({0}).", list_index ) );
		}
		if (list_index >= list_value.size()) {
			throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
		}
		return list_value.get( list_index );
	}

		public TitanLog_sequence__list_0_event__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
			final TitanLog_sequence__list_0_event__list ret_val = new TitanLog_sequence__list_0_event__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_event__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

	public void log_match(final TitanLog_sequence__list_0_event__list match_value) {
		log_match(match_value, false);
	}

	@Override
	public void log_match(final Base_Type match_value, final boolean legacy) {
		if (match_value instanceof TitanLog_sequence__list_0_event__list) {
			log_match((TitanLog_sequence__list_0_event__list)match_value, legacy);
			return;
		}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
	}

	public void log_match(final TitanLog_sequence__list_0_event__list match_value, final boolean legacy) {
		if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
			if(match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
			} else {
				if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
						TTCN_Logger.log_logmatch_info("[%d]", elem_count);
							value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					}
					log_match_length(value_elements.size());
				} else {
					TTCN_Logger.print_logmatch_buffer();
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
			return;
		}
		if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
			TTCN_Logger.log_event_str("{ ");
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (elem_count > 0) {
					TTCN_Logger.log_event_str(", ");
				}
				value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
			}
			TTCN_Logger.log_event_str(" }");
			log_match_length(value_elements.size());
		} else {
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if ( match(match_value, legacy) ) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}
	}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
				}
				value_elements = new ArrayList<TitanLogEvent_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanLogEvent_template temp2 = new TitanLogEvent_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_sequence__list_0_event__list_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLog_sequence__list_0_event__list_template temp2 = new TitanLog_sequence__list_0_event__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.event_list.");
			}
		}

	@Override
	public boolean get_istemplate_kind(final String type) {
		if ("AnyElement".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
			return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
					return true;
				}
			}
			return false;
		} else if ("AnyElementsOrNone".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
					return true;
				}
			}
			return false;
		} else if ("permutation".equals(type)) {
			return get_number_of_permutations() != 0;
		} else if ("length".equals(type)) {
			return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
		} else {
			return super.get_istemplate_kind(type);
		}
	}
}
public static void TitanLog_sequence__list_0_event__list_encoder(final TitanLog_sequence__list_0_event__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLog_sequence__list_0_event__list_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLog_sequence__list_0_event__list_decoder( final TitanOctetString input_stream, final TitanLog_sequence__list_0_event__list output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype.event_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLog_sequence__list_0_event__list_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class LogEventType_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_ActionEvent,  ALT_DefaultEvent,  ALT_ErrorLog,  ALT_ExecutorEvent,  ALT_FunctionEvent,  ALT_ParallelEvent,  ALT_TestcaseOp,  ALT_PortEvent,  ALT_Statistics,  ALT_TimerEvent,  ALT_UserLog,  ALT_VerdictOp,  ALT_WarningLog,  ALT_MatchingEvent,  ALT_DebugLog,  ALT_ExecutionSummary,  ALT_UnhandledEvent };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public LogEventType_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public LogEventType_choice(final LogEventType_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final LogEventType_choice otherValue) {
switch (otherValue.union_selection){
case ALT_ActionEvent:
field = new Strings((Strings)otherValue.field);
break;
case ALT_DefaultEvent:
field = new DefaultEvent((DefaultEvent)otherValue.field);
break;
case ALT_ErrorLog:
field = new Categorized((Categorized)otherValue.field);
break;
case ALT_ExecutorEvent:
field = new ExecutorEvent((ExecutorEvent)otherValue.field);
break;
case ALT_FunctionEvent:
field = new FunctionEvent((FunctionEvent)otherValue.field);
break;
case ALT_ParallelEvent:
field = new ParallelEvent((ParallelEvent)otherValue.field);
break;
case ALT_TestcaseOp:
field = new TestcaseEvent((TestcaseEvent)otherValue.field);
break;
case ALT_PortEvent:
field = new PortEvent((PortEvent)otherValue.field);
break;
case ALT_Statistics:
field = new StatisticsType((StatisticsType)otherValue.field);
break;
case ALT_TimerEvent:
field = new TimerEvent((TimerEvent)otherValue.field);
break;
case ALT_UserLog:
field = new Strings((Strings)otherValue.field);
break;
case ALT_VerdictOp:
field = new VerdictOp((VerdictOp)otherValue.field);
break;
case ALT_WarningLog:
field = new Categorized((Categorized)otherValue.field);
break;
case ALT_MatchingEvent:
field = new MatchingEvent((MatchingEvent)otherValue.field);
break;
case ALT_DebugLog:
field = new Categorized((Categorized)otherValue.field);
break;
case ALT_ExecutionSummary:
field = new ExecutionSummaryType((ExecutionSummaryType)otherValue.field);
break;
case ALT_UnhandledEvent:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.LogEventType.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public LogEventType_choice assign( final LogEventType_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public LogEventType_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof LogEventType_choice) {
return assign((LogEventType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.LogEventType.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_ActionEvent:
return field.isValue();
case ALT_DefaultEvent:
return field.isValue();
case ALT_ErrorLog:
return field.isValue();
case ALT_ExecutorEvent:
return field.isValue();
case ALT_FunctionEvent:
return field.isValue();
case ALT_ParallelEvent:
return field.isValue();
case ALT_TestcaseOp:
return field.isValue();
case ALT_PortEvent:
return field.isValue();
case ALT_Statistics:
return field.isValue();
case ALT_TimerEvent:
return field.isValue();
case ALT_UserLog:
return field.isValue();
case ALT_VerdictOp:
return field.isValue();
case ALT_WarningLog:
return field.isValue();
case ALT_MatchingEvent:
return field.isValue();
case ALT_DebugLog:
return field.isValue();
case ALT_ExecutionSummary:
return field.isValue();
case ALT_UnhandledEvent:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final LogEventType_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.LogEventType.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.LogEventType.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_ActionEvent:
return ((Strings)field).operatorEquals((Strings)otherValue.field);
case ALT_DefaultEvent:
return ((DefaultEvent)field).operatorEquals((DefaultEvent)otherValue.field);
case ALT_ErrorLog:
return ((Categorized)field).operatorEquals((Categorized)otherValue.field);
case ALT_ExecutorEvent:
return ((ExecutorEvent)field).operatorEquals((ExecutorEvent)otherValue.field);
case ALT_FunctionEvent:
return ((FunctionEvent)field).operatorEquals((FunctionEvent)otherValue.field);
case ALT_ParallelEvent:
return ((ParallelEvent)field).operatorEquals((ParallelEvent)otherValue.field);
case ALT_TestcaseOp:
return ((TestcaseEvent)field).operatorEquals((TestcaseEvent)otherValue.field);
case ALT_PortEvent:
return ((PortEvent)field).operatorEquals((PortEvent)otherValue.field);
case ALT_Statistics:
return ((StatisticsType)field).operatorEquals((StatisticsType)otherValue.field);
case ALT_TimerEvent:
return ((TimerEvent)field).operatorEquals((TimerEvent)otherValue.field);
case ALT_UserLog:
return ((Strings)field).operatorEquals((Strings)otherValue.field);
case ALT_VerdictOp:
return ((VerdictOp)field).operatorEquals((VerdictOp)otherValue.field);
case ALT_WarningLog:
return ((Categorized)field).operatorEquals((Categorized)otherValue.field);
case ALT_MatchingEvent:
return ((MatchingEvent)field).operatorEquals((MatchingEvent)otherValue.field);
case ALT_DebugLog:
return ((Categorized)field).operatorEquals((Categorized)otherValue.field);
case ALT_ExecutionSummary:
return ((ExecutionSummaryType)field).operatorEquals((ExecutionSummaryType)otherValue.field);
case ALT_UnhandledEvent:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof LogEventType_choice) {
return operatorEquals((LogEventType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final LogEventType_choice otherValue ) {
return !operatorEquals(otherValue);
}

public Strings getActionEvent() {
if (union_selection != union_selection_type.ALT_ActionEvent) {
cleanUp();
field = new Strings();
union_selection = union_selection_type.ALT_ActionEvent;
}
return (Strings)field;
}

public Strings constGetActionEvent() {
if (union_selection != union_selection_type.ALT_ActionEvent) {
throw new TtcnError("Using non-selected field actionEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Strings)field;
}

public DefaultEvent getDefaultEvent() {
if (union_selection != union_selection_type.ALT_DefaultEvent) {
cleanUp();
field = new DefaultEvent();
union_selection = union_selection_type.ALT_DefaultEvent;
}
return (DefaultEvent)field;
}

public DefaultEvent constGetDefaultEvent() {
if (union_selection != union_selection_type.ALT_DefaultEvent) {
throw new TtcnError("Using non-selected field defaultEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (DefaultEvent)field;
}

public Categorized getErrorLog() {
if (union_selection != union_selection_type.ALT_ErrorLog) {
cleanUp();
field = new Categorized();
union_selection = union_selection_type.ALT_ErrorLog;
}
return (Categorized)field;
}

public Categorized constGetErrorLog() {
if (union_selection != union_selection_type.ALT_ErrorLog) {
throw new TtcnError("Using non-selected field errorLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Categorized)field;
}

public ExecutorEvent getExecutorEvent() {
if (union_selection != union_selection_type.ALT_ExecutorEvent) {
cleanUp();
field = new ExecutorEvent();
union_selection = union_selection_type.ALT_ExecutorEvent;
}
return (ExecutorEvent)field;
}

public ExecutorEvent constGetExecutorEvent() {
if (union_selection != union_selection_type.ALT_ExecutorEvent) {
throw new TtcnError("Using non-selected field executorEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (ExecutorEvent)field;
}

public FunctionEvent getFunctionEvent() {
if (union_selection != union_selection_type.ALT_FunctionEvent) {
cleanUp();
field = new FunctionEvent();
union_selection = union_selection_type.ALT_FunctionEvent;
}
return (FunctionEvent)field;
}

public FunctionEvent constGetFunctionEvent() {
if (union_selection != union_selection_type.ALT_FunctionEvent) {
throw new TtcnError("Using non-selected field functionEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (FunctionEvent)field;
}

public ParallelEvent getParallelEvent() {
if (union_selection != union_selection_type.ALT_ParallelEvent) {
cleanUp();
field = new ParallelEvent();
union_selection = union_selection_type.ALT_ParallelEvent;
}
return (ParallelEvent)field;
}

public ParallelEvent constGetParallelEvent() {
if (union_selection != union_selection_type.ALT_ParallelEvent) {
throw new TtcnError("Using non-selected field parallelEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (ParallelEvent)field;
}

public TestcaseEvent getTestcaseOp() {
if (union_selection != union_selection_type.ALT_TestcaseOp) {
cleanUp();
field = new TestcaseEvent();
union_selection = union_selection_type.ALT_TestcaseOp;
}
return (TestcaseEvent)field;
}

public TestcaseEvent constGetTestcaseOp() {
if (union_selection != union_selection_type.ALT_TestcaseOp) {
throw new TtcnError("Using non-selected field testcaseOp in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (TestcaseEvent)field;
}

public PortEvent getPortEvent() {
if (union_selection != union_selection_type.ALT_PortEvent) {
cleanUp();
field = new PortEvent();
union_selection = union_selection_type.ALT_PortEvent;
}
return (PortEvent)field;
}

public PortEvent constGetPortEvent() {
if (union_selection != union_selection_type.ALT_PortEvent) {
throw new TtcnError("Using non-selected field portEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (PortEvent)field;
}

public StatisticsType getStatistics() {
if (union_selection != union_selection_type.ALT_Statistics) {
cleanUp();
field = new StatisticsType();
union_selection = union_selection_type.ALT_Statistics;
}
return (StatisticsType)field;
}

public StatisticsType constGetStatistics() {
if (union_selection != union_selection_type.ALT_Statistics) {
throw new TtcnError("Using non-selected field statistics in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (StatisticsType)field;
}

public TimerEvent getTimerEvent() {
if (union_selection != union_selection_type.ALT_TimerEvent) {
cleanUp();
field = new TimerEvent();
union_selection = union_selection_type.ALT_TimerEvent;
}
return (TimerEvent)field;
}

public TimerEvent constGetTimerEvent() {
if (union_selection != union_selection_type.ALT_TimerEvent) {
throw new TtcnError("Using non-selected field timerEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (TimerEvent)field;
}

public Strings getUserLog() {
if (union_selection != union_selection_type.ALT_UserLog) {
cleanUp();
field = new Strings();
union_selection = union_selection_type.ALT_UserLog;
}
return (Strings)field;
}

public Strings constGetUserLog() {
if (union_selection != union_selection_type.ALT_UserLog) {
throw new TtcnError("Using non-selected field userLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Strings)field;
}

public VerdictOp getVerdictOp() {
if (union_selection != union_selection_type.ALT_VerdictOp) {
cleanUp();
field = new VerdictOp();
union_selection = union_selection_type.ALT_VerdictOp;
}
return (VerdictOp)field;
}

public VerdictOp constGetVerdictOp() {
if (union_selection != union_selection_type.ALT_VerdictOp) {
throw new TtcnError("Using non-selected field verdictOp in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (VerdictOp)field;
}

public Categorized getWarningLog() {
if (union_selection != union_selection_type.ALT_WarningLog) {
cleanUp();
field = new Categorized();
union_selection = union_selection_type.ALT_WarningLog;
}
return (Categorized)field;
}

public Categorized constGetWarningLog() {
if (union_selection != union_selection_type.ALT_WarningLog) {
throw new TtcnError("Using non-selected field warningLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Categorized)field;
}

public MatchingEvent getMatchingEvent() {
if (union_selection != union_selection_type.ALT_MatchingEvent) {
cleanUp();
field = new MatchingEvent();
union_selection = union_selection_type.ALT_MatchingEvent;
}
return (MatchingEvent)field;
}

public MatchingEvent constGetMatchingEvent() {
if (union_selection != union_selection_type.ALT_MatchingEvent) {
throw new TtcnError("Using non-selected field matchingEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (MatchingEvent)field;
}

public Categorized getDebugLog() {
if (union_selection != union_selection_type.ALT_DebugLog) {
cleanUp();
field = new Categorized();
union_selection = union_selection_type.ALT_DebugLog;
}
return (Categorized)field;
}

public Categorized constGetDebugLog() {
if (union_selection != union_selection_type.ALT_DebugLog) {
throw new TtcnError("Using non-selected field debugLog in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Categorized)field;
}

public ExecutionSummaryType getExecutionSummary() {
if (union_selection != union_selection_type.ALT_ExecutionSummary) {
cleanUp();
field = new ExecutionSummaryType();
union_selection = union_selection_type.ALT_ExecutionSummary;
}
return (ExecutionSummaryType)field;
}

public ExecutionSummaryType constGetExecutionSummary() {
if (union_selection != union_selection_type.ALT_ExecutionSummary) {
throw new TtcnError("Using non-selected field executionSummary in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (ExecutionSummaryType)field;
}

public TitanCharString getUnhandledEvent() {
if (union_selection != union_selection_type.ALT_UnhandledEvent) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_UnhandledEvent;
}
return (TitanCharString)field;
}

public TitanCharString constGetUnhandledEvent() {
if (union_selection != union_selection_type.ALT_UnhandledEvent) {
throw new TtcnError("Using non-selected field unhandledEvent in a value of union type @TitanLoggerApi.LogEventType.choice.");
}
return (TitanCharString)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_ActionEvent:
TTCN_Logger.log_event_str("{ actionEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_DefaultEvent:
TTCN_Logger.log_event_str("{ defaultEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ErrorLog:
TTCN_Logger.log_event_str("{ errorLog := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExecutorEvent:
TTCN_Logger.log_event_str("{ executorEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_FunctionEvent:
TTCN_Logger.log_event_str("{ functionEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ParallelEvent:
TTCN_Logger.log_event_str("{ parallelEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_TestcaseOp:
TTCN_Logger.log_event_str("{ testcaseOp := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_PortEvent:
TTCN_Logger.log_event_str("{ portEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_Statistics:
TTCN_Logger.log_event_str("{ statistics := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_TimerEvent:
TTCN_Logger.log_event_str("{ timerEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_UserLog:
TTCN_Logger.log_event_str("{ userLog := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_VerdictOp:
TTCN_Logger.log_event_str("{ verdictOp := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_WarningLog:
TTCN_Logger.log_event_str("{ warningLog := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MatchingEvent:
TTCN_Logger.log_event_str("{ matchingEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_DebugLog:
TTCN_Logger.log_event_str("{ debugLog := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ExecutionSummary:
TTCN_Logger.log_event_str("{ executionSummary := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_UnhandledEvent:
TTCN_Logger.log_event_str("{ unhandledEvent := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_ActionEvent:
case ALT_DefaultEvent:
case ALT_ErrorLog:
case ALT_ExecutorEvent:
case ALT_FunctionEvent:
case ALT_ParallelEvent:
case ALT_TestcaseOp:
case ALT_PortEvent:
case ALT_Statistics:
case ALT_TimerEvent:
case ALT_UserLog:
case ALT_VerdictOp:
case ALT_WarningLog:
case ALT_MatchingEvent:
case ALT_DebugLog:
case ALT_ExecutionSummary:
case ALT_UnhandledEvent:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_ActionEvent:
text_buf.push_int(0);
break;
case ALT_DefaultEvent:
text_buf.push_int(1);
break;
case ALT_ErrorLog:
text_buf.push_int(2);
break;
case ALT_ExecutorEvent:
text_buf.push_int(3);
break;
case ALT_FunctionEvent:
text_buf.push_int(4);
break;
case ALT_ParallelEvent:
text_buf.push_int(5);
break;
case ALT_TestcaseOp:
text_buf.push_int(6);
break;
case ALT_PortEvent:
text_buf.push_int(7);
break;
case ALT_Statistics:
text_buf.push_int(8);
break;
case ALT_TimerEvent:
text_buf.push_int(9);
break;
case ALT_UserLog:
text_buf.push_int(10);
break;
case ALT_VerdictOp:
text_buf.push_int(11);
break;
case ALT_WarningLog:
text_buf.push_int(12);
break;
case ALT_MatchingEvent:
text_buf.push_int(13);
break;
case ALT_DebugLog:
text_buf.push_int(14);
break;
case ALT_ExecutionSummary:
text_buf.push_int(15);
break;
case ALT_UnhandledEvent:
text_buf.push_int(16);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.LogEventType.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getActionEvent().decode_text(text_buf);
break;
case 1:
getDefaultEvent().decode_text(text_buf);
break;
case 2:
getErrorLog().decode_text(text_buf);
break;
case 3:
getExecutorEvent().decode_text(text_buf);
break;
case 4:
getFunctionEvent().decode_text(text_buf);
break;
case 5:
getParallelEvent().decode_text(text_buf);
break;
case 6:
getTestcaseOp().decode_text(text_buf);
break;
case 7:
getPortEvent().decode_text(text_buf);
break;
case 8:
getStatistics().decode_text(text_buf);
break;
case 9:
getTimerEvent().decode_text(text_buf);
break;
case 10:
getUserLog().decode_text(text_buf);
break;
case 11:
getVerdictOp().decode_text(text_buf);
break;
case 12:
getWarningLog().decode_text(text_buf);
break;
case 13:
getMatchingEvent().decode_text(text_buf);
break;
case 14:
getDebugLog().decode_text(text_buf);
break;
case 15:
getExecutionSummary().decode_text(text_buf);
break;
case 16:
getUnhandledEvent().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.LogEventType.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class LogEventType_choice_template extends Base_Template {
//if single value which value?
private LogEventType_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<LogEventType_choice_template> value_list;

private void copy_value(final LogEventType_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_ActionEvent:
single_value = new Strings_template(other_value.constGetActionEvent());
break;
case ALT_DefaultEvent:
single_value = new DefaultEvent_template(other_value.constGetDefaultEvent());
break;
case ALT_ErrorLog:
single_value = new Categorized_template(other_value.constGetErrorLog());
break;
case ALT_ExecutorEvent:
single_value = new ExecutorEvent_template(other_value.constGetExecutorEvent());
break;
case ALT_FunctionEvent:
single_value = new FunctionEvent_template(other_value.constGetFunctionEvent());
break;
case ALT_ParallelEvent:
single_value = new ParallelEvent_template(other_value.constGetParallelEvent());
break;
case ALT_TestcaseOp:
single_value = new TestcaseEvent_template(other_value.constGetTestcaseOp());
break;
case ALT_PortEvent:
single_value = new PortEvent_template(other_value.constGetPortEvent());
break;
case ALT_Statistics:
single_value = new StatisticsType_template(other_value.constGetStatistics());
break;
case ALT_TimerEvent:
single_value = new TimerEvent_template(other_value.constGetTimerEvent());
break;
case ALT_UserLog:
single_value = new Strings_template(other_value.constGetUserLog());
break;
case ALT_VerdictOp:
single_value = new VerdictOp_template(other_value.constGetVerdictOp());
break;
case ALT_WarningLog:
single_value = new Categorized_template(other_value.constGetWarningLog());
break;
case ALT_MatchingEvent:
single_value = new MatchingEvent_template(other_value.constGetMatchingEvent());
break;
case ALT_DebugLog:
single_value = new Categorized_template(other_value.constGetDebugLog());
break;
case ALT_ExecutionSummary:
single_value = new ExecutionSummaryType_template(other_value.constGetExecutionSummary());
break;
case ALT_UnhandledEvent:
single_value = new TitanCharString_template(other_value.constGetUnhandledEvent());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.LogEventType.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final LogEventType_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_ActionEvent:
single_value = new Strings_template(other_value.constGetActionEvent());
break;
case ALT_DefaultEvent:
single_value = new DefaultEvent_template(other_value.constGetDefaultEvent());
break;
case ALT_ErrorLog:
single_value = new Categorized_template(other_value.constGetErrorLog());
break;
case ALT_ExecutorEvent:
single_value = new ExecutorEvent_template(other_value.constGetExecutorEvent());
break;
case ALT_FunctionEvent:
single_value = new FunctionEvent_template(other_value.constGetFunctionEvent());
break;
case ALT_ParallelEvent:
single_value = new ParallelEvent_template(other_value.constGetParallelEvent());
break;
case ALT_TestcaseOp:
single_value = new TestcaseEvent_template(other_value.constGetTestcaseOp());
break;
case ALT_PortEvent:
single_value = new PortEvent_template(other_value.constGetPortEvent());
break;
case ALT_Statistics:
single_value = new StatisticsType_template(other_value.constGetStatistics());
break;
case ALT_TimerEvent:
single_value = new TimerEvent_template(other_value.constGetTimerEvent());
break;
case ALT_UserLog:
single_value = new Strings_template(other_value.constGetUserLog());
break;
case ALT_VerdictOp:
single_value = new VerdictOp_template(other_value.constGetVerdictOp());
break;
case ALT_WarningLog:
single_value = new Categorized_template(other_value.constGetWarningLog());
break;
case ALT_MatchingEvent:
single_value = new MatchingEvent_template(other_value.constGetMatchingEvent());
break;
case ALT_DebugLog:
single_value = new Categorized_template(other_value.constGetDebugLog());
break;
case ALT_ExecutionSummary:
single_value = new ExecutionSummaryType_template(other_value.constGetExecutionSummary());
break;
case ALT_UnhandledEvent:
single_value = new TitanCharString_template(other_value.constGetUnhandledEvent());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.LogEventType.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<LogEventType_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final LogEventType_choice_template temp = new LogEventType_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.LogEventType.choice.");
}
set_selection(other_value);
}

public LogEventType_choice_template() {
}
public LogEventType_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public LogEventType_choice_template(final LogEventType_choice other_value) {
copy_value(other_value);
}
public LogEventType_choice_template(final LogEventType_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_ActionEvent:
((Strings_template)single_value).cleanUp();
break;
case ALT_DefaultEvent:
((DefaultEvent_template)single_value).cleanUp();
break;
case ALT_ErrorLog:
((Categorized_template)single_value).cleanUp();
break;
case ALT_ExecutorEvent:
((ExecutorEvent_template)single_value).cleanUp();
break;
case ALT_FunctionEvent:
((FunctionEvent_template)single_value).cleanUp();
break;
case ALT_ParallelEvent:
((ParallelEvent_template)single_value).cleanUp();
break;
case ALT_TestcaseOp:
((TestcaseEvent_template)single_value).cleanUp();
break;
case ALT_PortEvent:
((PortEvent_template)single_value).cleanUp();
break;
case ALT_Statistics:
((StatisticsType_template)single_value).cleanUp();
break;
case ALT_TimerEvent:
((TimerEvent_template)single_value).cleanUp();
break;
case ALT_UserLog:
((Strings_template)single_value).cleanUp();
break;
case ALT_VerdictOp:
((VerdictOp_template)single_value).cleanUp();
break;
case ALT_WarningLog:
((Categorized_template)single_value).cleanUp();
break;
case ALT_MatchingEvent:
((MatchingEvent_template)single_value).cleanUp();
break;
case ALT_DebugLog:
((Categorized_template)single_value).cleanUp();
break;
case ALT_ExecutionSummary:
((ExecutionSummaryType_template)single_value).cleanUp();
break;
case ALT_UnhandledEvent:
((TitanCharString_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public LogEventType_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public LogEventType_choice_template assign( final LogEventType_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public LogEventType_choice_template assign( final LogEventType_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public LogEventType_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof LogEventType_choice) {
return assign((LogEventType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to LogEventType_choice.");
}

@Override
public LogEventType_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof LogEventType_choice_template) {
return assign((LogEventType_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to LogEventType_choice_template.");
}

// originally match
public boolean match(final LogEventType_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final LogEventType_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final LogEventType_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == LogEventType_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_ActionEvent:
return ((Strings_template)single_value).match(other_value.getActionEvent(), legacy);
case ALT_DefaultEvent:
return ((DefaultEvent_template)single_value).match(other_value.getDefaultEvent(), legacy);
case ALT_ErrorLog:
return ((Categorized_template)single_value).match(other_value.getErrorLog(), legacy);
case ALT_ExecutorEvent:
return ((ExecutorEvent_template)single_value).match(other_value.getExecutorEvent(), legacy);
case ALT_FunctionEvent:
return ((FunctionEvent_template)single_value).match(other_value.getFunctionEvent(), legacy);
case ALT_ParallelEvent:
return ((ParallelEvent_template)single_value).match(other_value.getParallelEvent(), legacy);
case ALT_TestcaseOp:
return ((TestcaseEvent_template)single_value).match(other_value.getTestcaseOp(), legacy);
case ALT_PortEvent:
return ((PortEvent_template)single_value).match(other_value.getPortEvent(), legacy);
case ALT_Statistics:
return ((StatisticsType_template)single_value).match(other_value.getStatistics(), legacy);
case ALT_TimerEvent:
return ((TimerEvent_template)single_value).match(other_value.getTimerEvent(), legacy);
case ALT_UserLog:
return ((Strings_template)single_value).match(other_value.getUserLog(), legacy);
case ALT_VerdictOp:
return ((VerdictOp_template)single_value).match(other_value.getVerdictOp(), legacy);
case ALT_WarningLog:
return ((Categorized_template)single_value).match(other_value.getWarningLog(), legacy);
case ALT_MatchingEvent:
return ((MatchingEvent_template)single_value).match(other_value.getMatchingEvent(), legacy);
case ALT_DebugLog:
return ((Categorized_template)single_value).match(other_value.getDebugLog(), legacy);
case ALT_ExecutionSummary:
return ((ExecutionSummaryType_template)single_value).match(other_value.getExecutionSummary(), legacy);
case ALT_UnhandledEvent:
return ((TitanCharString_template)single_value).match(other_value.getUnhandledEvent(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.LogEventType.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof LogEventType_choice) {
		return match((LogEventType_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type LogEventType_choice.");
	}
public boolean isChosen(final LogEventType_choice.union_selection_type checked_selection) {
if(checked_selection == LogEventType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.LogEventType.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == LogEventType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.LogEventType.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_ActionEvent:
return ((Strings_template)single_value).isValue();
case ALT_DefaultEvent:
return ((DefaultEvent_template)single_value).isValue();
case ALT_ErrorLog:
return ((Categorized_template)single_value).isValue();
case ALT_ExecutorEvent:
return ((ExecutorEvent_template)single_value).isValue();
case ALT_FunctionEvent:
return ((FunctionEvent_template)single_value).isValue();
case ALT_ParallelEvent:
return ((ParallelEvent_template)single_value).isValue();
case ALT_TestcaseOp:
return ((TestcaseEvent_template)single_value).isValue();
case ALT_PortEvent:
return ((PortEvent_template)single_value).isValue();
case ALT_Statistics:
return ((StatisticsType_template)single_value).isValue();
case ALT_TimerEvent:
return ((TimerEvent_template)single_value).isValue();
case ALT_UserLog:
return ((Strings_template)single_value).isValue();
case ALT_VerdictOp:
return ((VerdictOp_template)single_value).isValue();
case ALT_WarningLog:
return ((Categorized_template)single_value).isValue();
case ALT_MatchingEvent:
return ((MatchingEvent_template)single_value).isValue();
case ALT_DebugLog:
return ((Categorized_template)single_value).isValue();
case ALT_ExecutionSummary:
return ((ExecutionSummaryType_template)single_value).isValue();
case ALT_UnhandledEvent:
return ((TitanCharString_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
}
}

public LogEventType_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
final LogEventType_choice ret_val = new LogEventType_choice();
switch (single_value_union_selection) {
case ALT_ActionEvent:
ret_val.getActionEvent().assign(((Strings_template)single_value).valueOf());
break;
case ALT_DefaultEvent:
ret_val.getDefaultEvent().assign(((DefaultEvent_template)single_value).valueOf());
break;
case ALT_ErrorLog:
ret_val.getErrorLog().assign(((Categorized_template)single_value).valueOf());
break;
case ALT_ExecutorEvent:
ret_val.getExecutorEvent().assign(((ExecutorEvent_template)single_value).valueOf());
break;
case ALT_FunctionEvent:
ret_val.getFunctionEvent().assign(((FunctionEvent_template)single_value).valueOf());
break;
case ALT_ParallelEvent:
ret_val.getParallelEvent().assign(((ParallelEvent_template)single_value).valueOf());
break;
case ALT_TestcaseOp:
ret_val.getTestcaseOp().assign(((TestcaseEvent_template)single_value).valueOf());
break;
case ALT_PortEvent:
ret_val.getPortEvent().assign(((PortEvent_template)single_value).valueOf());
break;
case ALT_Statistics:
ret_val.getStatistics().assign(((StatisticsType_template)single_value).valueOf());
break;
case ALT_TimerEvent:
ret_val.getTimerEvent().assign(((TimerEvent_template)single_value).valueOf());
break;
case ALT_UserLog:
ret_val.getUserLog().assign(((Strings_template)single_value).valueOf());
break;
case ALT_VerdictOp:
ret_val.getVerdictOp().assign(((VerdictOp_template)single_value).valueOf());
break;
case ALT_WarningLog:
ret_val.getWarningLog().assign(((Categorized_template)single_value).valueOf());
break;
case ALT_MatchingEvent:
ret_val.getMatchingEvent().assign(((MatchingEvent_template)single_value).valueOf());
break;
case ALT_DebugLog:
ret_val.getDebugLog().assign(((Categorized_template)single_value).valueOf());
break;
case ALT_ExecutionSummary:
ret_val.getExecutionSummary().assign(((ExecutionSummaryType_template)single_value).valueOf());
break;
case ALT_UnhandledEvent:
ret_val.getUnhandledEvent().assign(((TitanCharString_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.LogEventType.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<LogEventType_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new LogEventType_choice_template());
}
}

public LogEventType_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.LogEventType.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.LogEventType.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public Strings_template getActionEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ActionEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Strings_template(template_sel.ANY_VALUE);
} else {
single_value = new Strings_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_ActionEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Strings_template)single_value;
}

public Strings_template constGetActionEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field actionEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ActionEvent) {
throw new TtcnError("Accessing non-selected field actionEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Strings_template)single_value;
}

public DefaultEvent_template getDefaultEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_DefaultEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new DefaultEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new DefaultEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_DefaultEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (DefaultEvent_template)single_value;
}

public DefaultEvent_template constGetDefaultEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field defaultEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_DefaultEvent) {
throw new TtcnError("Accessing non-selected field defaultEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (DefaultEvent_template)single_value;
}

public Categorized_template getErrorLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ErrorLog) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Categorized_template(template_sel.ANY_VALUE);
} else {
single_value = new Categorized_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_ErrorLog;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Categorized_template)single_value;
}

public Categorized_template constGetErrorLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field errorLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ErrorLog) {
throw new TtcnError("Accessing non-selected field errorLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Categorized_template)single_value;
}

public ExecutorEvent_template getExecutorEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ExecutorEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ExecutorEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new ExecutorEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_ExecutorEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ExecutorEvent_template)single_value;
}

public ExecutorEvent_template constGetExecutorEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field executorEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ExecutorEvent) {
throw new TtcnError("Accessing non-selected field executorEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (ExecutorEvent_template)single_value;
}

public FunctionEvent_template getFunctionEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_FunctionEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new FunctionEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new FunctionEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_FunctionEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (FunctionEvent_template)single_value;
}

public FunctionEvent_template constGetFunctionEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field functionEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_FunctionEvent) {
throw new TtcnError("Accessing non-selected field functionEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (FunctionEvent_template)single_value;
}

public ParallelEvent_template getParallelEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ParallelEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ParallelEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new ParallelEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_ParallelEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ParallelEvent_template)single_value;
}

public ParallelEvent_template constGetParallelEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field parallelEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ParallelEvent) {
throw new TtcnError("Accessing non-selected field parallelEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (ParallelEvent_template)single_value;
}

public TestcaseEvent_template getTestcaseOp() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_TestcaseOp) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TestcaseEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new TestcaseEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_TestcaseOp;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TestcaseEvent_template)single_value;
}

public TestcaseEvent_template constGetTestcaseOp() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field testcaseOp in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_TestcaseOp) {
throw new TtcnError("Accessing non-selected field testcaseOp in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (TestcaseEvent_template)single_value;
}

public PortEvent_template getPortEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_PortEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new PortEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new PortEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_PortEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (PortEvent_template)single_value;
}

public PortEvent_template constGetPortEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field portEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_PortEvent) {
throw new TtcnError("Accessing non-selected field portEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (PortEvent_template)single_value;
}

public StatisticsType_template getStatistics() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_Statistics) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new StatisticsType_template(template_sel.ANY_VALUE);
} else {
single_value = new StatisticsType_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_Statistics;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (StatisticsType_template)single_value;
}

public StatisticsType_template constGetStatistics() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field statistics in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_Statistics) {
throw new TtcnError("Accessing non-selected field statistics in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (StatisticsType_template)single_value;
}

public TimerEvent_template getTimerEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_TimerEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_TimerEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerEvent_template)single_value;
}

public TimerEvent_template constGetTimerEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field timerEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_TimerEvent) {
throw new TtcnError("Accessing non-selected field timerEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (TimerEvent_template)single_value;
}

public Strings_template getUserLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_UserLog) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Strings_template(template_sel.ANY_VALUE);
} else {
single_value = new Strings_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_UserLog;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Strings_template)single_value;
}

public Strings_template constGetUserLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field userLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_UserLog) {
throw new TtcnError("Accessing non-selected field userLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Strings_template)single_value;
}

public VerdictOp_template getVerdictOp() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_VerdictOp) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new VerdictOp_template(template_sel.ANY_VALUE);
} else {
single_value = new VerdictOp_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_VerdictOp;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (VerdictOp_template)single_value;
}

public VerdictOp_template constGetVerdictOp() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field verdictOp in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_VerdictOp) {
throw new TtcnError("Accessing non-selected field verdictOp in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (VerdictOp_template)single_value;
}

public Categorized_template getWarningLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_WarningLog) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Categorized_template(template_sel.ANY_VALUE);
} else {
single_value = new Categorized_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_WarningLog;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Categorized_template)single_value;
}

public Categorized_template constGetWarningLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field warningLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_WarningLog) {
throw new TtcnError("Accessing non-selected field warningLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Categorized_template)single_value;
}

public MatchingEvent_template getMatchingEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_MatchingEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new MatchingEvent_template(template_sel.ANY_VALUE);
} else {
single_value = new MatchingEvent_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_MatchingEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (MatchingEvent_template)single_value;
}

public MatchingEvent_template constGetMatchingEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field matchingEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_MatchingEvent) {
throw new TtcnError("Accessing non-selected field matchingEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (MatchingEvent_template)single_value;
}

public Categorized_template getDebugLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_DebugLog) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Categorized_template(template_sel.ANY_VALUE);
} else {
single_value = new Categorized_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_DebugLog;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Categorized_template)single_value;
}

public Categorized_template constGetDebugLog() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field debugLog in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_DebugLog) {
throw new TtcnError("Accessing non-selected field debugLog in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (Categorized_template)single_value;
}

public ExecutionSummaryType_template getExecutionSummary() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ExecutionSummary) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ExecutionSummaryType_template(template_sel.ANY_VALUE);
} else {
single_value = new ExecutionSummaryType_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_ExecutionSummary;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ExecutionSummaryType_template)single_value;
}

public ExecutionSummaryType_template constGetExecutionSummary() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field executionSummary in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_ExecutionSummary) {
throw new TtcnError("Accessing non-selected field executionSummary in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (ExecutionSummaryType_template)single_value;
}

public TitanCharString_template getUnhandledEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != LogEventType_choice.union_selection_type.ALT_UnhandledEvent) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = LogEventType_choice.union_selection_type.ALT_UnhandledEvent;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetUnhandledEvent() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field unhandledEvent in a non-specific template of union type @TitanLoggerApi.LogEventType.choice.");
}
if (single_value_union_selection != LogEventType_choice.union_selection_type.ALT_UnhandledEvent) {
throw new TtcnError("Accessing non-selected field unhandledEvent in a template of union type @TitanLoggerApi.LogEventType.choice.");
}
return (TitanCharString_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof LogEventType_choice) {
log_match((LogEventType_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.choice.");
}

public void log_match(final LogEventType_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_ActionEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".actionEvent");
single_value.log_match(match_value.getActionEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ actionEvent := ");
single_value.log_match(match_value.getActionEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_DefaultEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".defaultEvent");
single_value.log_match(match_value.getDefaultEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ defaultEvent := ");
single_value.log_match(match_value.getDefaultEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ErrorLog:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".errorLog");
single_value.log_match(match_value.getErrorLog(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ errorLog := ");
single_value.log_match(match_value.getErrorLog(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExecutorEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".executorEvent");
single_value.log_match(match_value.getExecutorEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ executorEvent := ");
single_value.log_match(match_value.getExecutorEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_FunctionEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".functionEvent");
single_value.log_match(match_value.getFunctionEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ functionEvent := ");
single_value.log_match(match_value.getFunctionEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ParallelEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".parallelEvent");
single_value.log_match(match_value.getParallelEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ parallelEvent := ");
single_value.log_match(match_value.getParallelEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_TestcaseOp:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".testcaseOp");
single_value.log_match(match_value.getTestcaseOp(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ testcaseOp := ");
single_value.log_match(match_value.getTestcaseOp(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_PortEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".portEvent");
single_value.log_match(match_value.getPortEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ portEvent := ");
single_value.log_match(match_value.getPortEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_Statistics:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".statistics");
single_value.log_match(match_value.getStatistics(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ statistics := ");
single_value.log_match(match_value.getStatistics(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_TimerEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".timerEvent");
single_value.log_match(match_value.getTimerEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ timerEvent := ");
single_value.log_match(match_value.getTimerEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_UserLog:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".userLog");
single_value.log_match(match_value.getUserLog(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ userLog := ");
single_value.log_match(match_value.getUserLog(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_VerdictOp:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".verdictOp");
single_value.log_match(match_value.getVerdictOp(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ verdictOp := ");
single_value.log_match(match_value.getVerdictOp(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_WarningLog:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".warningLog");
single_value.log_match(match_value.getWarningLog(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ warningLog := ");
single_value.log_match(match_value.getWarningLog(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MatchingEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".matchingEvent");
single_value.log_match(match_value.getMatchingEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ matchingEvent := ");
single_value.log_match(match_value.getMatchingEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_DebugLog:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".debugLog");
single_value.log_match(match_value.getDebugLog(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ debugLog := ");
single_value.log_match(match_value.getDebugLog(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ExecutionSummary:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".executionSummary");
single_value.log_match(match_value.getExecutionSummary(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ executionSummary := ");
single_value.log_match(match_value.getExecutionSummary(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_UnhandledEvent:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".unhandledEvent");
single_value.log_match(match_value.getUnhandledEvent(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ unhandledEvent := ");
single_value.log_match(match_value.getUnhandledEvent(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.LogEventType.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new Strings_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new DefaultEvent_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new Categorized_template();
single_value.decode_text(text_buf);
break;
case 3:
single_value = new ExecutorEvent_template();
single_value.decode_text(text_buf);
break;
case 4:
single_value = new FunctionEvent_template();
single_value.decode_text(text_buf);
break;
case 5:
single_value = new ParallelEvent_template();
single_value.decode_text(text_buf);
break;
case 6:
single_value = new TestcaseEvent_template();
single_value.decode_text(text_buf);
break;
case 7:
single_value = new PortEvent_template();
single_value.decode_text(text_buf);
break;
case 8:
single_value = new StatisticsType_template();
single_value.decode_text(text_buf);
break;
case 9:
single_value = new TimerEvent_template();
single_value.decode_text(text_buf);
break;
case 10:
single_value = new Strings_template();
single_value.decode_text(text_buf);
break;
case 11:
single_value = new VerdictOp_template();
single_value.decode_text(text_buf);
break;
case 12:
single_value = new Categorized_template();
single_value.decode_text(text_buf);
break;
case 13:
single_value = new MatchingEvent_template();
single_value.decode_text(text_buf);
break;
case 14:
single_value = new Categorized_template();
single_value.decode_text(text_buf);
break;
case 15:
single_value = new ExecutionSummaryType_template();
single_value.decode_text(text_buf);
break;
case 16:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<LogEventType_choice_template>(size);
for (int i = 0; i < size; i++) {
final LogEventType_choice_template temp2 = new LogEventType_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.LogEventType.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void LogEventType_choice_encoder(final LogEventType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_decoder( final TitanOctetString input_stream, final LogEventType_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingDoneType_type___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingDoneType_type___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingDoneType_type___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingDoneType_type___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_ptc__verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_ptc__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_ptc__verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_ptc__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class DefaultEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_DefaultopActivate,  ALT_DefaultopDeactivate,  ALT_DefaultopExit };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public DefaultEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public DefaultEvent_choice(final DefaultEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final DefaultEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_DefaultopActivate:
field = new DefaultOp((DefaultOp)otherValue.field);
break;
case ALT_DefaultopDeactivate:
field = new DefaultOp((DefaultOp)otherValue.field);
break;
case ALT_DefaultopExit:
field = new DefaultOp((DefaultOp)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.DefaultEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public DefaultEvent_choice assign( final DefaultEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public DefaultEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof DefaultEvent_choice) {
return assign((DefaultEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_DefaultopActivate:
return field.isValue();
case ALT_DefaultopDeactivate:
return field.isValue();
case ALT_DefaultopExit:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final DefaultEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.DefaultEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.DefaultEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_DefaultopActivate:
return ((DefaultOp)field).operatorEquals((DefaultOp)otherValue.field);
case ALT_DefaultopDeactivate:
return ((DefaultOp)field).operatorEquals((DefaultOp)otherValue.field);
case ALT_DefaultopExit:
return ((DefaultOp)field).operatorEquals((DefaultOp)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof DefaultEvent_choice) {
return operatorEquals((DefaultEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final DefaultEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public DefaultOp getDefaultopActivate() {
if (union_selection != union_selection_type.ALT_DefaultopActivate) {
cleanUp();
field = new DefaultOp();
union_selection = union_selection_type.ALT_DefaultopActivate;
}
return (DefaultOp)field;
}

public DefaultOp constGetDefaultopActivate() {
if (union_selection != union_selection_type.ALT_DefaultopActivate) {
throw new TtcnError("Using non-selected field defaultopActivate in a value of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return (DefaultOp)field;
}

public DefaultOp getDefaultopDeactivate() {
if (union_selection != union_selection_type.ALT_DefaultopDeactivate) {
cleanUp();
field = new DefaultOp();
union_selection = union_selection_type.ALT_DefaultopDeactivate;
}
return (DefaultOp)field;
}

public DefaultOp constGetDefaultopDeactivate() {
if (union_selection != union_selection_type.ALT_DefaultopDeactivate) {
throw new TtcnError("Using non-selected field defaultopDeactivate in a value of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return (DefaultOp)field;
}

public DefaultOp getDefaultopExit() {
if (union_selection != union_selection_type.ALT_DefaultopExit) {
cleanUp();
field = new DefaultOp();
union_selection = union_selection_type.ALT_DefaultopExit;
}
return (DefaultOp)field;
}

public DefaultOp constGetDefaultopExit() {
if (union_selection != union_selection_type.ALT_DefaultopExit) {
throw new TtcnError("Using non-selected field defaultopExit in a value of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return (DefaultOp)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_DefaultopActivate:
TTCN_Logger.log_event_str("{ defaultopActivate := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_DefaultopDeactivate:
TTCN_Logger.log_event_str("{ defaultopDeactivate := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_DefaultopExit:
TTCN_Logger.log_event_str("{ defaultopExit := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_DefaultopActivate:
case ALT_DefaultopDeactivate:
case ALT_DefaultopExit:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_DefaultopActivate:
text_buf.push_int(0);
break;
case ALT_DefaultopDeactivate:
text_buf.push_int(1);
break;
case ALT_DefaultopExit:
text_buf.push_int(2);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.DefaultEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getDefaultopActivate().decode_text(text_buf);
break;
case 1:
getDefaultopDeactivate().decode_text(text_buf);
break;
case 2:
getDefaultopExit().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.DefaultEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class DefaultEvent_choice_template extends Base_Template {
//if single value which value?
private DefaultEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<DefaultEvent_choice_template> value_list;

private void copy_value(final DefaultEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_DefaultopActivate:
single_value = new DefaultOp_template(other_value.constGetDefaultopActivate());
break;
case ALT_DefaultopDeactivate:
single_value = new DefaultOp_template(other_value.constGetDefaultopDeactivate());
break;
case ALT_DefaultopExit:
single_value = new DefaultOp_template(other_value.constGetDefaultopExit());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.DefaultEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final DefaultEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_DefaultopActivate:
single_value = new DefaultOp_template(other_value.constGetDefaultopActivate());
break;
case ALT_DefaultopDeactivate:
single_value = new DefaultOp_template(other_value.constGetDefaultopDeactivate());
break;
case ALT_DefaultopExit:
single_value = new DefaultOp_template(other_value.constGetDefaultopExit());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.DefaultEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<DefaultEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final DefaultEvent_choice_template temp = new DefaultEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
set_selection(other_value);
}

public DefaultEvent_choice_template() {
}
public DefaultEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public DefaultEvent_choice_template(final DefaultEvent_choice other_value) {
copy_value(other_value);
}
public DefaultEvent_choice_template(final DefaultEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_DefaultopActivate:
((DefaultOp_template)single_value).cleanUp();
break;
case ALT_DefaultopDeactivate:
((DefaultOp_template)single_value).cleanUp();
break;
case ALT_DefaultopExit:
((DefaultOp_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public DefaultEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public DefaultEvent_choice_template assign( final DefaultEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public DefaultEvent_choice_template assign( final DefaultEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public DefaultEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof DefaultEvent_choice) {
return assign((DefaultEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to DefaultEvent_choice.");
}

@Override
public DefaultEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof DefaultEvent_choice_template) {
return assign((DefaultEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to DefaultEvent_choice_template.");
}

// originally match
public boolean match(final DefaultEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final DefaultEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final DefaultEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == DefaultEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_DefaultopActivate:
return ((DefaultOp_template)single_value).match(other_value.getDefaultopActivate(), legacy);
case ALT_DefaultopDeactivate:
return ((DefaultOp_template)single_value).match(other_value.getDefaultopDeactivate(), legacy);
case ALT_DefaultopExit:
return ((DefaultOp_template)single_value).match(other_value.getDefaultopExit(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof DefaultEvent_choice) {
		return match((DefaultEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type DefaultEvent_choice.");
	}
public boolean isChosen(final DefaultEvent_choice.union_selection_type checked_selection) {
if(checked_selection == DefaultEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.DefaultEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == DefaultEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.DefaultEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_DefaultopActivate:
return ((DefaultOp_template)single_value).isValue();
case ALT_DefaultopDeactivate:
return ((DefaultOp_template)single_value).isValue();
case ALT_DefaultopExit:
return ((DefaultOp_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
}

public DefaultEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
final DefaultEvent_choice ret_val = new DefaultEvent_choice();
switch (single_value_union_selection) {
case ALT_DefaultopActivate:
ret_val.getDefaultopActivate().assign(((DefaultOp_template)single_value).valueOf());
break;
case ALT_DefaultopDeactivate:
ret_val.getDefaultopDeactivate().assign(((DefaultOp_template)single_value).valueOf());
break;
case ALT_DefaultopExit:
ret_val.getDefaultopExit().assign(((DefaultOp_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<DefaultEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new DefaultEvent_choice_template());
}
}

public DefaultEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public DefaultOp_template getDefaultopActivate() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_DefaultopActivate) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new DefaultOp_template(template_sel.ANY_VALUE);
} else {
single_value = new DefaultOp_template();
}
single_value_union_selection = DefaultEvent_choice.union_selection_type.ALT_DefaultopActivate;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (DefaultOp_template)single_value;
}

public DefaultOp_template constGetDefaultopActivate() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field defaultopActivate in a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
if (single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_DefaultopActivate) {
throw new TtcnError("Accessing non-selected field defaultopActivate in a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return (DefaultOp_template)single_value;
}

public DefaultOp_template getDefaultopDeactivate() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_DefaultopDeactivate) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new DefaultOp_template(template_sel.ANY_VALUE);
} else {
single_value = new DefaultOp_template();
}
single_value_union_selection = DefaultEvent_choice.union_selection_type.ALT_DefaultopDeactivate;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (DefaultOp_template)single_value;
}

public DefaultOp_template constGetDefaultopDeactivate() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field defaultopDeactivate in a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
if (single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_DefaultopDeactivate) {
throw new TtcnError("Accessing non-selected field defaultopDeactivate in a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return (DefaultOp_template)single_value;
}

public DefaultOp_template getDefaultopExit() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_DefaultopExit) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new DefaultOp_template(template_sel.ANY_VALUE);
} else {
single_value = new DefaultOp_template();
}
single_value_union_selection = DefaultEvent_choice.union_selection_type.ALT_DefaultopExit;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (DefaultOp_template)single_value;
}

public DefaultOp_template constGetDefaultopExit() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field defaultopExit in a non-specific template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
if (single_value_union_selection != DefaultEvent_choice.union_selection_type.ALT_DefaultopExit) {
throw new TtcnError("Accessing non-selected field defaultopExit in a template of union type @TitanLoggerApi.DefaultEvent.choice.");
}
return (DefaultOp_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof DefaultEvent_choice) {
log_match((DefaultEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.choice.");
}

public void log_match(final DefaultEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_DefaultopActivate:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".defaultopActivate");
single_value.log_match(match_value.getDefaultopActivate(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ defaultopActivate := ");
single_value.log_match(match_value.getDefaultopActivate(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_DefaultopDeactivate:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".defaultopDeactivate");
single_value.log_match(match_value.getDefaultopDeactivate(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ defaultopDeactivate := ");
single_value.log_match(match_value.getDefaultopDeactivate(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_DefaultopExit:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".defaultopExit");
single_value.log_match(match_value.getDefaultopExit(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ defaultopExit := ");
single_value.log_match(match_value.getDefaultopExit(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.DefaultEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new DefaultOp_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new DefaultOp_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new DefaultOp_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<DefaultEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final DefaultEvent_choice_template temp2 = new DefaultEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.DefaultEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void DefaultEvent_choice_encoder(final DefaultEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultEvent_choice_decoder( final TitanOctetString input_stream, final DefaultEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class TestcaseEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_TestcaseStarted,  ALT_TestcaseFinished };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public TestcaseEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public TestcaseEvent_choice(final TestcaseEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final TestcaseEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_TestcaseStarted:
field = new QualifiedName((QualifiedName)otherValue.field);
break;
case ALT_TestcaseFinished:
field = new TestcaseType((TestcaseType)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.TestcaseEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public TestcaseEvent_choice assign( final TestcaseEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public TestcaseEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof TestcaseEvent_choice) {
return assign((TestcaseEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_TestcaseStarted:
return field.isValue();
case ALT_TestcaseFinished:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final TestcaseEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.TestcaseEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.TestcaseEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_TestcaseStarted:
return ((QualifiedName)field).operatorEquals((QualifiedName)otherValue.field);
case ALT_TestcaseFinished:
return ((TestcaseType)field).operatorEquals((TestcaseType)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof TestcaseEvent_choice) {
return operatorEquals((TestcaseEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final TestcaseEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public QualifiedName getTestcaseStarted() {
if (union_selection != union_selection_type.ALT_TestcaseStarted) {
cleanUp();
field = new QualifiedName();
union_selection = union_selection_type.ALT_TestcaseStarted;
}
return (QualifiedName)field;
}

public QualifiedName constGetTestcaseStarted() {
if (union_selection != union_selection_type.ALT_TestcaseStarted) {
throw new TtcnError("Using non-selected field testcaseStarted in a value of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return (QualifiedName)field;
}

public TestcaseType getTestcaseFinished() {
if (union_selection != union_selection_type.ALT_TestcaseFinished) {
cleanUp();
field = new TestcaseType();
union_selection = union_selection_type.ALT_TestcaseFinished;
}
return (TestcaseType)field;
}

public TestcaseType constGetTestcaseFinished() {
if (union_selection != union_selection_type.ALT_TestcaseFinished) {
throw new TtcnError("Using non-selected field testcaseFinished in a value of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return (TestcaseType)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_TestcaseStarted:
TTCN_Logger.log_event_str("{ testcaseStarted := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_TestcaseFinished:
TTCN_Logger.log_event_str("{ testcaseFinished := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_TestcaseStarted:
case ALT_TestcaseFinished:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_TestcaseStarted:
text_buf.push_int(0);
break;
case ALT_TestcaseFinished:
text_buf.push_int(1);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getTestcaseStarted().decode_text(text_buf);
break;
case 1:
getTestcaseFinished().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.TestcaseEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class TestcaseEvent_choice_template extends Base_Template {
//if single value which value?
private TestcaseEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<TestcaseEvent_choice_template> value_list;

private void copy_value(final TestcaseEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_TestcaseStarted:
single_value = new QualifiedName_template(other_value.constGetTestcaseStarted());
break;
case ALT_TestcaseFinished:
single_value = new TestcaseType_template(other_value.constGetTestcaseFinished());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.TestcaseEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final TestcaseEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_TestcaseStarted:
single_value = new QualifiedName_template(other_value.constGetTestcaseStarted());
break;
case ALT_TestcaseFinished:
single_value = new TestcaseType_template(other_value.constGetTestcaseFinished());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.TestcaseEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<TestcaseEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final TestcaseEvent_choice_template temp = new TestcaseEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
set_selection(other_value);
}

public TestcaseEvent_choice_template() {
}
public TestcaseEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public TestcaseEvent_choice_template(final TestcaseEvent_choice other_value) {
copy_value(other_value);
}
public TestcaseEvent_choice_template(final TestcaseEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_TestcaseStarted:
((QualifiedName_template)single_value).cleanUp();
break;
case ALT_TestcaseFinished:
((TestcaseType_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public TestcaseEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public TestcaseEvent_choice_template assign( final TestcaseEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public TestcaseEvent_choice_template assign( final TestcaseEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public TestcaseEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof TestcaseEvent_choice) {
return assign((TestcaseEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to TestcaseEvent_choice.");
}

@Override
public TestcaseEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof TestcaseEvent_choice_template) {
return assign((TestcaseEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to TestcaseEvent_choice_template.");
}

// originally match
public boolean match(final TestcaseEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final TestcaseEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final TestcaseEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == TestcaseEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_TestcaseStarted:
return ((QualifiedName_template)single_value).match(other_value.getTestcaseStarted(), legacy);
case ALT_TestcaseFinished:
return ((TestcaseType_template)single_value).match(other_value.getTestcaseFinished(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TestcaseEvent_choice) {
		return match((TestcaseEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TestcaseEvent_choice.");
	}
public boolean isChosen(final TestcaseEvent_choice.union_selection_type checked_selection) {
if(checked_selection == TestcaseEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == TestcaseEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_TestcaseStarted:
return ((QualifiedName_template)single_value).isValue();
case ALT_TestcaseFinished:
return ((TestcaseType_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
}

public TestcaseEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
final TestcaseEvent_choice ret_val = new TestcaseEvent_choice();
switch (single_value_union_selection) {
case ALT_TestcaseStarted:
ret_val.getTestcaseStarted().assign(((QualifiedName_template)single_value).valueOf());
break;
case ALT_TestcaseFinished:
ret_val.getTestcaseFinished().assign(((TestcaseType_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<TestcaseEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new TestcaseEvent_choice_template());
}
}

public TestcaseEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public QualifiedName_template getTestcaseStarted() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_TestcaseStarted) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new QualifiedName_template(template_sel.ANY_VALUE);
} else {
single_value = new QualifiedName_template();
}
single_value_union_selection = TestcaseEvent_choice.union_selection_type.ALT_TestcaseStarted;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (QualifiedName_template)single_value;
}

public QualifiedName_template constGetTestcaseStarted() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field testcaseStarted in a non-specific template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
if (single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_TestcaseStarted) {
throw new TtcnError("Accessing non-selected field testcaseStarted in a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return (QualifiedName_template)single_value;
}

public TestcaseType_template getTestcaseFinished() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_TestcaseFinished) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TestcaseType_template(template_sel.ANY_VALUE);
} else {
single_value = new TestcaseType_template();
}
single_value_union_selection = TestcaseEvent_choice.union_selection_type.ALT_TestcaseFinished;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TestcaseType_template)single_value;
}

public TestcaseType_template constGetTestcaseFinished() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field testcaseFinished in a non-specific template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
if (single_value_union_selection != TestcaseEvent_choice.union_selection_type.ALT_TestcaseFinished) {
throw new TtcnError("Accessing non-selected field testcaseFinished in a template of union type @TitanLoggerApi.TestcaseEvent.choice.");
}
return (TestcaseType_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof TestcaseEvent_choice) {
log_match((TestcaseEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.choice.");
}

public void log_match(final TestcaseEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_TestcaseStarted:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".testcaseStarted");
single_value.log_match(match_value.getTestcaseStarted(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ testcaseStarted := ");
single_value.log_match(match_value.getTestcaseStarted(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_TestcaseFinished:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".testcaseFinished");
single_value.log_match(match_value.getTestcaseFinished(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ testcaseFinished := ");
single_value.log_match(match_value.getTestcaseFinished(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.TestcaseEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new QualifiedName_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new TestcaseType_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<TestcaseEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final TestcaseEvent_choice_template temp2 = new TestcaseEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.TestcaseEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void TestcaseEvent_choice_encoder(final TestcaseEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseEvent_choice_decoder( final TitanOctetString input_stream, final TestcaseEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void VerdictOp_choice_finalVerdict_encoder(final FinalVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictOp_choice_finalVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictOp_choice_finalVerdict_decoder( final TitanOctetString input_stream, final FinalVerdictType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictOp_choice_finalVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class MatchingDoneType_reason extends Base_Type {
public enum enum_type {
done__failed__wrong__return__type (0),
done__failed__no__return (1),
any__component__done__successful (2),
any__component__done__failed (3),
all__component__done__successful (4),
any__component__killed__successful (5),
any__component__killed__failed (6),
all__component__killed__successful (7),
UNKNOWN_VALUE(8),
UNBOUND_VALUE(9);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return done__failed__wrong__return__type;
case 1:  return done__failed__no__return;
case 2:  return any__component__done__successful;
case 3:  return any__component__done__failed;
case 4:  return all__component__done__successful;
case 5:  return any__component__killed__successful;
case 6:  return any__component__killed__failed;
case 7:  return all__component__killed__successful;
case 8:  return UNKNOWN_VALUE;
case 9:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public MatchingDoneType_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public MatchingDoneType_reason(final MatchingDoneType_reason otherValue) {
enum_value = otherValue.enum_value;
}

public MatchingDoneType_reason(final MatchingDoneType_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public MatchingDoneType_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingDoneType_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public MatchingDoneType_reason assign(final MatchingDoneType_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public MatchingDoneType_reason assign(final Base_Type otherValue){
if( otherValue instanceof MatchingDoneType_reason ) {
return assign((MatchingDoneType_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public MatchingDoneType_reason assign(final MatchingDoneType_reason.enum_type otherValue){
return assign( new MatchingDoneType_reason(otherValue) );
}

//originally operator=
public MatchingDoneType_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingDoneType_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final MatchingDoneType_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof MatchingDoneType_reason) {
return operatorEquals( (MatchingDoneType_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingDoneType.reason.");
}
}

//originally operator==
public boolean operatorEquals(final MatchingDoneType_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final MatchingDoneType_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final MatchingDoneType_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final MatchingDoneType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final MatchingDoneType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingDoneType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingDoneType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final MatchingDoneType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final MatchingDoneType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingDoneType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingDoneType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingDoneType_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final MatchingDoneType_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final MatchingDoneType_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("done__failed__wrong__return__type".equals(strPar) || "done_failed_wrong_return_type".equals(strPar)) {
return enum_type.done__failed__wrong__return__type;
}
if ("done__failed__no__return".equals(strPar) || "done_failed_no_return".equals(strPar)) {
return enum_type.done__failed__no__return;
}
if ("any__component__done__successful".equals(strPar) || "any_component_done_successful".equals(strPar)) {
return enum_type.any__component__done__successful;
}
if ("any__component__done__failed".equals(strPar) || "any_component_done_failed".equals(strPar)) {
return enum_type.any__component__done__failed;
}
if ("all__component__done__successful".equals(strPar) || "all_component_done_successful".equals(strPar)) {
return enum_type.all__component__done__successful;
}
if ("any__component__killed__successful".equals(strPar) || "any_component_killed_successful".equals(strPar)) {
return enum_type.any__component__killed__successful;
}
if ("any__component__killed__failed".equals(strPar) || "any_component_killed_failed".equals(strPar)) {
return enum_type.any__component__killed__failed;
}
if ("all__component__killed__successful".equals(strPar) || "all_component_killed_successful".equals(strPar)) {
return enum_type.all__component__killed__successful;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingDoneType.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingDoneType.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class MatchingDoneType_reason_template extends Base_Template {
// single_value
private MatchingDoneType_reason.enum_type single_value;
// value_list part
private ArrayList<MatchingDoneType_reason_template> value_list;

private void copy_template(final MatchingDoneType_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<MatchingDoneType_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final MatchingDoneType_reason_template temp = new MatchingDoneType_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingDoneType_reason.");
}
}

public MatchingDoneType_reason_template() {
}

public MatchingDoneType_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public MatchingDoneType_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!MatchingDoneType_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type MatchingDoneType_reason with unknown numeric value "+ otherValue +".");
}
single_value = MatchingDoneType_reason.enum_type.getValue(otherValue);
}

public MatchingDoneType_reason_template(final MatchingDoneType_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == MatchingDoneType_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingDoneType_reason. ");
}
single_value = otherValue.enum_value;
}

public MatchingDoneType_reason_template(final MatchingDoneType_reason_template otherValue) {
copy_template(otherValue);
}

public MatchingDoneType_reason_template(final MatchingDoneType_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != MatchingDoneType_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public MatchingDoneType_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public MatchingDoneType_reason_template assign(final int otherValue) {
if (!MatchingDoneType_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingDoneType_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public MatchingDoneType_reason_template assign(final MatchingDoneType_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public MatchingDoneType_reason_template assign(final MatchingDoneType_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public MatchingDoneType_reason_template assign(final MatchingDoneType_reason otherValue){
if (otherValue.enum_value == MatchingDoneType_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type MatchingDoneType_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public MatchingDoneType_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof MatchingDoneType_reason ) {
return assign((MatchingDoneType_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason' can not be cast to {1}", otherValue));
}

@Override
public MatchingDoneType_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof MatchingDoneType_reason_template ) {
return assign((MatchingDoneType_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final MatchingDoneType_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final MatchingDoneType_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingDoneType_reason.");
}
}

// originally match
public boolean match(final MatchingDoneType_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final MatchingDoneType_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof MatchingDoneType_reason ) {
return match((MatchingDoneType_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType_reason' can not be cast to {1}", otherValue));
}

public MatchingDoneType_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingDoneType_reason.");
}
return new MatchingDoneType_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingDoneType_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<MatchingDoneType_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new MatchingDoneType_reason_template());
}
}

public MatchingDoneType_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingDoneType_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type MatchingDoneType_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type MatchingDoneType_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(MatchingDoneType_reason.enum2str(single_value), MatchingDoneType_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof MatchingDoneType_reason) {
log_match((MatchingDoneType_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingDoneType.reason.");
}
public void log_match(final MatchingDoneType_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingDoneType.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!MatchingDoneType_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingDoneType.reason.", temp));
}
single_value = MatchingDoneType_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<MatchingDoneType_reason_template>(size);
for(int i = 0; i < size; i++) {
final MatchingDoneType_reason_template temp = new MatchingDoneType_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingDoneType.reason.");
}
}
}
public static void MatchingDoneType_reason_encoder(final MatchingDoneType_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingDoneType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingDoneType_reason_decoder( final TitanOctetString input_stream, final MatchingDoneType_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingDoneType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Strings_str__list_0_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Strings_str__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Strings_str__list_0_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Strings_str__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ExecutorConfigdata extends Base_Type {
		private final ExecutorConfigdata_reason reason; //TTCN3_Enumerated_Type
		private final Optional<TitanCharString> param__; //CharString_Type

		public ExecutorConfigdata() {
			reason = new ExecutorConfigdata_reason();
			param__ = new Optional<TitanCharString>(TitanCharString.class);
		}

		public ExecutorConfigdata( final ExecutorConfigdata_reason aReason, final Optional<TitanCharString> aParam__ ) {
			reason = new ExecutorConfigdata_reason( aReason );
			param__ = new Optional<TitanCharString>(TitanCharString.class);
			this.param__.assign( aParam__ );
		}

		public ExecutorConfigdata( final ExecutorConfigdata aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			reason = new ExecutorConfigdata_reason();
			param__ = new Optional<TitanCharString>(TitanCharString.class);
			assign( aOtherValue );
		}
		public ExecutorConfigdata assign(final ExecutorConfigdata aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorConfigdata");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getParam__().isBound() ) {
					this.param__.assign( aOtherValue.getParam__() );
				} else {
					this.param__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorConfigdata assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorConfigdata ) {
				return assign((ExecutorConfigdata) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorConfigdata", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			param__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(param__.get_selection()) || param__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(param__.get_selection()) && !param__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorConfigdata aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.param__.operatorEquals( aOtherValue.param__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorConfigdata ) {
				return operatorEquals((ExecutorConfigdata) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorConfigdata", otherValue));
		}

		public ExecutorConfigdata_reason getReason() {
			return reason;
		}

		public ExecutorConfigdata_reason constGetReason() {
			return reason;
		}

		public Optional<TitanCharString> getParam__() {
			return param__;
		}

		public Optional<TitanCharString> constGetParam__() {
			return param__;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			if (param__.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" param_ := ");
			param__.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (param__.isBound()) {
				param__.set_implicit_omit();
			} else {
				param__.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			param__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			param__.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ExecutorConfigdata_template extends Base_Template {

	private ExecutorConfigdata_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template param__; //CharString_Type
	//originally value_list/list_value
	List<ExecutorConfigdata_template> list_value;

	public ExecutorConfigdata_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public ExecutorConfigdata_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorConfigdata.");
		}
		return reason;
	}

	public TitanCharString_template getParam__() {
		setSpecific();
		return param__;
	}

	public TitanCharString_template constGetParam__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field param_ of a non-specific template of type @TitanLoggerApi.ExecutorConfigdata.");
		}
		return param__;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new ExecutorConfigdata_reason_template();
			param__ = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				param__.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public ExecutorConfigdata_template() {
	}

	public ExecutorConfigdata_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ExecutorConfigdata_template( final ExecutorConfigdata otherValue ) {
		copyValue(otherValue);
	}

	public ExecutorConfigdata_template( final ExecutorConfigdata_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ExecutorConfigdata_template( final Optional<ExecutorConfigdata> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorConfigdata from an unbound optional field.");
		}
	}

	//originally operator=
	public ExecutorConfigdata_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ExecutorConfigdata_template assign( final ExecutorConfigdata other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ExecutorConfigdata_template assign( final ExecutorConfigdata_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ExecutorConfigdata_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorConfigdata) {
				return assign((ExecutorConfigdata) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorConfigdata_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorConfigdata_template) {
				return assign((ExecutorConfigdata_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata' can not be cast to {1}_template", otherValue));
		}

	public ExecutorConfigdata_template assign( final Optional<ExecutorConfigdata> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorConfigdata.");
		}
		return this;
	}

	private void copyValue(final ExecutorConfigdata other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getParam__().isBound()) {
			if (other_value.getParam__().isPresent()) {
				getParam__().assign(other_value.getParam__().get());
			} else {
				getParam__().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getParam__().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ExecutorConfigdata_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParam__().get_selection()) {
				getParam__().cleanUp();
			} else {
				getParam__().assign(other_value.getParam__());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ExecutorConfigdata_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ExecutorConfigdata_template temp = new ExecutorConfigdata_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorConfigdata.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorConfigdata valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			final ExecutorConfigdata ret_val = new ExecutorConfigdata();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			if (param__.isOmit()) {
				ret_val.param__.assign(template_sel.OMIT_VALUE);
			} else if (param__.isBound()) {
				ret_val.param__.assign(param__.valueOf());
			}
			return ret_val;
		}

		public ExecutorConfigdata_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorConfigdata_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorConfigdata_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (param__.isOmit() || param__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!param__.isOmit() && !param__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorConfigdata other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorConfigdata other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getParam__().isBound()) {
					return false;
				}
				if((other_value.getParam__().isPresent() ? !param__.match(other_value.getParam__().get(), legacy) : !param__.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutorConfigdata) {
		return match((ExecutorConfigdata)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorConfigdata.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				if (param__.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorConfigdata containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" param_ := ");
				param__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorConfigdata match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorConfigdata) {
				log_match((ExecutorConfigdata)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorConfigdata.");
		}

		public void log_match(final ExecutorConfigdata match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetParam__().isPresent()) {
							if( !param__.match(match_value.constGetParam__().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".param_");
								param__.log_match(match_value.constGetParam__().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!param__.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".param_ := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								param__.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ param_ := ");
				param__.log_match(match_value.constGetParam__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				param__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorConfigdata_reason_template();
				reason.decode_text(text_buf);
				param__ = new TitanCharString_template();
				param__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorConfigdata_template>(size);
				for(int i = 0; i < size; i++) {
					final ExecutorConfigdata_template temp = new ExecutorConfigdata_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorConfigdata.");
			}
		}
}
public static void ExecutorConfigdata_encoder(final ExecutorConfigdata input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorConfigdata_decoder( final TitanOctetString input_stream, final ExecutorConfigdata output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorConfigdata_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_timeoutTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_timeoutTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_timeoutTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_timeoutTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingSuccessType_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingSuccessType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingSuccessType_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingSuccessType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__State_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__State_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__State_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__State_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void DefaultOp_end_encoder(final DefaultEnd input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultOp_end_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultOp_end_decoder( final TitanOctetString input_stream, final DefaultEnd output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultOp_end_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorRuntime_pid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorRuntime_pid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorRuntime_pid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorRuntime_pid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__discard_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__discard_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__discard_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__discard_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class LocationInfo extends Base_Type {
		private final TitanCharString filename; //CharString_Type
		private final TitanInteger line; //Integer_Type
		private final TitanCharString ent__name; //CharString_Type
		private final LocationInfo_ent__type ent__type; //TTCN3_Enumerated_Type

		public LocationInfo() {
			filename = new TitanCharString();
			line = new TitanInteger();
			ent__name = new TitanCharString();
			ent__type = new LocationInfo_ent__type();
		}

		public LocationInfo( final TitanCharString aFilename, final TitanInteger aLine, final TitanCharString aEnt__name, final LocationInfo_ent__type aEnt__type ) {
			filename = new TitanCharString( aFilename );
			line = new TitanInteger( aLine );
			ent__name = new TitanCharString( aEnt__name );
			ent__type = new LocationInfo_ent__type( aEnt__type );
		}

		public LocationInfo( final LocationInfo aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.LocationInfo.");
			}
			filename = new TitanCharString();
			line = new TitanInteger();
			ent__name = new TitanCharString();
			ent__type = new LocationInfo_ent__type();
			assign( aOtherValue );
		}
		public LocationInfo assign(final LocationInfo aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.LocationInfo");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getFilename().isBound() ) {
					this.filename.assign( aOtherValue.getFilename() );
				} else {
					this.filename.cleanUp();
				}
				if ( aOtherValue.getLine().isBound() ) {
					this.line.assign( aOtherValue.getLine() );
				} else {
					this.line.cleanUp();
				}
				if ( aOtherValue.getEnt__name().isBound() ) {
					this.ent__name.assign( aOtherValue.getEnt__name() );
				} else {
					this.ent__name.cleanUp();
				}
				if ( aOtherValue.getEnt__type().isBound() ) {
					this.ent__type.assign( aOtherValue.getEnt__type() );
				} else {
					this.ent__type.cleanUp();
				}
			}

			return this;
		}

		@Override
		public LocationInfo assign(final Base_Type otherValue) {
			if (otherValue instanceof LocationInfo ) {
				return assign((LocationInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LocationInfo", otherValue));
		}

		public void cleanUp() {
			filename.cleanUp();
			line.cleanUp();
			ent__name.cleanUp();
			ent__type.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( filename.isBound() ) { return true; }
			if ( line.isBound() ) { return true; }
			if ( ent__name.isBound() ) { return true; }
			if ( ent__type.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !filename.isValue() ) { return false; }
			if ( !line.isValue() ) { return false; }
			if ( !ent__name.isValue() ) { return false; }
			if ( !ent__type.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final LocationInfo aOtherValue ) {
			if ( !this.filename.operatorEquals( aOtherValue.filename ) ) { return false; }
			if ( !this.line.operatorEquals( aOtherValue.line ) ) { return false; }
			if ( !this.ent__name.operatorEquals( aOtherValue.ent__name ) ) { return false; }
			if ( !this.ent__type.operatorEquals( aOtherValue.ent__type ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof LocationInfo ) {
				return operatorEquals((LocationInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LocationInfo", otherValue));
		}

		public TitanCharString getFilename() {
			return filename;
		}

		public TitanCharString constGetFilename() {
			return filename;
		}

		public TitanInteger getLine() {
			return line;
		}

		public TitanInteger constGetLine() {
			return line;
		}

		public TitanCharString getEnt__name() {
			return ent__name;
		}

		public TitanCharString constGetEnt__name() {
			return ent__name;
		}

		public LocationInfo_ent__type getEnt__type() {
			return ent__type;
		}

		public LocationInfo_ent__type constGetEnt__type() {
			return ent__type;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" filename := ");
			filename.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" line := ");
			line.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ent_name := ");
			ent__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ent_type := ");
			ent__type.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (filename.isBound()) {
				filename.set_implicit_omit();
			}
			if (line.isBound()) {
				line.set_implicit_omit();
			}
			if (ent__name.isBound()) {
				ent__name.set_implicit_omit();
			}
			if (ent__type.isBound()) {
				ent__type.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			filename.encode_text(text_buf);
			line.encode_text(text_buf);
			ent__name.encode_text(text_buf);
			ent__type.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			filename.decode_text(text_buf);
			line.decode_text(text_buf);
			ent__name.decode_text(text_buf);
			ent__type.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class LocationInfo_template extends Base_Template {

	private TitanCharString_template filename; //CharString_Type
	private TitanInteger_template line; //Integer_Type
	private TitanCharString_template ent__name; //CharString_Type
	private LocationInfo_ent__type_template ent__type; //TTCN3_Enumerated_Type
	//originally value_list/list_value
	List<LocationInfo_template> list_value;

	public TitanCharString_template getFilename() {
		setSpecific();
		return filename;
	}

	public TitanCharString_template constGetFilename() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field filename of a non-specific template of type @TitanLoggerApi.LocationInfo.");
		}
		return filename;
	}

	public TitanInteger_template getLine() {
		setSpecific();
		return line;
	}

	public TitanInteger_template constGetLine() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field line of a non-specific template of type @TitanLoggerApi.LocationInfo.");
		}
		return line;
	}

	public TitanCharString_template getEnt__name() {
		setSpecific();
		return ent__name;
	}

	public TitanCharString_template constGetEnt__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ent_name of a non-specific template of type @TitanLoggerApi.LocationInfo.");
		}
		return ent__name;
	}

	public LocationInfo_ent__type_template getEnt__type() {
		setSpecific();
		return ent__type;
	}

	public LocationInfo_ent__type_template constGetEnt__type() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ent_type of a non-specific template of type @TitanLoggerApi.LocationInfo.");
		}
		return ent__type;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			filename = new TitanCharString_template();
			line = new TitanInteger_template();
			ent__name = new TitanCharString_template();
			ent__type = new LocationInfo_ent__type_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				filename.assign(template_sel.ANY_VALUE);
				line.assign(template_sel.ANY_VALUE);
				ent__name.assign(template_sel.ANY_VALUE);
				ent__type.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public LocationInfo_template() {
	}

	public LocationInfo_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public LocationInfo_template( final LocationInfo otherValue ) {
		copyValue(otherValue);
	}

	public LocationInfo_template( final LocationInfo_template otherValue ) {
		copyTemplate( otherValue );
	}

	public LocationInfo_template( final Optional<LocationInfo> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.LocationInfo from an unbound optional field.");
		}
	}

	//originally operator=
	public LocationInfo_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public LocationInfo_template assign( final LocationInfo other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public LocationInfo_template assign( final LocationInfo_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public LocationInfo_template assign(final Base_Type otherValue) {
			if (otherValue instanceof LocationInfo) {
				return assign((LocationInfo) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo' can not be cast to {1}", otherValue));
		}

		@Override
		public LocationInfo_template assign(final Base_Template otherValue) {
			if (otherValue instanceof LocationInfo_template) {
				return assign((LocationInfo_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo' can not be cast to {1}_template", otherValue));
		}

	public LocationInfo_template assign( final Optional<LocationInfo> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.LocationInfo.");
		}
		return this;
	}

	private void copyValue(final LocationInfo other_value) {
		if (other_value.getFilename().isBound()) {
			getFilename().assign(other_value.getFilename());
		} else {
			getFilename().cleanUp();
		}
		if (other_value.getLine().isBound()) {
			getLine().assign(other_value.getLine());
		} else {
			getLine().cleanUp();
		}
		if (other_value.getEnt__name().isBound()) {
			getEnt__name().assign(other_value.getEnt__name());
		} else {
			getEnt__name().cleanUp();
		}
		if (other_value.getEnt__type().isBound()) {
			getEnt__type().assign(other_value.getEnt__type());
		} else {
			getEnt__type().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final LocationInfo_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFilename().get_selection()) {
				getFilename().cleanUp();
			} else {
				getFilename().assign(other_value.getFilename());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getLine().get_selection()) {
				getLine().cleanUp();
			} else {
				getLine().assign(other_value.getLine());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEnt__name().get_selection()) {
				getEnt__name().cleanUp();
			} else {
				getEnt__name().assign(other_value.getEnt__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEnt__type().get_selection()) {
				getEnt__type().cleanUp();
			} else {
				getEnt__type().assign(other_value.getEnt__type());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<LocationInfo_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final LocationInfo_template temp = new LocationInfo_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.LocationInfo.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public LocationInfo valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.LocationInfo.");
			}
			final LocationInfo ret_val = new LocationInfo();
			 if (filename.isBound()) {
				ret_val.filename.assign(filename.valueOf());
			}
			 if (line.isBound()) {
				ret_val.line.assign(line.valueOf());
			}
			 if (ent__name.isBound()) {
				ret_val.ent__name.assign(ent__name.valueOf());
			}
			 if (ent__type.isBound()) {
				ret_val.ent__type.assign(ent__type.valueOf());
			}
			return ret_val;
		}

		public LocationInfo_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.LocationInfo.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.LocationInfo.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.LocationInfo.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<LocationInfo_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new LocationInfo_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (filename.isBound()) {
				return true;
			}
			if (line.isBound()) {
				return true;
			}
			if (ent__name.isBound()) {
				return true;
			}
			if (ent__type.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!filename.isValue()) {
				return false;
			}
			if (!line.isValue()) {
				return false;
			}
			if (!ent__name.isValue()) {
				return false;
			}
			if (!ent__type.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final LocationInfo other_value) {
			return match(other_value, false);
		}

		public boolean match(final LocationInfo other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getFilename().isBound()) {
					return false;
				}
				if(!filename.match(other_value.getFilename(), legacy)) {
					return false;
				}
				if(!other_value.getLine().isBound()) {
					return false;
				}
				if(!line.match(other_value.getLine(), legacy)) {
					return false;
				}
				if(!other_value.getEnt__name().isBound()) {
					return false;
				}
				if(!ent__name.match(other_value.getEnt__name(), legacy)) {
					return false;
				}
				if(!other_value.getEnt__type().isBound()) {
					return false;
				}
				if(!ent__type.match(other_value.getEnt__type(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.LocationInfo.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof LocationInfo) {
		return match((LocationInfo)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type LocationInfo.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LocationInfo containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.LocationInfo.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" filename := ");
				filename.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" line := ");
				line.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ent_name := ");
				ent__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ent_type := ");
				ent__type.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final LocationInfo match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof LocationInfo) {
				log_match((LocationInfo)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LocationInfo.");
		}

		public void log_match(final LocationInfo match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !filename.match(match_value.constGetFilename(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".filename");
							filename.log_match(match_value.constGetFilename(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !line.match(match_value.constGetLine(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".line");
							line.log_match(match_value.constGetLine(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ent__name.match(match_value.constGetEnt__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ent_name");
							ent__name.log_match(match_value.constGetEnt__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ent__type.match(match_value.constGetEnt__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ent_type");
							ent__type.log_match(match_value.constGetEnt__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ filename := ");
				filename.log_match(match_value.constGetFilename(), legacy);
				TTCN_Logger.log_event_str("{ line := ");
				line.log_match(match_value.constGetLine(), legacy);
				TTCN_Logger.log_event_str("{ ent_name := ");
				ent__name.log_match(match_value.constGetEnt__name(), legacy);
				TTCN_Logger.log_event_str("{ ent_type := ");
				ent__type.log_match(match_value.constGetEnt__type(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				filename.encode_text(text_buf);
				line.encode_text(text_buf);
				ent__name.encode_text(text_buf);
				ent__type.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.LocationInfo.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				filename = new TitanCharString_template();
				filename.decode_text(text_buf);
				line = new TitanInteger_template();
				line.decode_text(text_buf);
				ent__name = new TitanCharString_template();
				ent__name.decode_text(text_buf);
				ent__type = new LocationInfo_ent__type_template();
				ent__type.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<LocationInfo_template>(size);
				for(int i = 0; i < size; i++) {
					final LocationInfo_template temp = new LocationInfo_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.LocationInfo.");
			}
		}
}
public static void LocationInfo_encoder(final LocationInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LocationInfo_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LocationInfo_decoder( final TitanOctetString input_stream, final LocationInfo output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LocationInfo_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TestcaseEvent extends Base_Type {
		private final TestcaseEvent_choice choice; //TTCN3_Choice_Type

		public TestcaseEvent() {
			choice = new TestcaseEvent_choice();
		}

		public TestcaseEvent( final TestcaseEvent_choice aChoice ) {
			choice = new TestcaseEvent_choice( aChoice );
		}

		public TestcaseEvent( final TestcaseEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TestcaseEvent.");
			}
			choice = new TestcaseEvent_choice();
			assign( aOtherValue );
		}
		public TestcaseEvent assign(final TestcaseEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TestcaseEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TestcaseEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseEvent ) {
				return assign((TestcaseEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TestcaseEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseEvent ) {
				return operatorEquals((TestcaseEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseEvent", otherValue));
		}

		public TestcaseEvent_choice getChoice() {
			return choice;
		}

		public TestcaseEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TestcaseEvent_template extends Base_Template {

	private TestcaseEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<TestcaseEvent_template> list_value;

	public TestcaseEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public TestcaseEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.TestcaseEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new TestcaseEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TestcaseEvent_template() {
	}

	public TestcaseEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TestcaseEvent_template( final TestcaseEvent otherValue ) {
		copyValue(otherValue);
	}

	public TestcaseEvent_template( final TestcaseEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TestcaseEvent_template( final Optional<TestcaseEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TestcaseEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public TestcaseEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TestcaseEvent_template assign( final TestcaseEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TestcaseEvent_template assign( final TestcaseEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TestcaseEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseEvent) {
				return assign((TestcaseEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TestcaseEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TestcaseEvent_template) {
				return assign((TestcaseEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseEvent' can not be cast to {1}_template", otherValue));
		}

	public TestcaseEvent_template assign( final Optional<TestcaseEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TestcaseEvent.");
		}
		return this;
	}

	private void copyValue(final TestcaseEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TestcaseEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TestcaseEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TestcaseEvent_template temp = new TestcaseEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TestcaseEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TestcaseEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TestcaseEvent.");
			}
			final TestcaseEvent ret_val = new TestcaseEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public TestcaseEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TestcaseEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TestcaseEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TestcaseEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TestcaseEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TestcaseEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TestcaseEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TestcaseEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TestcaseEvent) {
		return match((TestcaseEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TestcaseEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TestcaseEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TestcaseEvent) {
				log_match((TestcaseEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseEvent.");
		}

		public void log_match(final TestcaseEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new TestcaseEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TestcaseEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final TestcaseEvent_template temp = new TestcaseEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TestcaseEvent.");
			}
		}
}
public static void TestcaseEvent_encoder(final TestcaseEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseEvent_decoder( final TitanOctetString input_stream, final TestcaseEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class TimerEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_ReadTimer,  ALT_StartTimer,  ALT_GuardTimer,  ALT_StopTimer,  ALT_TimeoutTimer,  ALT_TimeoutAnyTimer,  ALT_UnqualifiedTimer };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public TimerEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public TimerEvent_choice(final TimerEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final TimerEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_ReadTimer:
field = new TimerType((TimerType)otherValue.field);
break;
case ALT_StartTimer:
field = new TimerType((TimerType)otherValue.field);
break;
case ALT_GuardTimer:
field = new TimerGuardType((TimerGuardType)otherValue.field);
break;
case ALT_StopTimer:
field = new TimerType((TimerType)otherValue.field);
break;
case ALT_TimeoutTimer:
field = new TimerType((TimerType)otherValue.field);
break;
case ALT_TimeoutAnyTimer:
field = new TimerAnyTimeoutType((TimerAnyTimeoutType)otherValue.field);
break;
case ALT_UnqualifiedTimer:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.TimerEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public TimerEvent_choice assign( final TimerEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public TimerEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof TimerEvent_choice) {
return assign((TimerEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TimerEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_ReadTimer:
return field.isValue();
case ALT_StartTimer:
return field.isValue();
case ALT_GuardTimer:
return field.isValue();
case ALT_StopTimer:
return field.isValue();
case ALT_TimeoutTimer:
return field.isValue();
case ALT_TimeoutAnyTimer:
return field.isValue();
case ALT_UnqualifiedTimer:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final TimerEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.TimerEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.TimerEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_ReadTimer:
return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
case ALT_StartTimer:
return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
case ALT_GuardTimer:
return ((TimerGuardType)field).operatorEquals((TimerGuardType)otherValue.field);
case ALT_StopTimer:
return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
case ALT_TimeoutTimer:
return ((TimerType)field).operatorEquals((TimerType)otherValue.field);
case ALT_TimeoutAnyTimer:
return ((TimerAnyTimeoutType)field).operatorEquals((TimerAnyTimeoutType)otherValue.field);
case ALT_UnqualifiedTimer:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof TimerEvent_choice) {
return operatorEquals((TimerEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final TimerEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public TimerType getReadTimer() {
if (union_selection != union_selection_type.ALT_ReadTimer) {
cleanUp();
field = new TimerType();
union_selection = union_selection_type.ALT_ReadTimer;
}
return (TimerType)field;
}

public TimerType constGetReadTimer() {
if (union_selection != union_selection_type.ALT_ReadTimer) {
throw new TtcnError("Using non-selected field readTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType)field;
}

public TimerType getStartTimer() {
if (union_selection != union_selection_type.ALT_StartTimer) {
cleanUp();
field = new TimerType();
union_selection = union_selection_type.ALT_StartTimer;
}
return (TimerType)field;
}

public TimerType constGetStartTimer() {
if (union_selection != union_selection_type.ALT_StartTimer) {
throw new TtcnError("Using non-selected field startTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType)field;
}

public TimerGuardType getGuardTimer() {
if (union_selection != union_selection_type.ALT_GuardTimer) {
cleanUp();
field = new TimerGuardType();
union_selection = union_selection_type.ALT_GuardTimer;
}
return (TimerGuardType)field;
}

public TimerGuardType constGetGuardTimer() {
if (union_selection != union_selection_type.ALT_GuardTimer) {
throw new TtcnError("Using non-selected field guardTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerGuardType)field;
}

public TimerType getStopTimer() {
if (union_selection != union_selection_type.ALT_StopTimer) {
cleanUp();
field = new TimerType();
union_selection = union_selection_type.ALT_StopTimer;
}
return (TimerType)field;
}

public TimerType constGetStopTimer() {
if (union_selection != union_selection_type.ALT_StopTimer) {
throw new TtcnError("Using non-selected field stopTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType)field;
}

public TimerType getTimeoutTimer() {
if (union_selection != union_selection_type.ALT_TimeoutTimer) {
cleanUp();
field = new TimerType();
union_selection = union_selection_type.ALT_TimeoutTimer;
}
return (TimerType)field;
}

public TimerType constGetTimeoutTimer() {
if (union_selection != union_selection_type.ALT_TimeoutTimer) {
throw new TtcnError("Using non-selected field timeoutTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType)field;
}

public TimerAnyTimeoutType getTimeoutAnyTimer() {
if (union_selection != union_selection_type.ALT_TimeoutAnyTimer) {
cleanUp();
field = new TimerAnyTimeoutType();
union_selection = union_selection_type.ALT_TimeoutAnyTimer;
}
return (TimerAnyTimeoutType)field;
}

public TimerAnyTimeoutType constGetTimeoutAnyTimer() {
if (union_selection != union_selection_type.ALT_TimeoutAnyTimer) {
throw new TtcnError("Using non-selected field timeoutAnyTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerAnyTimeoutType)field;
}

public TitanCharString getUnqualifiedTimer() {
if (union_selection != union_selection_type.ALT_UnqualifiedTimer) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_UnqualifiedTimer;
}
return (TitanCharString)field;
}

public TitanCharString constGetUnqualifiedTimer() {
if (union_selection != union_selection_type.ALT_UnqualifiedTimer) {
throw new TtcnError("Using non-selected field unqualifiedTimer in a value of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TitanCharString)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_ReadTimer:
TTCN_Logger.log_event_str("{ readTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_StartTimer:
TTCN_Logger.log_event_str("{ startTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_GuardTimer:
TTCN_Logger.log_event_str("{ guardTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_StopTimer:
TTCN_Logger.log_event_str("{ stopTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_TimeoutTimer:
TTCN_Logger.log_event_str("{ timeoutTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_TimeoutAnyTimer:
TTCN_Logger.log_event_str("{ timeoutAnyTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_UnqualifiedTimer:
TTCN_Logger.log_event_str("{ unqualifiedTimer := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_ReadTimer:
case ALT_StartTimer:
case ALT_GuardTimer:
case ALT_StopTimer:
case ALT_TimeoutTimer:
case ALT_TimeoutAnyTimer:
case ALT_UnqualifiedTimer:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_ReadTimer:
text_buf.push_int(0);
break;
case ALT_StartTimer:
text_buf.push_int(1);
break;
case ALT_GuardTimer:
text_buf.push_int(2);
break;
case ALT_StopTimer:
text_buf.push_int(3);
break;
case ALT_TimeoutTimer:
text_buf.push_int(4);
break;
case ALT_TimeoutAnyTimer:
text_buf.push_int(5);
break;
case ALT_UnqualifiedTimer:
text_buf.push_int(6);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.TimerEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getReadTimer().decode_text(text_buf);
break;
case 1:
getStartTimer().decode_text(text_buf);
break;
case 2:
getGuardTimer().decode_text(text_buf);
break;
case 3:
getStopTimer().decode_text(text_buf);
break;
case 4:
getTimeoutTimer().decode_text(text_buf);
break;
case 5:
getTimeoutAnyTimer().decode_text(text_buf);
break;
case 6:
getUnqualifiedTimer().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.TimerEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class TimerEvent_choice_template extends Base_Template {
//if single value which value?
private TimerEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<TimerEvent_choice_template> value_list;

private void copy_value(final TimerEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_ReadTimer:
single_value = new TimerType_template(other_value.constGetReadTimer());
break;
case ALT_StartTimer:
single_value = new TimerType_template(other_value.constGetStartTimer());
break;
case ALT_GuardTimer:
single_value = new TimerGuardType_template(other_value.constGetGuardTimer());
break;
case ALT_StopTimer:
single_value = new TimerType_template(other_value.constGetStopTimer());
break;
case ALT_TimeoutTimer:
single_value = new TimerType_template(other_value.constGetTimeoutTimer());
break;
case ALT_TimeoutAnyTimer:
single_value = new TimerAnyTimeoutType_template(other_value.constGetTimeoutAnyTimer());
break;
case ALT_UnqualifiedTimer:
single_value = new TitanCharString_template(other_value.constGetUnqualifiedTimer());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.TimerEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final TimerEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_ReadTimer:
single_value = new TimerType_template(other_value.constGetReadTimer());
break;
case ALT_StartTimer:
single_value = new TimerType_template(other_value.constGetStartTimer());
break;
case ALT_GuardTimer:
single_value = new TimerGuardType_template(other_value.constGetGuardTimer());
break;
case ALT_StopTimer:
single_value = new TimerType_template(other_value.constGetStopTimer());
break;
case ALT_TimeoutTimer:
single_value = new TimerType_template(other_value.constGetTimeoutTimer());
break;
case ALT_TimeoutAnyTimer:
single_value = new TimerAnyTimeoutType_template(other_value.constGetTimeoutAnyTimer());
break;
case ALT_UnqualifiedTimer:
single_value = new TitanCharString_template(other_value.constGetUnqualifiedTimer());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.TimerEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<TimerEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final TimerEvent_choice_template temp = new TimerEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.TimerEvent.choice.");
}
set_selection(other_value);
}

public TimerEvent_choice_template() {
}
public TimerEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public TimerEvent_choice_template(final TimerEvent_choice other_value) {
copy_value(other_value);
}
public TimerEvent_choice_template(final TimerEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_ReadTimer:
((TimerType_template)single_value).cleanUp();
break;
case ALT_StartTimer:
((TimerType_template)single_value).cleanUp();
break;
case ALT_GuardTimer:
((TimerGuardType_template)single_value).cleanUp();
break;
case ALT_StopTimer:
((TimerType_template)single_value).cleanUp();
break;
case ALT_TimeoutTimer:
((TimerType_template)single_value).cleanUp();
break;
case ALT_TimeoutAnyTimer:
((TimerAnyTimeoutType_template)single_value).cleanUp();
break;
case ALT_UnqualifiedTimer:
((TitanCharString_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public TimerEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public TimerEvent_choice_template assign( final TimerEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public TimerEvent_choice_template assign( final TimerEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public TimerEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof TimerEvent_choice) {
return assign((TimerEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to TimerEvent_choice.");
}

@Override
public TimerEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof TimerEvent_choice_template) {
return assign((TimerEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to TimerEvent_choice_template.");
}

// originally match
public boolean match(final TimerEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final TimerEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final TimerEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == TimerEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_ReadTimer:
return ((TimerType_template)single_value).match(other_value.getReadTimer(), legacy);
case ALT_StartTimer:
return ((TimerType_template)single_value).match(other_value.getStartTimer(), legacy);
case ALT_GuardTimer:
return ((TimerGuardType_template)single_value).match(other_value.getGuardTimer(), legacy);
case ALT_StopTimer:
return ((TimerType_template)single_value).match(other_value.getStopTimer(), legacy);
case ALT_TimeoutTimer:
return ((TimerType_template)single_value).match(other_value.getTimeoutTimer(), legacy);
case ALT_TimeoutAnyTimer:
return ((TimerAnyTimeoutType_template)single_value).match(other_value.getTimeoutAnyTimer(), legacy);
case ALT_UnqualifiedTimer:
return ((TitanCharString_template)single_value).match(other_value.getUnqualifiedTimer(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TimerEvent_choice) {
		return match((TimerEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerEvent_choice.");
	}
public boolean isChosen(final TimerEvent_choice.union_selection_type checked_selection) {
if(checked_selection == TimerEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.TimerEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == TimerEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.TimerEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_ReadTimer:
return ((TimerType_template)single_value).isValue();
case ALT_StartTimer:
return ((TimerType_template)single_value).isValue();
case ALT_GuardTimer:
return ((TimerGuardType_template)single_value).isValue();
case ALT_StopTimer:
return ((TimerType_template)single_value).isValue();
case ALT_TimeoutTimer:
return ((TimerType_template)single_value).isValue();
case ALT_TimeoutAnyTimer:
return ((TimerAnyTimeoutType_template)single_value).isValue();
case ALT_UnqualifiedTimer:
return ((TitanCharString_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
}

public TimerEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
final TimerEvent_choice ret_val = new TimerEvent_choice();
switch (single_value_union_selection) {
case ALT_ReadTimer:
ret_val.getReadTimer().assign(((TimerType_template)single_value).valueOf());
break;
case ALT_StartTimer:
ret_val.getStartTimer().assign(((TimerType_template)single_value).valueOf());
break;
case ALT_GuardTimer:
ret_val.getGuardTimer().assign(((TimerGuardType_template)single_value).valueOf());
break;
case ALT_StopTimer:
ret_val.getStopTimer().assign(((TimerType_template)single_value).valueOf());
break;
case ALT_TimeoutTimer:
ret_val.getTimeoutTimer().assign(((TimerType_template)single_value).valueOf());
break;
case ALT_TimeoutAnyTimer:
ret_val.getTimeoutAnyTimer().assign(((TimerAnyTimeoutType_template)single_value).valueOf());
break;
case ALT_UnqualifiedTimer:
ret_val.getUnqualifiedTimer().assign(((TitanCharString_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<TimerEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new TimerEvent_choice_template());
}
}

public TimerEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public TimerType_template getReadTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_ReadTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerType_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerType_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_ReadTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerType_template)single_value;
}

public TimerType_template constGetReadTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field readTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_ReadTimer) {
throw new TtcnError("Accessing non-selected field readTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType_template)single_value;
}

public TimerType_template getStartTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_StartTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerType_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerType_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_StartTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerType_template)single_value;
}

public TimerType_template constGetStartTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field startTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_StartTimer) {
throw new TtcnError("Accessing non-selected field startTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType_template)single_value;
}

public TimerGuardType_template getGuardTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_GuardTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerGuardType_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerGuardType_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_GuardTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerGuardType_template)single_value;
}

public TimerGuardType_template constGetGuardTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field guardTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_GuardTimer) {
throw new TtcnError("Accessing non-selected field guardTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerGuardType_template)single_value;
}

public TimerType_template getStopTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_StopTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerType_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerType_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_StopTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerType_template)single_value;
}

public TimerType_template constGetStopTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field stopTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_StopTimer) {
throw new TtcnError("Accessing non-selected field stopTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType_template)single_value;
}

public TimerType_template getTimeoutTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_TimeoutTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerType_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerType_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_TimeoutTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerType_template)single_value;
}

public TimerType_template constGetTimeoutTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field timeoutTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_TimeoutTimer) {
throw new TtcnError("Accessing non-selected field timeoutTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerType_template)single_value;
}

public TimerAnyTimeoutType_template getTimeoutAnyTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_TimeoutAnyTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TimerAnyTimeoutType_template(template_sel.ANY_VALUE);
} else {
single_value = new TimerAnyTimeoutType_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_TimeoutAnyTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TimerAnyTimeoutType_template)single_value;
}

public TimerAnyTimeoutType_template constGetTimeoutAnyTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field timeoutAnyTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_TimeoutAnyTimer) {
throw new TtcnError("Accessing non-selected field timeoutAnyTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TimerAnyTimeoutType_template)single_value;
}

public TitanCharString_template getUnqualifiedTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_UnqualifiedTimer) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = TimerEvent_choice.union_selection_type.ALT_UnqualifiedTimer;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetUnqualifiedTimer() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field unqualifiedTimer in a non-specific template of union type @TitanLoggerApi.TimerEvent.choice.");
}
if (single_value_union_selection != TimerEvent_choice.union_selection_type.ALT_UnqualifiedTimer) {
throw new TtcnError("Accessing non-selected field unqualifiedTimer in a template of union type @TitanLoggerApi.TimerEvent.choice.");
}
return (TitanCharString_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof TimerEvent_choice) {
log_match((TimerEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerEvent.choice.");
}

public void log_match(final TimerEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_ReadTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".readTimer");
single_value.log_match(match_value.getReadTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ readTimer := ");
single_value.log_match(match_value.getReadTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_StartTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".startTimer");
single_value.log_match(match_value.getStartTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ startTimer := ");
single_value.log_match(match_value.getStartTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_GuardTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".guardTimer");
single_value.log_match(match_value.getGuardTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ guardTimer := ");
single_value.log_match(match_value.getGuardTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_StopTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".stopTimer");
single_value.log_match(match_value.getStopTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ stopTimer := ");
single_value.log_match(match_value.getStopTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_TimeoutTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".timeoutTimer");
single_value.log_match(match_value.getTimeoutTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ timeoutTimer := ");
single_value.log_match(match_value.getTimeoutTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_TimeoutAnyTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".timeoutAnyTimer");
single_value.log_match(match_value.getTimeoutAnyTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ timeoutAnyTimer := ");
single_value.log_match(match_value.getTimeoutAnyTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_UnqualifiedTimer:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".unqualifiedTimer");
single_value.log_match(match_value.getUnqualifiedTimer(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ unqualifiedTimer := ");
single_value.log_match(match_value.getUnqualifiedTimer(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.TimerEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new TimerType_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new TimerType_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new TimerGuardType_template();
single_value.decode_text(text_buf);
break;
case 3:
single_value = new TimerType_template();
single_value.decode_text(text_buf);
break;
case 4:
single_value = new TimerType_template();
single_value.decode_text(text_buf);
break;
case 5:
single_value = new TimerAnyTimeoutType_template();
single_value.decode_text(text_buf);
break;
case 6:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<TimerEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final TimerEvent_choice_template temp2 = new TimerEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.TimerEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void TimerEvent_choice_encoder(final TimerEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_decoder( final TitanOctetString input_stream, final TimerEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class StatisticsType_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_VerdictStatistics,  ALT_ControlpartStart,  ALT_ControlpartFinish,  ALT_ControlpartErrors };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public StatisticsType_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public StatisticsType_choice(final StatisticsType_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final StatisticsType_choice otherValue) {
switch (otherValue.union_selection){
case ALT_VerdictStatistics:
field = new StatisticsType_choice_verdictStatistics((StatisticsType_choice_verdictStatistics)otherValue.field);
break;
case ALT_ControlpartStart:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_ControlpartFinish:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_ControlpartErrors:
field = new TitanInteger((TitanInteger)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.StatisticsType.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public StatisticsType_choice assign( final StatisticsType_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public StatisticsType_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof StatisticsType_choice) {
return assign((StatisticsType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.StatisticsType.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_VerdictStatistics:
return field.isValue();
case ALT_ControlpartStart:
return field.isValue();
case ALT_ControlpartFinish:
return field.isValue();
case ALT_ControlpartErrors:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final StatisticsType_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.StatisticsType.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.StatisticsType.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_VerdictStatistics:
return ((StatisticsType_choice_verdictStatistics)field).operatorEquals((StatisticsType_choice_verdictStatistics)otherValue.field);
case ALT_ControlpartStart:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_ControlpartFinish:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_ControlpartErrors:
return ((TitanInteger)field).operatorEquals((TitanInteger)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof StatisticsType_choice) {
return operatorEquals((StatisticsType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final StatisticsType_choice otherValue ) {
return !operatorEquals(otherValue);
}

public StatisticsType_choice_verdictStatistics getVerdictStatistics() {
if (union_selection != union_selection_type.ALT_VerdictStatistics) {
cleanUp();
field = new StatisticsType_choice_verdictStatistics();
union_selection = union_selection_type.ALT_VerdictStatistics;
}
return (StatisticsType_choice_verdictStatistics)field;
}

public StatisticsType_choice_verdictStatistics constGetVerdictStatistics() {
if (union_selection != union_selection_type.ALT_VerdictStatistics) {
throw new TtcnError("Using non-selected field verdictStatistics in a value of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (StatisticsType_choice_verdictStatistics)field;
}

public TitanCharString getControlpartStart() {
if (union_selection != union_selection_type.ALT_ControlpartStart) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_ControlpartStart;
}
return (TitanCharString)field;
}

public TitanCharString constGetControlpartStart() {
if (union_selection != union_selection_type.ALT_ControlpartStart) {
throw new TtcnError("Using non-selected field controlpartStart in a value of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (TitanCharString)field;
}

public TitanCharString getControlpartFinish() {
if (union_selection != union_selection_type.ALT_ControlpartFinish) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_ControlpartFinish;
}
return (TitanCharString)field;
}

public TitanCharString constGetControlpartFinish() {
if (union_selection != union_selection_type.ALT_ControlpartFinish) {
throw new TtcnError("Using non-selected field controlpartFinish in a value of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (TitanCharString)field;
}

public TitanInteger getControlpartErrors() {
if (union_selection != union_selection_type.ALT_ControlpartErrors) {
cleanUp();
field = new TitanInteger();
union_selection = union_selection_type.ALT_ControlpartErrors;
}
return (TitanInteger)field;
}

public TitanInteger constGetControlpartErrors() {
if (union_selection != union_selection_type.ALT_ControlpartErrors) {
throw new TtcnError("Using non-selected field controlpartErrors in a value of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (TitanInteger)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_VerdictStatistics:
TTCN_Logger.log_event_str("{ verdictStatistics := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ControlpartStart:
TTCN_Logger.log_event_str("{ controlpartStart := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ControlpartFinish:
TTCN_Logger.log_event_str("{ controlpartFinish := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ControlpartErrors:
TTCN_Logger.log_event_str("{ controlpartErrors := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_VerdictStatistics:
case ALT_ControlpartStart:
case ALT_ControlpartFinish:
case ALT_ControlpartErrors:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_VerdictStatistics:
text_buf.push_int(0);
break;
case ALT_ControlpartStart:
text_buf.push_int(1);
break;
case ALT_ControlpartFinish:
text_buf.push_int(2);
break;
case ALT_ControlpartErrors:
text_buf.push_int(3);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.StatisticsType.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getVerdictStatistics().decode_text(text_buf);
break;
case 1:
getControlpartStart().decode_text(text_buf);
break;
case 2:
getControlpartFinish().decode_text(text_buf);
break;
case 3:
getControlpartErrors().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.StatisticsType.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class StatisticsType_choice_template extends Base_Template {
//if single value which value?
private StatisticsType_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<StatisticsType_choice_template> value_list;

private void copy_value(final StatisticsType_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_VerdictStatistics:
single_value = new StatisticsType_choice_verdictStatistics_template(other_value.constGetVerdictStatistics());
break;
case ALT_ControlpartStart:
single_value = new TitanCharString_template(other_value.constGetControlpartStart());
break;
case ALT_ControlpartFinish:
single_value = new TitanCharString_template(other_value.constGetControlpartFinish());
break;
case ALT_ControlpartErrors:
single_value = new TitanInteger_template(other_value.constGetControlpartErrors());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.StatisticsType.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final StatisticsType_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_VerdictStatistics:
single_value = new StatisticsType_choice_verdictStatistics_template(other_value.constGetVerdictStatistics());
break;
case ALT_ControlpartStart:
single_value = new TitanCharString_template(other_value.constGetControlpartStart());
break;
case ALT_ControlpartFinish:
single_value = new TitanCharString_template(other_value.constGetControlpartFinish());
break;
case ALT_ControlpartErrors:
single_value = new TitanInteger_template(other_value.constGetControlpartErrors());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.StatisticsType.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<StatisticsType_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final StatisticsType_choice_template temp = new StatisticsType_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.StatisticsType.choice.");
}
set_selection(other_value);
}

public StatisticsType_choice_template() {
}
public StatisticsType_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public StatisticsType_choice_template(final StatisticsType_choice other_value) {
copy_value(other_value);
}
public StatisticsType_choice_template(final StatisticsType_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_VerdictStatistics:
((StatisticsType_choice_verdictStatistics_template)single_value).cleanUp();
break;
case ALT_ControlpartStart:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_ControlpartFinish:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_ControlpartErrors:
((TitanInteger_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public StatisticsType_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public StatisticsType_choice_template assign( final StatisticsType_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public StatisticsType_choice_template assign( final StatisticsType_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public StatisticsType_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof StatisticsType_choice) {
return assign((StatisticsType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to StatisticsType_choice.");
}

@Override
public StatisticsType_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof StatisticsType_choice_template) {
return assign((StatisticsType_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to StatisticsType_choice_template.");
}

// originally match
public boolean match(final StatisticsType_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final StatisticsType_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final StatisticsType_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == StatisticsType_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_VerdictStatistics:
return ((StatisticsType_choice_verdictStatistics_template)single_value).match(other_value.getVerdictStatistics(), legacy);
case ALT_ControlpartStart:
return ((TitanCharString_template)single_value).match(other_value.getControlpartStart(), legacy);
case ALT_ControlpartFinish:
return ((TitanCharString_template)single_value).match(other_value.getControlpartFinish(), legacy);
case ALT_ControlpartErrors:
return ((TitanInteger_template)single_value).match(other_value.getControlpartErrors(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof StatisticsType_choice) {
		return match((StatisticsType_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StatisticsType_choice.");
	}
public boolean isChosen(final StatisticsType_choice.union_selection_type checked_selection) {
if(checked_selection == StatisticsType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.StatisticsType.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == StatisticsType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.StatisticsType.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_VerdictStatistics:
return ((StatisticsType_choice_verdictStatistics_template)single_value).isValue();
case ALT_ControlpartStart:
return ((TitanCharString_template)single_value).isValue();
case ALT_ControlpartFinish:
return ((TitanCharString_template)single_value).isValue();
case ALT_ControlpartErrors:
return ((TitanInteger_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
}

public StatisticsType_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
}
final StatisticsType_choice ret_val = new StatisticsType_choice();
switch (single_value_union_selection) {
case ALT_VerdictStatistics:
ret_val.getVerdictStatistics().assign(((StatisticsType_choice_verdictStatistics_template)single_value).valueOf());
break;
case ALT_ControlpartStart:
ret_val.getControlpartStart().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_ControlpartFinish:
ret_val.getControlpartFinish().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_ControlpartErrors:
ret_val.getControlpartErrors().assign(((TitanInteger_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<StatisticsType_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new StatisticsType_choice_template());
}
}

public StatisticsType_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.StatisticsType.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.StatisticsType.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public StatisticsType_choice_verdictStatistics_template getVerdictStatistics() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_VerdictStatistics) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new StatisticsType_choice_verdictStatistics_template(template_sel.ANY_VALUE);
} else {
single_value = new StatisticsType_choice_verdictStatistics_template();
}
single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_VerdictStatistics;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (StatisticsType_choice_verdictStatistics_template)single_value;
}

public StatisticsType_choice_verdictStatistics_template constGetVerdictStatistics() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field verdictStatistics in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
}
if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_VerdictStatistics) {
throw new TtcnError("Accessing non-selected field verdictStatistics in a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (StatisticsType_choice_verdictStatistics_template)single_value;
}

public TitanCharString_template getControlpartStart() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_ControlpartStart) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_ControlpartStart;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetControlpartStart() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field controlpartStart in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
}
if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_ControlpartStart) {
throw new TtcnError("Accessing non-selected field controlpartStart in a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template getControlpartFinish() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_ControlpartFinish) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_ControlpartFinish;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetControlpartFinish() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field controlpartFinish in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
}
if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_ControlpartFinish) {
throw new TtcnError("Accessing non-selected field controlpartFinish in a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (TitanCharString_template)single_value;
}

public TitanInteger_template getControlpartErrors() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_ControlpartErrors) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanInteger_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanInteger_template();
}
single_value_union_selection = StatisticsType_choice.union_selection_type.ALT_ControlpartErrors;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanInteger_template)single_value;
}

public TitanInteger_template constGetControlpartErrors() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field controlpartErrors in a non-specific template of union type @TitanLoggerApi.StatisticsType.choice.");
}
if (single_value_union_selection != StatisticsType_choice.union_selection_type.ALT_ControlpartErrors) {
throw new TtcnError("Accessing non-selected field controlpartErrors in a template of union type @TitanLoggerApi.StatisticsType.choice.");
}
return (TitanInteger_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof StatisticsType_choice) {
log_match((StatisticsType_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.");
}

public void log_match(final StatisticsType_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_VerdictStatistics:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".verdictStatistics");
single_value.log_match(match_value.getVerdictStatistics(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ verdictStatistics := ");
single_value.log_match(match_value.getVerdictStatistics(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ControlpartStart:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".controlpartStart");
single_value.log_match(match_value.getControlpartStart(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ controlpartStart := ");
single_value.log_match(match_value.getControlpartStart(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ControlpartFinish:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".controlpartFinish");
single_value.log_match(match_value.getControlpartFinish(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ controlpartFinish := ");
single_value.log_match(match_value.getControlpartFinish(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ControlpartErrors:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".controlpartErrors");
single_value.log_match(match_value.getControlpartErrors(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ controlpartErrors := ");
single_value.log_match(match_value.getControlpartErrors(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.StatisticsType.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new StatisticsType_choice_verdictStatistics_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 3:
single_value = new TitanInteger_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<StatisticsType_choice_template>(size);
for (int i = 0; i < size; i++) {
final StatisticsType_choice_template temp2 = new StatisticsType_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.StatisticsType.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void StatisticsType_choice_encoder(final StatisticsType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_decoder( final TitanOctetString input_stream, final StatisticsType_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimestampType_microSeconds_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimestampType_microSeconds_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimestampType_microSeconds_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimestampType_microSeconds_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Port__Misc extends Base_Type {
		private final Port__Misc_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanInteger remote__component; //Integer_Type
		private final TitanCharString remote__port; //CharString_Type
		private final TitanCharString ip__address; //CharString_Type
		private final TitanInteger tcp__port; //Integer_Type
		private final TitanInteger new__size; //Integer_Type

		public Port__Misc() {
			reason = new Port__Misc_reason();
			port__name = new TitanCharString();
			remote__component = new TitanInteger();
			remote__port = new TitanCharString();
			ip__address = new TitanCharString();
			tcp__port = new TitanInteger();
			new__size = new TitanInteger();
		}

		public Port__Misc( final Port__Misc_reason aReason, final TitanCharString aPort__name, final TitanInteger aRemote__component, final TitanCharString aRemote__port, final TitanCharString aIp__address, final TitanInteger aTcp__port, final TitanInteger aNew__size ) {
			reason = new Port__Misc_reason( aReason );
			port__name = new TitanCharString( aPort__name );
			remote__component = new TitanInteger( aRemote__component );
			remote__port = new TitanCharString( aRemote__port );
			ip__address = new TitanCharString( aIp__address );
			tcp__port = new TitanInteger( aTcp__port );
			new__size = new TitanInteger( aNew__size );
		}

		public Port__Misc( final Port__Misc aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Port_Misc.");
			}
			reason = new Port__Misc_reason();
			port__name = new TitanCharString();
			remote__component = new TitanInteger();
			remote__port = new TitanCharString();
			ip__address = new TitanCharString();
			tcp__port = new TitanInteger();
			new__size = new TitanInteger();
			assign( aOtherValue );
		}
		public Port__Misc assign(final Port__Misc aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Port_Misc");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getRemote__component().isBound() ) {
					this.remote__component.assign( aOtherValue.getRemote__component() );
				} else {
					this.remote__component.cleanUp();
				}
				if ( aOtherValue.getRemote__port().isBound() ) {
					this.remote__port.assign( aOtherValue.getRemote__port() );
				} else {
					this.remote__port.cleanUp();
				}
				if ( aOtherValue.getIp__address().isBound() ) {
					this.ip__address.assign( aOtherValue.getIp__address() );
				} else {
					this.ip__address.cleanUp();
				}
				if ( aOtherValue.getTcp__port().isBound() ) {
					this.tcp__port.assign( aOtherValue.getTcp__port() );
				} else {
					this.tcp__port.cleanUp();
				}
				if ( aOtherValue.getNew__size().isBound() ) {
					this.new__size.assign( aOtherValue.getNew__size() );
				} else {
					this.new__size.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Port__Misc assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Misc ) {
				return assign((Port__Misc) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Misc", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			port__name.cleanUp();
			remote__component.cleanUp();
			remote__port.cleanUp();
			ip__address.cleanUp();
			tcp__port.cleanUp();
			new__size.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( remote__component.isBound() ) { return true; }
			if ( remote__port.isBound() ) { return true; }
			if ( ip__address.isBound() ) { return true; }
			if ( tcp__port.isBound() ) { return true; }
			if ( new__size.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !remote__component.isValue() ) { return false; }
			if ( !remote__port.isValue() ) { return false; }
			if ( !ip__address.isValue() ) { return false; }
			if ( !tcp__port.isValue() ) { return false; }
			if ( !new__size.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Port__Misc aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.remote__component.operatorEquals( aOtherValue.remote__component ) ) { return false; }
			if ( !this.remote__port.operatorEquals( aOtherValue.remote__port ) ) { return false; }
			if ( !this.ip__address.operatorEquals( aOtherValue.ip__address ) ) { return false; }
			if ( !this.tcp__port.operatorEquals( aOtherValue.tcp__port ) ) { return false; }
			if ( !this.new__size.operatorEquals( aOtherValue.new__size ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Port__Misc ) {
				return operatorEquals((Port__Misc) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Misc", otherValue));
		}

		public Port__Misc_reason getReason() {
			return reason;
		}

		public Port__Misc_reason constGetReason() {
			return reason;
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanInteger getRemote__component() {
			return remote__component;
		}

		public TitanInteger constGetRemote__component() {
			return remote__component;
		}

		public TitanCharString getRemote__port() {
			return remote__port;
		}

		public TitanCharString constGetRemote__port() {
			return remote__port;
		}

		public TitanCharString getIp__address() {
			return ip__address;
		}

		public TitanCharString constGetIp__address() {
			return ip__address;
		}

		public TitanInteger getTcp__port() {
			return tcp__port;
		}

		public TitanInteger constGetTcp__port() {
			return tcp__port;
		}

		public TitanInteger getNew__size() {
			return new__size;
		}

		public TitanInteger constGetNew__size() {
			return new__size;
		}

		public TitanInteger sizeOf() {
			int sizeof = 7;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remote_component := ");
			remote__component.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" remote_port := ");
			remote__port.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ip_address := ");
			ip__address.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" tcp_port := ");
			tcp__port.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" new_size := ");
			new__size.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (remote__component.isBound()) {
				remote__component.set_implicit_omit();
			}
			if (remote__port.isBound()) {
				remote__port.set_implicit_omit();
			}
			if (ip__address.isBound()) {
				ip__address.set_implicit_omit();
			}
			if (tcp__port.isBound()) {
				tcp__port.set_implicit_omit();
			}
			if (new__size.isBound()) {
				new__size.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			port__name.encode_text(text_buf);
			remote__component.encode_text(text_buf);
			remote__port.encode_text(text_buf);
			ip__address.encode_text(text_buf);
			tcp__port.encode_text(text_buf);
			new__size.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			port__name.decode_text(text_buf);
			remote__component.decode_text(text_buf);
			remote__port.decode_text(text_buf);
			ip__address.decode_text(text_buf);
			tcp__port.decode_text(text_buf);
			new__size.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Port__Misc_template extends Base_Template {

	private Port__Misc_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template port__name; //CharString_Type
	private TitanInteger_template remote__component; //Integer_Type
	private TitanCharString_template remote__port; //CharString_Type
	private TitanCharString_template ip__address; //CharString_Type
	private TitanInteger_template tcp__port; //Integer_Type
	private TitanInteger_template new__size; //Integer_Type
	//originally value_list/list_value
	List<Port__Misc_template> list_value;

	public Port__Misc_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public Port__Misc_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return reason;
	}

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return port__name;
	}

	public TitanInteger_template getRemote__component() {
		setSpecific();
		return remote__component;
	}

	public TitanInteger_template constGetRemote__component() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field remote_component of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return remote__component;
	}

	public TitanCharString_template getRemote__port() {
		setSpecific();
		return remote__port;
	}

	public TitanCharString_template constGetRemote__port() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field remote_port of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return remote__port;
	}

	public TitanCharString_template getIp__address() {
		setSpecific();
		return ip__address;
	}

	public TitanCharString_template constGetIp__address() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ip_address of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return ip__address;
	}

	public TitanInteger_template getTcp__port() {
		setSpecific();
		return tcp__port;
	}

	public TitanInteger_template constGetTcp__port() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field tcp_port of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return tcp__port;
	}

	public TitanInteger_template getNew__size() {
		setSpecific();
		return new__size;
	}

	public TitanInteger_template constGetNew__size() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field new_size of a non-specific template of type @TitanLoggerApi.Port_Misc.");
		}
		return new__size;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new Port__Misc_reason_template();
			port__name = new TitanCharString_template();
			remote__component = new TitanInteger_template();
			remote__port = new TitanCharString_template();
			ip__address = new TitanCharString_template();
			tcp__port = new TitanInteger_template();
			new__size = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				port__name.assign(template_sel.ANY_VALUE);
				remote__component.assign(template_sel.ANY_VALUE);
				remote__port.assign(template_sel.ANY_VALUE);
				ip__address.assign(template_sel.ANY_VALUE);
				tcp__port.assign(template_sel.ANY_VALUE);
				new__size.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Port__Misc_template() {
	}

	public Port__Misc_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Port__Misc_template( final Port__Misc otherValue ) {
		copyValue(otherValue);
	}

	public Port__Misc_template( final Port__Misc_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Port__Misc_template( final Optional<Port__Misc> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Port_Misc from an unbound optional field.");
		}
	}

	//originally operator=
	public Port__Misc_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Port__Misc_template assign( final Port__Misc other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Port__Misc_template assign( final Port__Misc_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Port__Misc_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Misc) {
				return assign((Port__Misc) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__Misc_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Port__Misc_template) {
				return assign((Port__Misc_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc' can not be cast to {1}_template", otherValue));
		}

	public Port__Misc_template assign( final Optional<Port__Misc> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Port_Misc.");
		}
		return this;
	}

	private void copyValue(final Port__Misc other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getRemote__component().isBound()) {
			getRemote__component().assign(other_value.getRemote__component());
		} else {
			getRemote__component().cleanUp();
		}
		if (other_value.getRemote__port().isBound()) {
			getRemote__port().assign(other_value.getRemote__port());
		} else {
			getRemote__port().cleanUp();
		}
		if (other_value.getIp__address().isBound()) {
			getIp__address().assign(other_value.getIp__address());
		} else {
			getIp__address().cleanUp();
		}
		if (other_value.getTcp__port().isBound()) {
			getTcp__port().assign(other_value.getTcp__port());
		} else {
			getTcp__port().cleanUp();
		}
		if (other_value.getNew__size().isBound()) {
			getNew__size().assign(other_value.getNew__size());
		} else {
			getNew__size().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Port__Misc_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getRemote__component().get_selection()) {
				getRemote__component().cleanUp();
			} else {
				getRemote__component().assign(other_value.getRemote__component());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getRemote__port().get_selection()) {
				getRemote__port().cleanUp();
			} else {
				getRemote__port().assign(other_value.getRemote__port());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getIp__address().get_selection()) {
				getIp__address().cleanUp();
			} else {
				getIp__address().assign(other_value.getIp__address());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTcp__port().get_selection()) {
				getTcp__port().cleanUp();
			} else {
				getTcp__port().assign(other_value.getTcp__port());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNew__size().get_selection()) {
				getNew__size().cleanUp();
			} else {
				getNew__size().assign(other_value.getNew__size());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Port__Misc_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Port__Misc_template temp = new Port__Misc_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Port_Misc.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Port__Misc valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Port_Misc.");
			}
			final Port__Misc ret_val = new Port__Misc();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (remote__component.isBound()) {
				ret_val.remote__component.assign(remote__component.valueOf());
			}
			 if (remote__port.isBound()) {
				ret_val.remote__port.assign(remote__port.valueOf());
			}
			 if (ip__address.isBound()) {
				ret_val.ip__address.assign(ip__address.valueOf());
			}
			 if (tcp__port.isBound()) {
				ret_val.tcp__port.assign(tcp__port.valueOf());
			}
			 if (new__size.isBound()) {
				ret_val.new__size.assign(new__size.valueOf());
			}
			return ret_val;
		}

		public Port__Misc_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Port_Misc.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Port_Misc.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Port_Misc.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Port__Misc_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Port__Misc_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (remote__component.isBound()) {
				return true;
			}
			if (remote__port.isBound()) {
				return true;
			}
			if (ip__address.isBound()) {
				return true;
			}
			if (tcp__port.isBound()) {
				return true;
			}
			if (new__size.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!remote__component.isValue()) {
				return false;
			}
			if (!remote__port.isValue()) {
				return false;
			}
			if (!ip__address.isValue()) {
				return false;
			}
			if (!tcp__port.isValue()) {
				return false;
			}
			if (!new__size.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Port__Misc other_value) {
			return match(other_value, false);
		}

		public boolean match(final Port__Misc other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getRemote__component().isBound()) {
					return false;
				}
				if(!remote__component.match(other_value.getRemote__component(), legacy)) {
					return false;
				}
				if(!other_value.getRemote__port().isBound()) {
					return false;
				}
				if(!remote__port.match(other_value.getRemote__port(), legacy)) {
					return false;
				}
				if(!other_value.getIp__address().isBound()) {
					return false;
				}
				if(!ip__address.match(other_value.getIp__address(), legacy)) {
					return false;
				}
				if(!other_value.getTcp__port().isBound()) {
					return false;
				}
				if(!tcp__port.match(other_value.getTcp__port(), legacy)) {
					return false;
				}
				if(!other_value.getNew__size().isBound()) {
					return false;
				}
				if(!new__size.match(other_value.getNew__size(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Port_Misc.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Port__Misc) {
		return match((Port__Misc)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Port__Misc.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 7;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Misc containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Port_Misc.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remote_component := ");
				remote__component.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" remote_port := ");
				remote__port.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ip_address := ");
				ip__address.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" tcp_port := ");
				tcp__port.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" new_size := ");
				new__size.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Port__Misc match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__Misc) {
				log_match((Port__Misc)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Misc.");
		}

		public void log_match(final Port__Misc match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remote__component.match(match_value.constGetRemote__component(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remote_component");
							remote__component.log_match(match_value.constGetRemote__component(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !remote__port.match(match_value.constGetRemote__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".remote_port");
							remote__port.log_match(match_value.constGetRemote__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ip__address.match(match_value.constGetIp__address(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ip_address");
							ip__address.log_match(match_value.constGetIp__address(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !tcp__port.match(match_value.constGetTcp__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".tcp_port");
							tcp__port.log_match(match_value.constGetTcp__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !new__size.match(match_value.constGetNew__size(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".new_size");
							new__size.log_match(match_value.constGetNew__size(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ remote_component := ");
				remote__component.log_match(match_value.constGetRemote__component(), legacy);
				TTCN_Logger.log_event_str("{ remote_port := ");
				remote__port.log_match(match_value.constGetRemote__port(), legacy);
				TTCN_Logger.log_event_str("{ ip_address := ");
				ip__address.log_match(match_value.constGetIp__address(), legacy);
				TTCN_Logger.log_event_str("{ tcp_port := ");
				tcp__port.log_match(match_value.constGetTcp__port(), legacy);
				TTCN_Logger.log_event_str("{ new_size := ");
				new__size.log_match(match_value.constGetNew__size(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				port__name.encode_text(text_buf);
				remote__component.encode_text(text_buf);
				remote__port.encode_text(text_buf);
				ip__address.encode_text(text_buf);
				tcp__port.encode_text(text_buf);
				new__size.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Port_Misc.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new Port__Misc_reason_template();
				reason.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				remote__component = new TitanInteger_template();
				remote__component.decode_text(text_buf);
				remote__port = new TitanCharString_template();
				remote__port.decode_text(text_buf);
				ip__address = new TitanCharString_template();
				ip__address.decode_text(text_buf);
				tcp__port = new TitanInteger_template();
				tcp__port.decode_text(text_buf);
				new__size = new TitanInteger_template();
				new__size.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Port__Misc_template>(size);
				for(int i = 0; i < size; i++) {
					final Port__Misc_template temp = new Port__Misc_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Port_Misc.");
			}
		}
}
public static void Port__Misc_encoder(final Port__Misc input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_decoder( final TitanOctetString input_stream, final Port__Misc output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Misc_ip__address_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_ip__address_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_ip__address_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_ip__address_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ParallelPTC extends Base_Type {
		private final ParallelPTC_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString module__; //CharString_Type
		private final TitanCharString name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString compname; //CharString_Type
		private final TitanCharString tc__loc; //CharString_Type
		private final TitanInteger alive__pid; //Integer_Type
		private final TitanInteger status; //Integer_Type

		public ParallelPTC() {
			reason = new ParallelPTC_reason();
			module__ = new TitanCharString();
			name = new TitanCharString();
			compref = new TitanInteger();
			compname = new TitanCharString();
			tc__loc = new TitanCharString();
			alive__pid = new TitanInteger();
			status = new TitanInteger();
		}

		public ParallelPTC( final ParallelPTC_reason aReason, final TitanCharString aModule__, final TitanCharString aName, final TitanInteger aCompref, final TitanCharString aCompname, final TitanCharString aTc__loc, final TitanInteger aAlive__pid, final TitanInteger aStatus ) {
			reason = new ParallelPTC_reason( aReason );
			module__ = new TitanCharString( aModule__ );
			name = new TitanCharString( aName );
			compref = new TitanInteger( aCompref );
			compname = new TitanCharString( aCompname );
			tc__loc = new TitanCharString( aTc__loc );
			alive__pid = new TitanInteger( aAlive__pid );
			status = new TitanInteger( aStatus );
		}

		public ParallelPTC( final ParallelPTC aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ParallelPTC.");
			}
			reason = new ParallelPTC_reason();
			module__ = new TitanCharString();
			name = new TitanCharString();
			compref = new TitanInteger();
			compname = new TitanCharString();
			tc__loc = new TitanCharString();
			alive__pid = new TitanInteger();
			status = new TitanInteger();
			assign( aOtherValue );
		}
		public ParallelPTC assign(final ParallelPTC aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ParallelPTC");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getModule__().isBound() ) {
					this.module__.assign( aOtherValue.getModule__() );
				} else {
					this.module__.cleanUp();
				}
				if ( aOtherValue.getName().isBound() ) {
					this.name.assign( aOtherValue.getName() );
				} else {
					this.name.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getCompname().isBound() ) {
					this.compname.assign( aOtherValue.getCompname() );
				} else {
					this.compname.cleanUp();
				}
				if ( aOtherValue.getTc__loc().isBound() ) {
					this.tc__loc.assign( aOtherValue.getTc__loc() );
				} else {
					this.tc__loc.cleanUp();
				}
				if ( aOtherValue.getAlive__pid().isBound() ) {
					this.alive__pid.assign( aOtherValue.getAlive__pid() );
				} else {
					this.alive__pid.cleanUp();
				}
				if ( aOtherValue.getStatus().isBound() ) {
					this.status.assign( aOtherValue.getStatus() );
				} else {
					this.status.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ParallelPTC assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelPTC ) {
				return assign((ParallelPTC) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelPTC", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			module__.cleanUp();
			name.cleanUp();
			compref.cleanUp();
			compname.cleanUp();
			tc__loc.cleanUp();
			alive__pid.cleanUp();
			status.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( module__.isBound() ) { return true; }
			if ( name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( compname.isBound() ) { return true; }
			if ( tc__loc.isBound() ) { return true; }
			if ( alive__pid.isBound() ) { return true; }
			if ( status.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !module__.isValue() ) { return false; }
			if ( !name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !compname.isValue() ) { return false; }
			if ( !tc__loc.isValue() ) { return false; }
			if ( !alive__pid.isValue() ) { return false; }
			if ( !status.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ParallelPTC aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.module__.operatorEquals( aOtherValue.module__ ) ) { return false; }
			if ( !this.name.operatorEquals( aOtherValue.name ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.compname.operatorEquals( aOtherValue.compname ) ) { return false; }
			if ( !this.tc__loc.operatorEquals( aOtherValue.tc__loc ) ) { return false; }
			if ( !this.alive__pid.operatorEquals( aOtherValue.alive__pid ) ) { return false; }
			if ( !this.status.operatorEquals( aOtherValue.status ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ParallelPTC ) {
				return operatorEquals((ParallelPTC) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelPTC", otherValue));
		}

		public ParallelPTC_reason getReason() {
			return reason;
		}

		public ParallelPTC_reason constGetReason() {
			return reason;
		}

		public TitanCharString getModule__() {
			return module__;
		}

		public TitanCharString constGetModule__() {
			return module__;
		}

		public TitanCharString getName() {
			return name;
		}

		public TitanCharString constGetName() {
			return name;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanCharString getCompname() {
			return compname;
		}

		public TitanCharString constGetCompname() {
			return compname;
		}

		public TitanCharString getTc__loc() {
			return tc__loc;
		}

		public TitanCharString constGetTc__loc() {
			return tc__loc;
		}

		public TitanInteger getAlive__pid() {
			return alive__pid;
		}

		public TitanInteger constGetAlive__pid() {
			return alive__pid;
		}

		public TitanInteger getStatus() {
			return status;
		}

		public TitanInteger constGetStatus() {
			return status;
		}

		public TitanInteger sizeOf() {
			int sizeof = 8;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" module_ := ");
			module__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compname := ");
			compname.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" tc_loc := ");
			tc__loc.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" alive_pid := ");
			alive__pid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" status := ");
			status.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (module__.isBound()) {
				module__.set_implicit_omit();
			}
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (compname.isBound()) {
				compname.set_implicit_omit();
			}
			if (tc__loc.isBound()) {
				tc__loc.set_implicit_omit();
			}
			if (alive__pid.isBound()) {
				alive__pid.set_implicit_omit();
			}
			if (status.isBound()) {
				status.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			module__.encode_text(text_buf);
			name.encode_text(text_buf);
			compref.encode_text(text_buf);
			compname.encode_text(text_buf);
			tc__loc.encode_text(text_buf);
			alive__pid.encode_text(text_buf);
			status.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			module__.decode_text(text_buf);
			name.decode_text(text_buf);
			compref.decode_text(text_buf);
			compname.decode_text(text_buf);
			tc__loc.decode_text(text_buf);
			alive__pid.decode_text(text_buf);
			status.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ParallelPTC_template extends Base_Template {

	private ParallelPTC_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template module__; //CharString_Type
	private TitanCharString_template name; //CharString_Type
	private TitanInteger_template compref; //Integer_Type
	private TitanCharString_template compname; //CharString_Type
	private TitanCharString_template tc__loc; //CharString_Type
	private TitanInteger_template alive__pid; //Integer_Type
	private TitanInteger_template status; //Integer_Type
	//originally value_list/list_value
	List<ParallelPTC_template> list_value;

	public ParallelPTC_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public ParallelPTC_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return reason;
	}

	public TitanCharString_template getModule__() {
		setSpecific();
		return module__;
	}

	public TitanCharString_template constGetModule__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field module_ of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return module__;
	}

	public TitanCharString_template getName() {
		setSpecific();
		return name;
	}

	public TitanCharString_template constGetName() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return name;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return compref;
	}

	public TitanCharString_template getCompname() {
		setSpecific();
		return compname;
	}

	public TitanCharString_template constGetCompname() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compname of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return compname;
	}

	public TitanCharString_template getTc__loc() {
		setSpecific();
		return tc__loc;
	}

	public TitanCharString_template constGetTc__loc() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field tc_loc of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return tc__loc;
	}

	public TitanInteger_template getAlive__pid() {
		setSpecific();
		return alive__pid;
	}

	public TitanInteger_template constGetAlive__pid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field alive_pid of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return alive__pid;
	}

	public TitanInteger_template getStatus() {
		setSpecific();
		return status;
	}

	public TitanInteger_template constGetStatus() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field status of a non-specific template of type @TitanLoggerApi.ParallelPTC.");
		}
		return status;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new ParallelPTC_reason_template();
			module__ = new TitanCharString_template();
			name = new TitanCharString_template();
			compref = new TitanInteger_template();
			compname = new TitanCharString_template();
			tc__loc = new TitanCharString_template();
			alive__pid = new TitanInteger_template();
			status = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				module__.assign(template_sel.ANY_VALUE);
				name.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				compname.assign(template_sel.ANY_VALUE);
				tc__loc.assign(template_sel.ANY_VALUE);
				alive__pid.assign(template_sel.ANY_VALUE);
				status.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ParallelPTC_template() {
	}

	public ParallelPTC_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ParallelPTC_template( final ParallelPTC otherValue ) {
		copyValue(otherValue);
	}

	public ParallelPTC_template( final ParallelPTC_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ParallelPTC_template( final Optional<ParallelPTC> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ParallelPTC from an unbound optional field.");
		}
	}

	//originally operator=
	public ParallelPTC_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ParallelPTC_template assign( final ParallelPTC other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ParallelPTC_template assign( final ParallelPTC_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ParallelPTC_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelPTC) {
				return assign((ParallelPTC) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC' can not be cast to {1}", otherValue));
		}

		@Override
		public ParallelPTC_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ParallelPTC_template) {
				return assign((ParallelPTC_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC' can not be cast to {1}_template", otherValue));
		}

	public ParallelPTC_template assign( final Optional<ParallelPTC> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ParallelPTC.");
		}
		return this;
	}

	private void copyValue(final ParallelPTC other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getModule__().isBound()) {
			getModule__().assign(other_value.getModule__());
		} else {
			getModule__().cleanUp();
		}
		if (other_value.getName().isBound()) {
			getName().assign(other_value.getName());
		} else {
			getName().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getCompname().isBound()) {
			getCompname().assign(other_value.getCompname());
		} else {
			getCompname().cleanUp();
		}
		if (other_value.getTc__loc().isBound()) {
			getTc__loc().assign(other_value.getTc__loc());
		} else {
			getTc__loc().cleanUp();
		}
		if (other_value.getAlive__pid().isBound()) {
			getAlive__pid().assign(other_value.getAlive__pid());
		} else {
			getAlive__pid().cleanUp();
		}
		if (other_value.getStatus().isBound()) {
			getStatus().assign(other_value.getStatus());
		} else {
			getStatus().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ParallelPTC_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getModule__().get_selection()) {
				getModule__().cleanUp();
			} else {
				getModule__().assign(other_value.getModule__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getName().get_selection()) {
				getName().cleanUp();
			} else {
				getName().assign(other_value.getName());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompname().get_selection()) {
				getCompname().cleanUp();
			} else {
				getCompname().assign(other_value.getCompname());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTc__loc().get_selection()) {
				getTc__loc().cleanUp();
			} else {
				getTc__loc().assign(other_value.getTc__loc());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getAlive__pid().get_selection()) {
				getAlive__pid().cleanUp();
			} else {
				getAlive__pid().assign(other_value.getAlive__pid());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getStatus().get_selection()) {
				getStatus().cleanUp();
			} else {
				getStatus().assign(other_value.getStatus());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ParallelPTC_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ParallelPTC_template temp = new ParallelPTC_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ParallelPTC.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ParallelPTC valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ParallelPTC.");
			}
			final ParallelPTC ret_val = new ParallelPTC();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (module__.isBound()) {
				ret_val.module__.assign(module__.valueOf());
			}
			 if (name.isBound()) {
				ret_val.name.assign(name.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (compname.isBound()) {
				ret_val.compname.assign(compname.valueOf());
			}
			 if (tc__loc.isBound()) {
				ret_val.tc__loc.assign(tc__loc.valueOf());
			}
			 if (alive__pid.isBound()) {
				ret_val.alive__pid.assign(alive__pid.valueOf());
			}
			 if (status.isBound()) {
				ret_val.status.assign(status.valueOf());
			}
			return ret_val;
		}

		public ParallelPTC_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ParallelPTC.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ParallelPTC.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ParallelPTC.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ParallelPTC_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ParallelPTC_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (module__.isBound()) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (compname.isBound()) {
				return true;
			}
			if (tc__loc.isBound()) {
				return true;
			}
			if (alive__pid.isBound()) {
				return true;
			}
			if (status.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!module__.isValue()) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!compname.isValue()) {
				return false;
			}
			if (!tc__loc.isValue()) {
				return false;
			}
			if (!alive__pid.isValue()) {
				return false;
			}
			if (!status.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ParallelPTC other_value) {
			return match(other_value, false);
		}

		public boolean match(final ParallelPTC other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getModule__().isBound()) {
					return false;
				}
				if(!module__.match(other_value.getModule__(), legacy)) {
					return false;
				}
				if(!other_value.getName().isBound()) {
					return false;
				}
				if(!name.match(other_value.getName(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getCompname().isBound()) {
					return false;
				}
				if(!compname.match(other_value.getCompname(), legacy)) {
					return false;
				}
				if(!other_value.getTc__loc().isBound()) {
					return false;
				}
				if(!tc__loc.match(other_value.getTc__loc(), legacy)) {
					return false;
				}
				if(!other_value.getAlive__pid().isBound()) {
					return false;
				}
				if(!alive__pid.match(other_value.getAlive__pid(), legacy)) {
					return false;
				}
				if(!other_value.getStatus().isBound()) {
					return false;
				}
				if(!status.match(other_value.getStatus(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ParallelPTC) {
		return match((ParallelPTC)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ParallelPTC.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 8;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelPTC containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" module_ := ");
				module__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compname := ");
				compname.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" tc_loc := ");
				tc__loc.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" alive_pid := ");
				alive__pid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" status := ");
				status.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ParallelPTC match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParallelPTC) {
				log_match((ParallelPTC)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelPTC.");
		}

		public void log_match(final ParallelPTC match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !module__.match(match_value.constGetModule__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".module_");
							module__.log_match(match_value.constGetModule__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !name.match(match_value.constGetName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compname.match(match_value.constGetCompname(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compname");
							compname.log_match(match_value.constGetCompname(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !tc__loc.match(match_value.constGetTc__loc(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".tc_loc");
							tc__loc.log_match(match_value.constGetTc__loc(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !alive__pid.match(match_value.constGetAlive__pid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".alive_pid");
							alive__pid.log_match(match_value.constGetAlive__pid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !status.match(match_value.constGetStatus(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".status");
							status.log_match(match_value.constGetStatus(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ module_ := ");
				module__.log_match(match_value.constGetModule__(), legacy);
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetName(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ compname := ");
				compname.log_match(match_value.constGetCompname(), legacy);
				TTCN_Logger.log_event_str("{ tc_loc := ");
				tc__loc.log_match(match_value.constGetTc__loc(), legacy);
				TTCN_Logger.log_event_str("{ alive_pid := ");
				alive__pid.log_match(match_value.constGetAlive__pid(), legacy);
				TTCN_Logger.log_event_str("{ status := ");
				status.log_match(match_value.constGetStatus(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				module__.encode_text(text_buf);
				name.encode_text(text_buf);
				compref.encode_text(text_buf);
				compname.encode_text(text_buf);
				tc__loc.encode_text(text_buf);
				alive__pid.encode_text(text_buf);
				status.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ParallelPTC.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ParallelPTC_reason_template();
				reason.decode_text(text_buf);
				module__ = new TitanCharString_template();
				module__.decode_text(text_buf);
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				compname = new TitanCharString_template();
				compname.decode_text(text_buf);
				tc__loc = new TitanCharString_template();
				tc__loc.decode_text(text_buf);
				alive__pid = new TitanInteger_template();
				alive__pid.decode_text(text_buf);
				status = new TitanInteger_template();
				status.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ParallelPTC_template>(size);
				for(int i = 0; i < size; i++) {
					final ParallelPTC_template temp = new ParallelPTC_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ParallelPTC.");
			}
		}
}
public static void ParallelPTC_encoder(final ParallelPTC input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_decoder( final TitanOctetString input_stream, final ParallelPTC output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class LocationInfo_ent__type extends Base_Type {
public enum enum_type {
unknown (0),
controlpart (1),
testcase__ (2),
altstep__ (3),
function__ (4),
external__function (5),
template__ (6),
UNKNOWN_VALUE(7),
UNBOUND_VALUE(8);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return unknown;
case 1:  return controlpart;
case 2:  return testcase__;
case 3:  return altstep__;
case 4:  return function__;
case 5:  return external__function;
case 6:  return template__;
case 7:  return UNKNOWN_VALUE;
case 8:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public LocationInfo_ent__type() {
enum_value = enum_type.UNBOUND_VALUE;
}

public LocationInfo_ent__type(final LocationInfo_ent__type otherValue) {
enum_value = otherValue.enum_value;
}

public LocationInfo_ent__type(final LocationInfo_ent__type.enum_type otherValue ) {
enum_value = otherValue;
}

public LocationInfo_ent__type(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `LocationInfo_ent__type' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public LocationInfo_ent__type assign(final LocationInfo_ent__type otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public LocationInfo_ent__type assign(final Base_Type otherValue){
if( otherValue instanceof LocationInfo_ent__type ) {
return assign((LocationInfo_ent__type) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type' can not be cast to {1}", otherValue));
}

//originally operator=
public LocationInfo_ent__type assign(final LocationInfo_ent__type.enum_type otherValue){
return assign( new LocationInfo_ent__type(otherValue) );
}

//originally operator=
public LocationInfo_ent__type assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `LocationInfo_ent__type'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final LocationInfo_ent__type otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof LocationInfo_ent__type) {
return operatorEquals( (LocationInfo_ent__type) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LocationInfo.ent_type.");
}
}

//originally operator==
public boolean operatorEquals(final LocationInfo_ent__type.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final LocationInfo_ent__type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final LocationInfo_ent__type.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final LocationInfo_ent__type.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final LocationInfo_ent__type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final LocationInfo_ent__type.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final LocationInfo_ent__type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final LocationInfo_ent__type.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final LocationInfo_ent__type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final LocationInfo_ent__type.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final LocationInfo_ent__type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type LocationInfo_ent__type. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final LocationInfo_ent__type.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final LocationInfo_ent__type enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("unknown".equals(strPar)) {
return enum_type.unknown;
}
if ("controlpart".equals(strPar)) {
return enum_type.controlpart;
}
if ("testcase__".equals(strPar) || "testcase_".equals(strPar)) {
return enum_type.testcase__;
}
if ("altstep__".equals(strPar) || "altstep_".equals(strPar)) {
return enum_type.altstep__;
}
if ("function__".equals(strPar) || "function_".equals(strPar)) {
return enum_type.function__;
}
if ("external__function".equals(strPar) || "external_function".equals(strPar)) {
return enum_type.external__function;
}
if ("template__".equals(strPar) || "template_".equals(strPar)) {
return enum_type.template__;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.LocationInfo.ent_type.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.LocationInfo.ent_type.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class LocationInfo_ent__type_template extends Base_Template {
// single_value
private LocationInfo_ent__type.enum_type single_value;
// value_list part
private ArrayList<LocationInfo_ent__type_template> value_list;

private void copy_template(final LocationInfo_ent__type_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<LocationInfo_ent__type_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final LocationInfo_ent__type_template temp = new LocationInfo_ent__type_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type LocationInfo_ent__type.");
}
}

public LocationInfo_ent__type_template() {
}

public LocationInfo_ent__type_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public LocationInfo_ent__type_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!LocationInfo_ent__type.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type LocationInfo_ent__type with unknown numeric value "+ otherValue +".");
}
single_value = LocationInfo_ent__type.enum_type.getValue(otherValue);
}

public LocationInfo_ent__type_template(final LocationInfo_ent__type otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == LocationInfo_ent__type.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type LocationInfo_ent__type. ");
}
single_value = otherValue.enum_value;
}

public LocationInfo_ent__type_template(final LocationInfo_ent__type_template otherValue) {
copy_template(otherValue);
}

public LocationInfo_ent__type_template(final LocationInfo_ent__type.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != LocationInfo_ent__type.enum_type.UNBOUND_VALUE;
}

//originally operator=
public LocationInfo_ent__type_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public LocationInfo_ent__type_template assign(final int otherValue) {
if (!LocationInfo_ent__type.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type LocationInfo_ent__type.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public LocationInfo_ent__type_template assign(final LocationInfo_ent__type.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public LocationInfo_ent__type_template assign(final LocationInfo_ent__type_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public LocationInfo_ent__type_template assign(final LocationInfo_ent__type otherValue){
if (otherValue.enum_value == LocationInfo_ent__type.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type LocationInfo_ent__type to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public LocationInfo_ent__type_template assign(final Base_Type otherValue){
if( otherValue instanceof LocationInfo_ent__type ) {
return assign((LocationInfo_ent__type) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type' can not be cast to {1}", otherValue));
}

@Override
public LocationInfo_ent__type_template assign(final Base_Template otherValue){
if( otherValue instanceof LocationInfo_ent__type_template ) {
return assign((LocationInfo_ent__type_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final LocationInfo_ent__type.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final LocationInfo_ent__type.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type LocationInfo_ent__type.");
}
}

// originally match
public boolean match(final LocationInfo_ent__type otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final LocationInfo_ent__type otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof LocationInfo_ent__type ) {
return match((LocationInfo_ent__type) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `LocationInfo_ent__type' can not be cast to {1}", otherValue));
}

public LocationInfo_ent__type valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type LocationInfo_ent__type.");
}
return new LocationInfo_ent__type(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type LocationInfo_ent__type.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<LocationInfo_ent__type_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new LocationInfo_ent__type_template());
}
}

public LocationInfo_ent__type_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type LocationInfo_ent__type.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type LocationInfo_ent__type.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type LocationInfo_ent__type.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(LocationInfo_ent__type.enum2str(single_value), LocationInfo_ent__type.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof LocationInfo_ent__type) {
log_match((LocationInfo_ent__type)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LocationInfo.ent_type.");
}
public void log_match(final LocationInfo_ent__type match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.LocationInfo.ent_type.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!LocationInfo_ent__type.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.LocationInfo.ent_type.", temp));
}
single_value = LocationInfo_ent__type.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<LocationInfo_ent__type_template>(size);
for(int i = 0; i < size; i++) {
final LocationInfo_ent__type_template temp = new LocationInfo_ent__type_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.LocationInfo.ent_type.");
}
}
}
public static void LocationInfo_ent__type_encoder(final LocationInfo_ent__type input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo.ent_type' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LocationInfo_ent__type_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LocationInfo_ent__type_decoder( final TitanOctetString input_stream, final LocationInfo_ent__type output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo.ent_type' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LocationInfo_ent__type_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_inconc___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_inconc___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_inconc___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_inconc___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__in_operation_encoder(final Port__oper input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_operation_decoder( final TitanOctetString input_stream, final Port__oper output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_parallelEvent_encoder(final ParallelEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_parallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_parallelEvent_decoder( final TitanOctetString input_stream, final ParallelEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_parallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TestcaseEvent_choice_testcaseFinished_encoder(final TestcaseType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseEvent_choice_testcaseFinished_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseEvent_choice_testcaseFinished_decoder( final TitanOctetString input_stream, final TestcaseType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseEvent_choice_testcaseFinished_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Misc_remote__port_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_remote__port_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_remote__port_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_remote__port_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanSingleLogEvent_entityId_encoder(final ComponentIDType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanSingleLogEvent_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanSingleLogEvent_entityId_decoder( final TitanOctetString input_stream, final ComponentIDType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanSingleLogEvent_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__out_operation_encoder(final Port__oper input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__out_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__out_operation_decoder( final TitanOctetString input_stream, final Port__oper output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__out_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorConfigdata_param___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorConfigdata_param___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorConfigdata_param___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorConfigdata_param___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PTC__exit_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PTC__exit_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PTC__exit_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PTC__exit_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class MatchingTimeout extends Base_Type {
		private final Optional<TitanCharString> timer__name; //CharString_Type

		public MatchingTimeout() {
			timer__name = new Optional<TitanCharString>(TitanCharString.class);
		}

		public MatchingTimeout( final Optional<TitanCharString> aTimer__name ) {
			timer__name = new Optional<TitanCharString>(TitanCharString.class);
			this.timer__name.assign( aTimer__name );
		}

		public MatchingTimeout( final MatchingTimeout aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingTimeout.");
			}
			timer__name = new Optional<TitanCharString>(TitanCharString.class);
			assign( aOtherValue );
		}
		public MatchingTimeout assign(final MatchingTimeout aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingTimeout");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getTimer__name().isBound() ) {
					this.timer__name.assign( aOtherValue.getTimer__name() );
				} else {
					this.timer__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingTimeout assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingTimeout ) {
				return assign((MatchingTimeout) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingTimeout", otherValue));
		}

		public void cleanUp() {
			timer__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( optional_sel.OPTIONAL_OMIT.equals(timer__name.get_selection()) || timer__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !optional_sel.OPTIONAL_OMIT.equals(timer__name.get_selection()) && !timer__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingTimeout aOtherValue ) {
			if ( !this.timer__name.operatorEquals( aOtherValue.timer__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingTimeout ) {
				return operatorEquals((MatchingTimeout) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingTimeout", otherValue));
		}

		public Optional<TitanCharString> getTimer__name() {
			return timer__name;
		}

		public Optional<TitanCharString> constGetTimer__name() {
			return timer__name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 0;
			if (timer__name.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" timer_name := ");
			timer__name.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (timer__name.isBound()) {
				timer__name.set_implicit_omit();
			} else {
				timer__name.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			timer__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			timer__name.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class MatchingTimeout_template extends Base_Template {

	private TitanCharString_template timer__name; //CharString_Type
	//originally value_list/list_value
	List<MatchingTimeout_template> list_value;

	public TitanCharString_template getTimer__name() {
		setSpecific();
		return timer__name;
	}

	public TitanCharString_template constGetTimer__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field timer_name of a non-specific template of type @TitanLoggerApi.MatchingTimeout.");
		}
		return timer__name;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			timer__name = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				timer__name.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public MatchingTimeout_template() {
	}

	public MatchingTimeout_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public MatchingTimeout_template( final MatchingTimeout otherValue ) {
		copyValue(otherValue);
	}

	public MatchingTimeout_template( final MatchingTimeout_template otherValue ) {
		copyTemplate( otherValue );
	}

	public MatchingTimeout_template( final Optional<MatchingTimeout> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingTimeout from an unbound optional field.");
		}
	}

	//originally operator=
	public MatchingTimeout_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public MatchingTimeout_template assign( final MatchingTimeout other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public MatchingTimeout_template assign( final MatchingTimeout_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public MatchingTimeout_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingTimeout) {
				return assign((MatchingTimeout) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingTimeout' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingTimeout_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingTimeout_template) {
				return assign((MatchingTimeout_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingTimeout' can not be cast to {1}_template", otherValue));
		}

	public MatchingTimeout_template assign( final Optional<MatchingTimeout> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingTimeout.");
		}
		return this;
	}

	private void copyValue(final MatchingTimeout other_value) {
		if (other_value.getTimer__name().isBound()) {
			if (other_value.getTimer__name().isPresent()) {
				getTimer__name().assign(other_value.getTimer__name().get());
			} else {
				getTimer__name().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getTimer__name().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final MatchingTimeout_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTimer__name().get_selection()) {
				getTimer__name().cleanUp();
			} else {
				getTimer__name().assign(other_value.getTimer__name());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<MatchingTimeout_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final MatchingTimeout_template temp = new MatchingTimeout_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingTimeout.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingTimeout valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingTimeout.");
			}
			final MatchingTimeout ret_val = new MatchingTimeout();
			if (timer__name.isOmit()) {
				ret_val.timer__name.assign(template_sel.OMIT_VALUE);
			} else if (timer__name.isBound()) {
				ret_val.timer__name.assign(timer__name.valueOf());
			}
			return ret_val;
		}

		public MatchingTimeout_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingTimeout.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingTimeout.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingTimeout.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingTimeout_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingTimeout_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (timer__name.isOmit() || timer__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!timer__name.isOmit() && !timer__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingTimeout other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingTimeout other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getTimer__name().isBound()) {
					return false;
				}
				if((other_value.getTimer__name().isPresent() ? !timer__name.match(other_value.getTimer__name().get(), legacy) : !timer__name.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingTimeout) {
		return match((MatchingTimeout)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingTimeout.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 0;
				if (timer__name.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingTimeout containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" timer_name := ");
				timer__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingTimeout match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingTimeout) {
				log_match((MatchingTimeout)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingTimeout.");
		}

		public void log_match(final MatchingTimeout match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if (match_value.constGetTimer__name().isPresent()) {
							if( !timer__name.match(match_value.constGetTimer__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".timer_name");
								timer__name.log_match(match_value.constGetTimer__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!timer__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".timer_name := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								timer__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ timer_name := ");
				timer__name.log_match(match_value.constGetTimer__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timer__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timer__name = new TitanCharString_template();
				timer__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingTimeout_template>(size);
				for(int i = 0; i < size; i++) {
					final MatchingTimeout_template temp = new MatchingTimeout_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingTimeout.");
			}
		}
}
public static void MatchingTimeout_encoder(final MatchingTimeout input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingTimeout_decoder( final TitanOctetString input_stream, final MatchingTimeout output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class VerdictOp extends Base_Type {
		private final VerdictOp_choice choice; //TTCN3_Choice_Type

		public VerdictOp() {
			choice = new VerdictOp_choice();
		}

		public VerdictOp( final VerdictOp_choice aChoice ) {
			choice = new VerdictOp_choice( aChoice );
		}

		public VerdictOp( final VerdictOp aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.VerdictOp.");
			}
			choice = new VerdictOp_choice();
			assign( aOtherValue );
		}
		public VerdictOp assign(final VerdictOp aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.VerdictOp");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public VerdictOp assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictOp ) {
				return assign((VerdictOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictOp", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final VerdictOp aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof VerdictOp ) {
				return operatorEquals((VerdictOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictOp", otherValue));
		}

		public VerdictOp_choice getChoice() {
			return choice;
		}

		public VerdictOp_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class VerdictOp_template extends Base_Template {

	private VerdictOp_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<VerdictOp_template> list_value;

	public VerdictOp_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public VerdictOp_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.VerdictOp.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new VerdictOp_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public VerdictOp_template() {
	}

	public VerdictOp_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public VerdictOp_template( final VerdictOp otherValue ) {
		copyValue(otherValue);
	}

	public VerdictOp_template( final VerdictOp_template otherValue ) {
		copyTemplate( otherValue );
	}

	public VerdictOp_template( final Optional<VerdictOp> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.VerdictOp from an unbound optional field.");
		}
	}

	//originally operator=
	public VerdictOp_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public VerdictOp_template assign( final VerdictOp other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public VerdictOp_template assign( final VerdictOp_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public VerdictOp_template assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictOp) {
				return assign((VerdictOp) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictOp' can not be cast to {1}", otherValue));
		}

		@Override
		public VerdictOp_template assign(final Base_Template otherValue) {
			if (otherValue instanceof VerdictOp_template) {
				return assign((VerdictOp_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictOp' can not be cast to {1}_template", otherValue));
		}

	public VerdictOp_template assign( final Optional<VerdictOp> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.VerdictOp.");
		}
		return this;
	}

	private void copyValue(final VerdictOp other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final VerdictOp_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<VerdictOp_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final VerdictOp_template temp = new VerdictOp_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.VerdictOp.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public VerdictOp valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.VerdictOp.");
			}
			final VerdictOp ret_val = new VerdictOp();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public VerdictOp_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.VerdictOp.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.VerdictOp.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.VerdictOp.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<VerdictOp_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new VerdictOp_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final VerdictOp other_value) {
			return match(other_value, false);
		}

		public boolean match(final VerdictOp other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.VerdictOp.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof VerdictOp) {
		return match((VerdictOp)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type VerdictOp.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictOp containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.VerdictOp.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final VerdictOp match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof VerdictOp) {
				log_match((VerdictOp)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictOp.");
		}

		public void log_match(final VerdictOp match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.VerdictOp.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new VerdictOp_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<VerdictOp_template>(size);
				for(int i = 0; i < size; i++) {
					final VerdictOp_template temp = new VerdictOp_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.VerdictOp.");
			}
		}
}
public static void VerdictOp_encoder(final VerdictOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictOp_decoder( final TitanOctetString input_stream, final VerdictOp output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class MatchingProblemType_reason extends Base_Type {
public enum enum_type {
port__not__started__and__queue__empty (0),
no__incoming__types (1),
no__incoming__signatures (2),
no__outgoing__blocking__signatures (3),
no__outgoing__blocking__signatures__that__support__exceptions (4),
component__has__no__ports (5),
UNKNOWN_VALUE(6),
UNBOUND_VALUE(7);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return port__not__started__and__queue__empty;
case 1:  return no__incoming__types;
case 2:  return no__incoming__signatures;
case 3:  return no__outgoing__blocking__signatures;
case 4:  return no__outgoing__blocking__signatures__that__support__exceptions;
case 5:  return component__has__no__ports;
case 6:  return UNKNOWN_VALUE;
case 7:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public MatchingProblemType_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public MatchingProblemType_reason(final MatchingProblemType_reason otherValue) {
enum_value = otherValue.enum_value;
}

public MatchingProblemType_reason(final MatchingProblemType_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public MatchingProblemType_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingProblemType_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public MatchingProblemType_reason assign(final MatchingProblemType_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public MatchingProblemType_reason assign(final Base_Type otherValue){
if( otherValue instanceof MatchingProblemType_reason ) {
return assign((MatchingProblemType_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public MatchingProblemType_reason assign(final MatchingProblemType_reason.enum_type otherValue){
return assign( new MatchingProblemType_reason(otherValue) );
}

//originally operator=
public MatchingProblemType_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingProblemType_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final MatchingProblemType_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof MatchingProblemType_reason) {
return operatorEquals( (MatchingProblemType_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.reason.");
}
}

//originally operator==
public boolean operatorEquals(final MatchingProblemType_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final MatchingProblemType_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final MatchingProblemType_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final MatchingProblemType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final MatchingProblemType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingProblemType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingProblemType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final MatchingProblemType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final MatchingProblemType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingProblemType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingProblemType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final MatchingProblemType_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final MatchingProblemType_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("port__not__started__and__queue__empty".equals(strPar) || "port_not_started_and_queue_empty".equals(strPar)) {
return enum_type.port__not__started__and__queue__empty;
}
if ("no__incoming__types".equals(strPar) || "no_incoming_types".equals(strPar)) {
return enum_type.no__incoming__types;
}
if ("no__incoming__signatures".equals(strPar) || "no_incoming_signatures".equals(strPar)) {
return enum_type.no__incoming__signatures;
}
if ("no__outgoing__blocking__signatures".equals(strPar) || "no_outgoing_blocking_signatures".equals(strPar)) {
return enum_type.no__outgoing__blocking__signatures;
}
if ("no__outgoing__blocking__signatures__that__support__exceptions".equals(strPar) || "no_outgoing_blocking_signatures_that_support_exceptions".equals(strPar)) {
return enum_type.no__outgoing__blocking__signatures__that__support__exceptions;
}
if ("component__has__no__ports".equals(strPar) || "component_has_no_ports".equals(strPar)) {
return enum_type.component__has__no__ports;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingProblemType.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class MatchingProblemType_reason_template extends Base_Template {
// single_value
private MatchingProblemType_reason.enum_type single_value;
// value_list part
private ArrayList<MatchingProblemType_reason_template> value_list;

private void copy_template(final MatchingProblemType_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<MatchingProblemType_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final MatchingProblemType_reason_template temp = new MatchingProblemType_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingProblemType_reason.");
}
}

public MatchingProblemType_reason_template() {
}

public MatchingProblemType_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public MatchingProblemType_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!MatchingProblemType_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type MatchingProblemType_reason with unknown numeric value "+ otherValue +".");
}
single_value = MatchingProblemType_reason.enum_type.getValue(otherValue);
}

public MatchingProblemType_reason_template(final MatchingProblemType_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == MatchingProblemType_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingProblemType_reason. ");
}
single_value = otherValue.enum_value;
}

public MatchingProblemType_reason_template(final MatchingProblemType_reason_template otherValue) {
copy_template(otherValue);
}

public MatchingProblemType_reason_template(final MatchingProblemType_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != MatchingProblemType_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public MatchingProblemType_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public MatchingProblemType_reason_template assign(final int otherValue) {
if (!MatchingProblemType_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingProblemType_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public MatchingProblemType_reason_template assign(final MatchingProblemType_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public MatchingProblemType_reason_template assign(final MatchingProblemType_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public MatchingProblemType_reason_template assign(final MatchingProblemType_reason otherValue){
if (otherValue.enum_value == MatchingProblemType_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type MatchingProblemType_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public MatchingProblemType_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof MatchingProblemType_reason ) {
return assign((MatchingProblemType_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason' can not be cast to {1}", otherValue));
}

@Override
public MatchingProblemType_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof MatchingProblemType_reason_template ) {
return assign((MatchingProblemType_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final MatchingProblemType_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final MatchingProblemType_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingProblemType_reason.");
}
}

// originally match
public boolean match(final MatchingProblemType_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final MatchingProblemType_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof MatchingProblemType_reason ) {
return match((MatchingProblemType_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_reason' can not be cast to {1}", otherValue));
}

public MatchingProblemType_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingProblemType_reason.");
}
return new MatchingProblemType_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingProblemType_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<MatchingProblemType_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new MatchingProblemType_reason_template());
}
}

public MatchingProblemType_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingProblemType_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type MatchingProblemType_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type MatchingProblemType_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(MatchingProblemType_reason.enum2str(single_value), MatchingProblemType_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof MatchingProblemType_reason) {
log_match((MatchingProblemType_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.reason.");
}
public void log_match(final MatchingProblemType_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingProblemType.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!MatchingProblemType_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.reason.", temp));
}
single_value = MatchingProblemType_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<MatchingProblemType_reason_template>(size);
for(int i = 0; i < size; i++) {
final MatchingProblemType_reason_template temp = new MatchingProblemType_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingProblemType.reason.");
}
}
}
public static void MatchingProblemType_reason_encoder(final MatchingProblemType_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingProblemType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingProblemType_reason_decoder( final TitanOctetString input_stream, final MatchingProblemType_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingProblemType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Queue_param___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_param___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_param___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_param___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ExecutorRuntime_reason extends Base_Type {
public enum enum_type {
connected__to__mc (0),
disconnected__from__mc (1),
initialization__of__modules__failed (2),
exit__requested__from__mc__hc (3),
exit__requested__from__mc__mtc (4),
stop__was__requested__from__mc__ignored__on__idle__mtc (5),
stop__was__requested__from__mc (6),
stop__was__requested__from__mc__ignored__on__idle__ptc (7),
executing__testcase__in__module (8),
performing__error__recovery (9),
initializing__module (10),
initialization__of__module__finished (11),
stopping__current__testcase (12),
exiting (13),
host__controller__started (14),
host__controller__finished (15),
stopping__control__part__execution (16),
stopping__test__component__execution (17),
waiting__for__ptcs__to__finish (18),
user__paused__waiting__to__resume (19),
resuming__execution (20),
terminating__execution (21),
mtc__created (22),
overload__check (23),
overload__check__fail (24),
overloaded__no__more (25),
executor__start__single__mode (26),
executor__finish__single__mode (27),
fd__limits (28),
UNKNOWN_VALUE(29),
UNBOUND_VALUE(30);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return connected__to__mc;
case 1:  return disconnected__from__mc;
case 2:  return initialization__of__modules__failed;
case 3:  return exit__requested__from__mc__hc;
case 4:  return exit__requested__from__mc__mtc;
case 5:  return stop__was__requested__from__mc__ignored__on__idle__mtc;
case 6:  return stop__was__requested__from__mc;
case 7:  return stop__was__requested__from__mc__ignored__on__idle__ptc;
case 8:  return executing__testcase__in__module;
case 9:  return performing__error__recovery;
case 10:  return initializing__module;
case 11:  return initialization__of__module__finished;
case 12:  return stopping__current__testcase;
case 13:  return exiting;
case 14:  return host__controller__started;
case 15:  return host__controller__finished;
case 16:  return stopping__control__part__execution;
case 17:  return stopping__test__component__execution;
case 18:  return waiting__for__ptcs__to__finish;
case 19:  return user__paused__waiting__to__resume;
case 20:  return resuming__execution;
case 21:  return terminating__execution;
case 22:  return mtc__created;
case 23:  return overload__check;
case 24:  return overload__check__fail;
case 25:  return overloaded__no__more;
case 26:  return executor__start__single__mode;
case 27:  return executor__finish__single__mode;
case 28:  return fd__limits;
case 29:  return UNKNOWN_VALUE;
case 30:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public ExecutorRuntime_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public ExecutorRuntime_reason(final ExecutorRuntime_reason otherValue) {
enum_value = otherValue.enum_value;
}

public ExecutorRuntime_reason(final ExecutorRuntime_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public ExecutorRuntime_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorRuntime_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public ExecutorRuntime_reason assign(final ExecutorRuntime_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public ExecutorRuntime_reason assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorRuntime_reason ) {
return assign((ExecutorRuntime_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public ExecutorRuntime_reason assign(final ExecutorRuntime_reason.enum_type otherValue){
return assign( new ExecutorRuntime_reason(otherValue) );
}

//originally operator=
public ExecutorRuntime_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorRuntime_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final ExecutorRuntime_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof ExecutorRuntime_reason) {
return operatorEquals( (ExecutorRuntime_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorRuntime.reason.");
}
}

//originally operator==
public boolean operatorEquals(final ExecutorRuntime_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorRuntime_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorRuntime_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final ExecutorRuntime_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final ExecutorRuntime_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorRuntime_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorRuntime_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final ExecutorRuntime_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final ExecutorRuntime_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorRuntime_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorRuntime_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorRuntime_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final ExecutorRuntime_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final ExecutorRuntime_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("connected__to__mc".equals(strPar) || "connected_to_mc".equals(strPar)) {
return enum_type.connected__to__mc;
}
if ("disconnected__from__mc".equals(strPar) || "disconnected_from_mc".equals(strPar)) {
return enum_type.disconnected__from__mc;
}
if ("initialization__of__modules__failed".equals(strPar) || "initialization_of_modules_failed".equals(strPar)) {
return enum_type.initialization__of__modules__failed;
}
if ("exit__requested__from__mc__hc".equals(strPar) || "exit_requested_from_mc_hc".equals(strPar)) {
return enum_type.exit__requested__from__mc__hc;
}
if ("exit__requested__from__mc__mtc".equals(strPar) || "exit_requested_from_mc_mtc".equals(strPar)) {
return enum_type.exit__requested__from__mc__mtc;
}
if ("stop__was__requested__from__mc__ignored__on__idle__mtc".equals(strPar) || "stop_was_requested_from_mc_ignored_on_idle_mtc".equals(strPar)) {
return enum_type.stop__was__requested__from__mc__ignored__on__idle__mtc;
}
if ("stop__was__requested__from__mc".equals(strPar) || "stop_was_requested_from_mc".equals(strPar)) {
return enum_type.stop__was__requested__from__mc;
}
if ("stop__was__requested__from__mc__ignored__on__idle__ptc".equals(strPar) || "stop_was_requested_from_mc_ignored_on_idle_ptc".equals(strPar)) {
return enum_type.stop__was__requested__from__mc__ignored__on__idle__ptc;
}
if ("executing__testcase__in__module".equals(strPar) || "executing_testcase_in_module".equals(strPar)) {
return enum_type.executing__testcase__in__module;
}
if ("performing__error__recovery".equals(strPar) || "performing_error_recovery".equals(strPar)) {
return enum_type.performing__error__recovery;
}
if ("initializing__module".equals(strPar) || "initializing_module".equals(strPar)) {
return enum_type.initializing__module;
}
if ("initialization__of__module__finished".equals(strPar) || "initialization_of_module_finished".equals(strPar)) {
return enum_type.initialization__of__module__finished;
}
if ("stopping__current__testcase".equals(strPar) || "stopping_current_testcase".equals(strPar)) {
return enum_type.stopping__current__testcase;
}
if ("exiting".equals(strPar)) {
return enum_type.exiting;
}
if ("host__controller__started".equals(strPar) || "host_controller_started".equals(strPar)) {
return enum_type.host__controller__started;
}
if ("host__controller__finished".equals(strPar) || "host_controller_finished".equals(strPar)) {
return enum_type.host__controller__finished;
}
if ("stopping__control__part__execution".equals(strPar) || "stopping_control_part_execution".equals(strPar)) {
return enum_type.stopping__control__part__execution;
}
if ("stopping__test__component__execution".equals(strPar) || "stopping_test_component_execution".equals(strPar)) {
return enum_type.stopping__test__component__execution;
}
if ("waiting__for__ptcs__to__finish".equals(strPar) || "waiting_for_ptcs_to_finish".equals(strPar)) {
return enum_type.waiting__for__ptcs__to__finish;
}
if ("user__paused__waiting__to__resume".equals(strPar) || "user_paused_waiting_to_resume".equals(strPar)) {
return enum_type.user__paused__waiting__to__resume;
}
if ("resuming__execution".equals(strPar) || "resuming_execution".equals(strPar)) {
return enum_type.resuming__execution;
}
if ("terminating__execution".equals(strPar) || "terminating_execution".equals(strPar)) {
return enum_type.terminating__execution;
}
if ("mtc__created".equals(strPar) || "mtc_created".equals(strPar)) {
return enum_type.mtc__created;
}
if ("overload__check".equals(strPar) || "overload_check".equals(strPar)) {
return enum_type.overload__check;
}
if ("overload__check__fail".equals(strPar) || "overload_check_fail".equals(strPar)) {
return enum_type.overload__check__fail;
}
if ("overloaded__no__more".equals(strPar) || "overloaded_no_more".equals(strPar)) {
return enum_type.overloaded__no__more;
}
if ("executor__start__single__mode".equals(strPar) || "executor_start_single_mode".equals(strPar)) {
return enum_type.executor__start__single__mode;
}
if ("executor__finish__single__mode".equals(strPar) || "executor_finish_single_mode".equals(strPar)) {
return enum_type.executor__finish__single__mode;
}
if ("fd__limits".equals(strPar) || "fd_limits".equals(strPar)) {
return enum_type.fd__limits;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorRuntime.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorRuntime.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class ExecutorRuntime_reason_template extends Base_Template {
// single_value
private ExecutorRuntime_reason.enum_type single_value;
// value_list part
private ArrayList<ExecutorRuntime_reason_template> value_list;

private void copy_template(final ExecutorRuntime_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ExecutorRuntime_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final ExecutorRuntime_reason_template temp = new ExecutorRuntime_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorRuntime_reason.");
}
}

public ExecutorRuntime_reason_template() {
}

public ExecutorRuntime_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public ExecutorRuntime_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!ExecutorRuntime_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type ExecutorRuntime_reason with unknown numeric value "+ otherValue +".");
}
single_value = ExecutorRuntime_reason.enum_type.getValue(otherValue);
}

public ExecutorRuntime_reason_template(final ExecutorRuntime_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == ExecutorRuntime_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorRuntime_reason. ");
}
single_value = otherValue.enum_value;
}

public ExecutorRuntime_reason_template(final ExecutorRuntime_reason_template otherValue) {
copy_template(otherValue);
}

public ExecutorRuntime_reason_template(final ExecutorRuntime_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != ExecutorRuntime_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public ExecutorRuntime_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public ExecutorRuntime_reason_template assign(final int otherValue) {
if (!ExecutorRuntime_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorRuntime_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public ExecutorRuntime_reason_template assign(final ExecutorRuntime_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public ExecutorRuntime_reason_template assign(final ExecutorRuntime_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public ExecutorRuntime_reason_template assign(final ExecutorRuntime_reason otherValue){
if (otherValue.enum_value == ExecutorRuntime_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorRuntime_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public ExecutorRuntime_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorRuntime_reason ) {
return assign((ExecutorRuntime_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason' can not be cast to {1}", otherValue));
}

@Override
public ExecutorRuntime_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof ExecutorRuntime_reason_template ) {
return assign((ExecutorRuntime_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final ExecutorRuntime_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final ExecutorRuntime_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorRuntime_reason.");
}
}

// originally match
public boolean match(final ExecutorRuntime_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final ExecutorRuntime_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof ExecutorRuntime_reason ) {
return match((ExecutorRuntime_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime_reason' can not be cast to {1}", otherValue));
}

public ExecutorRuntime_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorRuntime_reason.");
}
return new ExecutorRuntime_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorRuntime_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<ExecutorRuntime_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ExecutorRuntime_reason_template());
}
}

public ExecutorRuntime_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorRuntime_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorRuntime_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorRuntime_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(ExecutorRuntime_reason.enum2str(single_value), ExecutorRuntime_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ExecutorRuntime_reason) {
log_match((ExecutorRuntime_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorRuntime.reason.");
}
public void log_match(final ExecutorRuntime_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorRuntime.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!ExecutorRuntime_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorRuntime.reason.", temp));
}
single_value = ExecutorRuntime_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ExecutorRuntime_reason_template>(size);
for(int i = 0; i < size; i++) {
final ExecutorRuntime_reason_template temp = new ExecutorRuntime_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorRuntime.reason.");
}
}
}
public static void ExecutorRuntime_reason_encoder(final ExecutorRuntime_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorRuntime_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorRuntime_reason_decoder( final TitanOctetString input_stream, final ExecutorRuntime_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorRuntime_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class MatchingFailureType_reason extends Base_Type {
public enum enum_type {
sender__does__not__match__from__clause (0),
sender__is__not__system (1),
message__does__not__match__template (2),
parameters__of__call__do__not__match__template (3),
parameters__of__reply__do__not__match__template (4),
exception__does__not__match__template (5),
not__an__exception__for__signature (6),
UNKNOWN_VALUE(7),
UNBOUND_VALUE(8);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return sender__does__not__match__from__clause;
case 1:  return sender__is__not__system;
case 2:  return message__does__not__match__template;
case 3:  return parameters__of__call__do__not__match__template;
case 4:  return parameters__of__reply__do__not__match__template;
case 5:  return exception__does__not__match__template;
case 6:  return not__an__exception__for__signature;
case 7:  return UNKNOWN_VALUE;
case 8:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public MatchingFailureType_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public MatchingFailureType_reason(final MatchingFailureType_reason otherValue) {
enum_value = otherValue.enum_value;
}

public MatchingFailureType_reason(final MatchingFailureType_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public MatchingFailureType_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingFailureType_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public MatchingFailureType_reason assign(final MatchingFailureType_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public MatchingFailureType_reason assign(final Base_Type otherValue){
if( otherValue instanceof MatchingFailureType_reason ) {
return assign((MatchingFailureType_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public MatchingFailureType_reason assign(final MatchingFailureType_reason.enum_type otherValue){
return assign( new MatchingFailureType_reason(otherValue) );
}

//originally operator=
public MatchingFailureType_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingFailureType_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final MatchingFailureType_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof MatchingFailureType_reason) {
return operatorEquals( (MatchingFailureType_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.reason.");
}
}

//originally operator==
public boolean operatorEquals(final MatchingFailureType_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final MatchingFailureType_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final MatchingFailureType_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final MatchingFailureType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final MatchingFailureType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingFailureType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingFailureType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final MatchingFailureType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final MatchingFailureType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingFailureType_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingFailureType_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingFailureType_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final MatchingFailureType_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final MatchingFailureType_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("sender__does__not__match__from__clause".equals(strPar) || "sender_does_not_match_from_clause".equals(strPar)) {
return enum_type.sender__does__not__match__from__clause;
}
if ("sender__is__not__system".equals(strPar) || "sender_is_not_system".equals(strPar)) {
return enum_type.sender__is__not__system;
}
if ("message__does__not__match__template".equals(strPar) || "message_does_not_match_template".equals(strPar)) {
return enum_type.message__does__not__match__template;
}
if ("parameters__of__call__do__not__match__template".equals(strPar) || "parameters_of_call_do_not_match_template".equals(strPar)) {
return enum_type.parameters__of__call__do__not__match__template;
}
if ("parameters__of__reply__do__not__match__template".equals(strPar) || "parameters_of_reply_do_not_match_template".equals(strPar)) {
return enum_type.parameters__of__reply__do__not__match__template;
}
if ("exception__does__not__match__template".equals(strPar) || "exception_does_not_match_template".equals(strPar)) {
return enum_type.exception__does__not__match__template;
}
if ("not__an__exception__for__signature".equals(strPar) || "not_an_exception_for_signature".equals(strPar)) {
return enum_type.not__an__exception__for__signature;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingFailureType.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingFailureType.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class MatchingFailureType_reason_template extends Base_Template {
// single_value
private MatchingFailureType_reason.enum_type single_value;
// value_list part
private ArrayList<MatchingFailureType_reason_template> value_list;

private void copy_template(final MatchingFailureType_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<MatchingFailureType_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final MatchingFailureType_reason_template temp = new MatchingFailureType_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingFailureType_reason.");
}
}

public MatchingFailureType_reason_template() {
}

public MatchingFailureType_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public MatchingFailureType_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!MatchingFailureType_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type MatchingFailureType_reason with unknown numeric value "+ otherValue +".");
}
single_value = MatchingFailureType_reason.enum_type.getValue(otherValue);
}

public MatchingFailureType_reason_template(final MatchingFailureType_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == MatchingFailureType_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingFailureType_reason. ");
}
single_value = otherValue.enum_value;
}

public MatchingFailureType_reason_template(final MatchingFailureType_reason_template otherValue) {
copy_template(otherValue);
}

public MatchingFailureType_reason_template(final MatchingFailureType_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != MatchingFailureType_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public MatchingFailureType_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public MatchingFailureType_reason_template assign(final int otherValue) {
if (!MatchingFailureType_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingFailureType_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public MatchingFailureType_reason_template assign(final MatchingFailureType_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public MatchingFailureType_reason_template assign(final MatchingFailureType_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public MatchingFailureType_reason_template assign(final MatchingFailureType_reason otherValue){
if (otherValue.enum_value == MatchingFailureType_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type MatchingFailureType_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public MatchingFailureType_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof MatchingFailureType_reason ) {
return assign((MatchingFailureType_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason' can not be cast to {1}", otherValue));
}

@Override
public MatchingFailureType_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof MatchingFailureType_reason_template ) {
return assign((MatchingFailureType_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final MatchingFailureType_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final MatchingFailureType_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingFailureType_reason.");
}
}

// originally match
public boolean match(final MatchingFailureType_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final MatchingFailureType_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof MatchingFailureType_reason ) {
return match((MatchingFailureType_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType_reason' can not be cast to {1}", otherValue));
}

public MatchingFailureType_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingFailureType_reason.");
}
return new MatchingFailureType_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingFailureType_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<MatchingFailureType_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new MatchingFailureType_reason_template());
}
}

public MatchingFailureType_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingFailureType_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type MatchingFailureType_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type MatchingFailureType_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(MatchingFailureType_reason.enum2str(single_value), MatchingFailureType_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof MatchingFailureType_reason) {
log_match((MatchingFailureType_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.reason.");
}
public void log_match(final MatchingFailureType_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingFailureType.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!MatchingFailureType_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingFailureType.reason.", temp));
}
single_value = MatchingFailureType_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<MatchingFailureType_reason_template>(size);
for(int i = 0; i < size; i++) {
final MatchingFailureType_reason_template temp = new MatchingFailureType_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingFailureType.reason.");
}
}
}
public static void MatchingFailureType_reason_encoder(final MatchingFailureType_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_reason_decoder( final TitanOctetString input_stream, final MatchingFailureType_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorRuntime_module__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorRuntime_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorRuntime_module__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorRuntime_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TitanSingleLogEvent extends Base_Type {
		private final ComponentIDType entityId; //Referenced_Type
		private final TitanLogEvent event; //Referenced_Type

		public TitanSingleLogEvent() {
			entityId = new ComponentIDType();
			event = new TitanLogEvent();
		}

		public TitanSingleLogEvent( final ComponentIDType aEntityId, final TitanLogEvent aEvent ) {
			entityId = new ComponentIDType( aEntityId );
			event = new TitanLogEvent( aEvent );
		}

		public TitanSingleLogEvent( final TitanSingleLogEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			entityId = new ComponentIDType();
			event = new TitanLogEvent();
			assign( aOtherValue );
		}
		public TitanSingleLogEvent assign(final TitanSingleLogEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanSingleLogEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getEntityId().isBound() ) {
					this.entityId.assign( aOtherValue.getEntityId() );
				} else {
					this.entityId.cleanUp();
				}
				if ( aOtherValue.getEvent().isBound() ) {
					this.event.assign( aOtherValue.getEvent() );
				} else {
					this.event.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanSingleLogEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanSingleLogEvent ) {
				return assign((TitanSingleLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanSingleLogEvent", otherValue));
		}

		public void cleanUp() {
			entityId.cleanUp();
			event.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( entityId.isBound() ) { return true; }
			if ( event.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !entityId.isValue() ) { return false; }
			if ( !event.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanSingleLogEvent aOtherValue ) {
			if ( !this.entityId.operatorEquals( aOtherValue.entityId ) ) { return false; }
			if ( !this.event.operatorEquals( aOtherValue.event ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanSingleLogEvent ) {
				return operatorEquals((TitanSingleLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanSingleLogEvent", otherValue));
		}

		public ComponentIDType getEntityId() {
			return entityId;
		}

		public ComponentIDType constGetEntityId() {
			return entityId;
		}

		public TitanLogEvent getEvent() {
			return event;
		}

		public TitanLogEvent constGetEvent() {
			return event;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" entityId := ");
			entityId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" event := ");
			event.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (entityId.isBound()) {
				entityId.set_implicit_omit();
			}
			if (event.isBound()) {
				event.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			entityId.encode_text(text_buf);
			event.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			entityId.decode_text(text_buf);
			event.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TitanSingleLogEvent_template extends Base_Template {

	private ComponentIDType_template entityId; //Referenced_Type
	private TitanLogEvent_template event; //Referenced_Type
	//originally value_list/list_value
	List<TitanSingleLogEvent_template> list_value;

	public ComponentIDType_template getEntityId() {
		setSpecific();
		return entityId;
	}

	public ComponentIDType_template constGetEntityId() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field entityId of a non-specific template of type @TitanLoggerApi.TitanSingleLogEvent.");
		}
		return entityId;
	}

	public TitanLogEvent_template getEvent() {
		setSpecific();
		return event;
	}

	public TitanLogEvent_template constGetEvent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field event of a non-specific template of type @TitanLoggerApi.TitanSingleLogEvent.");
		}
		return event;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			entityId = new ComponentIDType_template();
			event = new TitanLogEvent_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				entityId.assign(template_sel.ANY_VALUE);
				event.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TitanSingleLogEvent_template() {
	}

	public TitanSingleLogEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanSingleLogEvent_template( final TitanSingleLogEvent otherValue ) {
		copyValue(otherValue);
	}

	public TitanSingleLogEvent_template( final TitanSingleLogEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanSingleLogEvent_template( final Optional<TitanSingleLogEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanSingleLogEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public TitanSingleLogEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanSingleLogEvent_template assign( final TitanSingleLogEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TitanSingleLogEvent_template assign( final TitanSingleLogEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TitanSingleLogEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanSingleLogEvent) {
				return assign((TitanSingleLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanSingleLogEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanSingleLogEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanSingleLogEvent_template) {
				return assign((TitanSingleLogEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanSingleLogEvent' can not be cast to {1}_template", otherValue));
		}

	public TitanSingleLogEvent_template assign( final Optional<TitanSingleLogEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanSingleLogEvent.");
		}
		return this;
	}

	private void copyValue(final TitanSingleLogEvent other_value) {
		if (other_value.getEntityId().isBound()) {
			getEntityId().assign(other_value.getEntityId());
		} else {
			getEntityId().cleanUp();
		}
		if (other_value.getEvent().isBound()) {
			getEvent().assign(other_value.getEvent());
		} else {
			getEvent().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanSingleLogEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEntityId().get_selection()) {
				getEntityId().cleanUp();
			} else {
				getEntityId().assign(other_value.getEntityId());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEvent().get_selection()) {
				getEvent().cleanUp();
			} else {
				getEvent().assign(other_value.getEvent());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanSingleLogEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanSingleLogEvent_template temp = new TitanSingleLogEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanSingleLogEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanSingleLogEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			final TitanSingleLogEvent ret_val = new TitanSingleLogEvent();
			 if (entityId.isBound()) {
				ret_val.entityId.assign(entityId.valueOf());
			}
			 if (event.isBound()) {
				ret_val.event.assign(event.valueOf());
			}
			return ret_val;
		}

		public TitanSingleLogEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanSingleLogEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanSingleLogEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (entityId.isBound()) {
				return true;
			}
			if (event.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!entityId.isValue()) {
				return false;
			}
			if (!event.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanSingleLogEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanSingleLogEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getEntityId().isBound()) {
					return false;
				}
				if(!entityId.match(other_value.getEntityId(), legacy)) {
					return false;
				}
				if(!other_value.getEvent().isBound()) {
					return false;
				}
				if(!event.match(other_value.getEvent(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TitanSingleLogEvent) {
		return match((TitanSingleLogEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanSingleLogEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanSingleLogEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" entityId := ");
				entityId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" event := ");
				event.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanSingleLogEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanSingleLogEvent) {
				log_match((TitanSingleLogEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanSingleLogEvent.");
		}

		public void log_match(final TitanSingleLogEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !entityId.match(match_value.constGetEntityId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".entityId");
							entityId.log_match(match_value.constGetEntityId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !event.match(match_value.constGetEvent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".event");
							event.log_match(match_value.constGetEvent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ entityId := ");
				entityId.log_match(match_value.constGetEntityId(), legacy);
				TTCN_Logger.log_event_str("{ event := ");
				event.log_match(match_value.constGetEvent(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId.encode_text(text_buf);
				event.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId = new ComponentIDType_template();
				entityId.decode_text(text_buf);
				event = new TitanLogEvent_template();
				event.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanSingleLogEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final TitanSingleLogEvent_template temp = new TitanSingleLogEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanSingleLogEvent.");
			}
		}
}
public static void TitanSingleLogEvent_encoder(final TitanSingleLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanSingleLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanSingleLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanSingleLogEvent_decoder( final TitanOctetString input_stream, final TitanSingleLogEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanSingleLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanSingleLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_procPortRecv_encoder(final Proc__port__in input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_procPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_procPortRecv_decoder( final TitanOctetString input_stream, final Proc__port__in output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_procPortRecv_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class MatchingProblemType_operation extends Base_Type {
public enum enum_type {
receive__ (0),
trigger__ (1),
getcall__ (2),
getreply__ (3),
catch__ (4),
check__ (5),
UNKNOWN_VALUE(6),
UNBOUND_VALUE(7);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return receive__;
case 1:  return trigger__;
case 2:  return getcall__;
case 3:  return getreply__;
case 4:  return catch__;
case 5:  return check__;
case 6:  return UNKNOWN_VALUE;
case 7:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public MatchingProblemType_operation() {
enum_value = enum_type.UNBOUND_VALUE;
}

public MatchingProblemType_operation(final MatchingProblemType_operation otherValue) {
enum_value = otherValue.enum_value;
}

public MatchingProblemType_operation(final MatchingProblemType_operation.enum_type otherValue ) {
enum_value = otherValue;
}

public MatchingProblemType_operation(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `MatchingProblemType_operation' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public MatchingProblemType_operation assign(final MatchingProblemType_operation otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public MatchingProblemType_operation assign(final Base_Type otherValue){
if( otherValue instanceof MatchingProblemType_operation ) {
return assign((MatchingProblemType_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation' can not be cast to {1}", otherValue));
}

//originally operator=
public MatchingProblemType_operation assign(final MatchingProblemType_operation.enum_type otherValue){
return assign( new MatchingProblemType_operation(otherValue) );
}

//originally operator=
public MatchingProblemType_operation assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `MatchingProblemType_operation'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final MatchingProblemType_operation otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof MatchingProblemType_operation) {
return operatorEquals( (MatchingProblemType_operation) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.operation.");
}
}

//originally operator==
public boolean operatorEquals(final MatchingProblemType_operation.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final MatchingProblemType_operation otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final MatchingProblemType_operation.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final MatchingProblemType_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final MatchingProblemType_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingProblemType_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final MatchingProblemType_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final MatchingProblemType_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final MatchingProblemType_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingProblemType_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final MatchingProblemType_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type MatchingProblemType_operation. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final MatchingProblemType_operation.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final MatchingProblemType_operation enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("receive__".equals(strPar) || "receive_".equals(strPar)) {
return enum_type.receive__;
}
if ("trigger__".equals(strPar) || "trigger_".equals(strPar)) {
return enum_type.trigger__;
}
if ("getcall__".equals(strPar) || "getcall_".equals(strPar)) {
return enum_type.getcall__;
}
if ("getreply__".equals(strPar) || "getreply_".equals(strPar)) {
return enum_type.getreply__;
}
if ("catch__".equals(strPar) || "catch_".equals(strPar)) {
return enum_type.catch__;
}
if ("check__".equals(strPar) || "check_".equals(strPar)) {
return enum_type.check__;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.MatchingProblemType.operation.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.operation.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class MatchingProblemType_operation_template extends Base_Template {
// single_value
private MatchingProblemType_operation.enum_type single_value;
// value_list part
private ArrayList<MatchingProblemType_operation_template> value_list;

private void copy_template(final MatchingProblemType_operation_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<MatchingProblemType_operation_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final MatchingProblemType_operation_template temp = new MatchingProblemType_operation_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type MatchingProblemType_operation.");
}
}

public MatchingProblemType_operation_template() {
}

public MatchingProblemType_operation_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public MatchingProblemType_operation_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!MatchingProblemType_operation.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type MatchingProblemType_operation with unknown numeric value "+ otherValue +".");
}
single_value = MatchingProblemType_operation.enum_type.getValue(otherValue);
}

public MatchingProblemType_operation_template(final MatchingProblemType_operation otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == MatchingProblemType_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type MatchingProblemType_operation. ");
}
single_value = otherValue.enum_value;
}

public MatchingProblemType_operation_template(final MatchingProblemType_operation_template otherValue) {
copy_template(otherValue);
}

public MatchingProblemType_operation_template(final MatchingProblemType_operation.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != MatchingProblemType_operation.enum_type.UNBOUND_VALUE;
}

//originally operator=
public MatchingProblemType_operation_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public MatchingProblemType_operation_template assign(final int otherValue) {
if (!MatchingProblemType_operation.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type MatchingProblemType_operation.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public MatchingProblemType_operation_template assign(final MatchingProblemType_operation.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public MatchingProblemType_operation_template assign(final MatchingProblemType_operation_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public MatchingProblemType_operation_template assign(final MatchingProblemType_operation otherValue){
if (otherValue.enum_value == MatchingProblemType_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type MatchingProblemType_operation to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public MatchingProblemType_operation_template assign(final Base_Type otherValue){
if( otherValue instanceof MatchingProblemType_operation ) {
return assign((MatchingProblemType_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation' can not be cast to {1}", otherValue));
}

@Override
public MatchingProblemType_operation_template assign(final Base_Template otherValue){
if( otherValue instanceof MatchingProblemType_operation_template ) {
return assign((MatchingProblemType_operation_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final MatchingProblemType_operation.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final MatchingProblemType_operation.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type MatchingProblemType_operation.");
}
}

// originally match
public boolean match(final MatchingProblemType_operation otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final MatchingProblemType_operation otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof MatchingProblemType_operation ) {
return match((MatchingProblemType_operation) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType_operation' can not be cast to {1}", otherValue));
}

public MatchingProblemType_operation valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type MatchingProblemType_operation.");
}
return new MatchingProblemType_operation(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type MatchingProblemType_operation.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<MatchingProblemType_operation_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new MatchingProblemType_operation_template());
}
}

public MatchingProblemType_operation_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type MatchingProblemType_operation.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type MatchingProblemType_operation.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type MatchingProblemType_operation.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(MatchingProblemType_operation.enum2str(single_value), MatchingProblemType_operation.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof MatchingProblemType_operation) {
log_match((MatchingProblemType_operation)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.operation.");
}
public void log_match(final MatchingProblemType_operation match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.MatchingProblemType.operation.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!MatchingProblemType_operation.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.MatchingProblemType.operation.", temp));
}
single_value = MatchingProblemType_operation.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<MatchingProblemType_operation_template>(size);
for(int i = 0; i < size; i++) {
final MatchingProblemType_operation_template temp = new MatchingProblemType_operation_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.MatchingProblemType.operation.");
}
}
}
public static void MatchingProblemType_operation_encoder(final MatchingProblemType_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingProblemType_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingProblemType_operation_decoder( final TitanOctetString input_stream, final MatchingProblemType_operation output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingProblemType_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_msgPortSend_encoder(final Msg__port__send input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_msgPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_msgPortSend_decoder( final TitanOctetString input_stream, final Msg__port__send output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_msgPortSend_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LocationInfo_filename_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LocationInfo_filename_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LocationInfo_filename_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LocationInfo_filename_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_guardTimer_encoder(final TimerGuardType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_guardTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_guardTimer_decoder( final TitanOctetString input_stream, final TimerGuardType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_guardTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingFailureType_choice_system___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_choice_system___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_choice_system___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_choice_system___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class MatchingFailureType_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_System__,  ALT_Compref };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public MatchingFailureType_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public MatchingFailureType_choice(final MatchingFailureType_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final MatchingFailureType_choice otherValue) {
switch (otherValue.union_selection){
case ALT_System__:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_Compref:
field = new TitanInteger((TitanInteger)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.MatchingFailureType.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public MatchingFailureType_choice assign( final MatchingFailureType_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public MatchingFailureType_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof MatchingFailureType_choice) {
return assign((MatchingFailureType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_System__:
return field.isValue();
case ALT_Compref:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final MatchingFailureType_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingFailureType.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingFailureType.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_System__:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_Compref:
return ((TitanInteger)field).operatorEquals((TitanInteger)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof MatchingFailureType_choice) {
return operatorEquals((MatchingFailureType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final MatchingFailureType_choice otherValue ) {
return !operatorEquals(otherValue);
}

public TitanCharString getSystem__() {
if (union_selection != union_selection_type.ALT_System__) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_System__;
}
return (TitanCharString)field;
}

public TitanCharString constGetSystem__() {
if (union_selection != union_selection_type.ALT_System__) {
throw new TtcnError("Using non-selected field system_ in a value of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return (TitanCharString)field;
}

public TitanInteger getCompref() {
if (union_selection != union_selection_type.ALT_Compref) {
cleanUp();
field = new TitanInteger();
union_selection = union_selection_type.ALT_Compref;
}
return (TitanInteger)field;
}

public TitanInteger constGetCompref() {
if (union_selection != union_selection_type.ALT_Compref) {
throw new TtcnError("Using non-selected field compref in a value of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return (TitanInteger)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_System__:
TTCN_Logger.log_event_str("{ system_ := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_Compref:
TTCN_Logger.log_event_str("{ compref := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_System__:
case ALT_Compref:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_System__:
text_buf.push_int(0);
break;
case ALT_Compref:
text_buf.push_int(1);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getSystem__().decode_text(text_buf);
break;
case 1:
getCompref().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.MatchingFailureType.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class MatchingFailureType_choice_template extends Base_Template {
//if single value which value?
private MatchingFailureType_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<MatchingFailureType_choice_template> value_list;

private void copy_value(final MatchingFailureType_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_System__:
single_value = new TitanCharString_template(other_value.constGetSystem__());
break;
case ALT_Compref:
single_value = new TitanInteger_template(other_value.constGetCompref());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.MatchingFailureType.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final MatchingFailureType_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_System__:
single_value = new TitanCharString_template(other_value.constGetSystem__());
break;
case ALT_Compref:
single_value = new TitanInteger_template(other_value.constGetCompref());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.MatchingFailureType.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<MatchingFailureType_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final MatchingFailureType_choice_template temp = new MatchingFailureType_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
set_selection(other_value);
}

public MatchingFailureType_choice_template() {
}
public MatchingFailureType_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public MatchingFailureType_choice_template(final MatchingFailureType_choice other_value) {
copy_value(other_value);
}
public MatchingFailureType_choice_template(final MatchingFailureType_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_System__:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_Compref:
((TitanInteger_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public MatchingFailureType_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public MatchingFailureType_choice_template assign( final MatchingFailureType_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public MatchingFailureType_choice_template assign( final MatchingFailureType_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public MatchingFailureType_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof MatchingFailureType_choice) {
return assign((MatchingFailureType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to MatchingFailureType_choice.");
}

@Override
public MatchingFailureType_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof MatchingFailureType_choice_template) {
return assign((MatchingFailureType_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to MatchingFailureType_choice_template.");
}

// originally match
public boolean match(final MatchingFailureType_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final MatchingFailureType_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final MatchingFailureType_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == MatchingFailureType_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_System__:
return ((TitanCharString_template)single_value).match(other_value.getSystem__(), legacy);
case ALT_Compref:
return ((TitanInteger_template)single_value).match(other_value.getCompref(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingFailureType_choice) {
		return match((MatchingFailureType_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingFailureType_choice.");
	}
public boolean isChosen(final MatchingFailureType_choice.union_selection_type checked_selection) {
if(checked_selection == MatchingFailureType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == MatchingFailureType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_System__:
return ((TitanCharString_template)single_value).isValue();
case ALT_Compref:
return ((TitanInteger_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
}

public MatchingFailureType_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
final MatchingFailureType_choice ret_val = new MatchingFailureType_choice();
switch (single_value_union_selection) {
case ALT_System__:
ret_val.getSystem__().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_Compref:
ret_val.getCompref().assign(((TitanInteger_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<MatchingFailureType_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new MatchingFailureType_choice_template());
}
}

public MatchingFailureType_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public TitanCharString_template getSystem__() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_System__) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = MatchingFailureType_choice.union_selection_type.ALT_System__;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetSystem__() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field system_ in a non-specific template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
if (single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_System__) {
throw new TtcnError("Accessing non-selected field system_ in a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return (TitanCharString_template)single_value;
}

public TitanInteger_template getCompref() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_Compref) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanInteger_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanInteger_template();
}
single_value_union_selection = MatchingFailureType_choice.union_selection_type.ALT_Compref;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanInteger_template)single_value;
}

public TitanInteger_template constGetCompref() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field compref in a non-specific template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
if (single_value_union_selection != MatchingFailureType_choice.union_selection_type.ALT_Compref) {
throw new TtcnError("Accessing non-selected field compref in a template of union type @TitanLoggerApi.MatchingFailureType.choice.");
}
return (TitanInteger_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof MatchingFailureType_choice) {
log_match((MatchingFailureType_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.choice.");
}

public void log_match(final MatchingFailureType_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_System__:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".system_");
single_value.log_match(match_value.getSystem__(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ system_ := ");
single_value.log_match(match_value.getSystem__(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_Compref:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".compref");
single_value.log_match(match_value.getCompref(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ compref := ");
single_value.log_match(match_value.getCompref(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.MatchingFailureType.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new TitanInteger_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<MatchingFailureType_choice_template>(size);
for (int i = 0; i < size; i++) {
final MatchingFailureType_choice_template temp2 = new MatchingFailureType_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.MatchingFailureType.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void MatchingFailureType_choice_encoder(final MatchingFailureType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_choice_decoder( final TitanOctetString input_stream, final MatchingFailureType_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ExecutorConfigdata_reason extends Base_Type {
public enum enum_type {
received__from__mc (0),
processing__failed (1),
processing__succeeded (2),
module__has__parameters (3),
using__config__file (4),
overriding__testcase__list (5),
UNKNOWN_VALUE(6),
UNBOUND_VALUE(7);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return received__from__mc;
case 1:  return processing__failed;
case 2:  return processing__succeeded;
case 3:  return module__has__parameters;
case 4:  return using__config__file;
case 5:  return overriding__testcase__list;
case 6:  return UNKNOWN_VALUE;
case 7:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public ExecutorConfigdata_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public ExecutorConfigdata_reason(final ExecutorConfigdata_reason otherValue) {
enum_value = otherValue.enum_value;
}

public ExecutorConfigdata_reason(final ExecutorConfigdata_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public ExecutorConfigdata_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorConfigdata_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public ExecutorConfigdata_reason assign(final ExecutorConfigdata_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public ExecutorConfigdata_reason assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorConfigdata_reason ) {
return assign((ExecutorConfigdata_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public ExecutorConfigdata_reason assign(final ExecutorConfigdata_reason.enum_type otherValue){
return assign( new ExecutorConfigdata_reason(otherValue) );
}

//originally operator=
public ExecutorConfigdata_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorConfigdata_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final ExecutorConfigdata_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof ExecutorConfigdata_reason) {
return operatorEquals( (ExecutorConfigdata_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorConfigdata.reason.");
}
}

//originally operator==
public boolean operatorEquals(final ExecutorConfigdata_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorConfigdata_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorConfigdata_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final ExecutorConfigdata_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final ExecutorConfigdata_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorConfigdata_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorConfigdata_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final ExecutorConfigdata_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final ExecutorConfigdata_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorConfigdata_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorConfigdata_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final ExecutorConfigdata_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final ExecutorConfigdata_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("received__from__mc".equals(strPar) || "received_from_mc".equals(strPar)) {
return enum_type.received__from__mc;
}
if ("processing__failed".equals(strPar) || "processing_failed".equals(strPar)) {
return enum_type.processing__failed;
}
if ("processing__succeeded".equals(strPar) || "processing_succeeded".equals(strPar)) {
return enum_type.processing__succeeded;
}
if ("module__has__parameters".equals(strPar) || "module_has_parameters".equals(strPar)) {
return enum_type.module__has__parameters;
}
if ("using__config__file".equals(strPar) || "using_config_file".equals(strPar)) {
return enum_type.using__config__file;
}
if ("overriding__testcase__list".equals(strPar) || "overriding_testcase_list".equals(strPar)) {
return enum_type.overriding__testcase__list;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class ExecutorConfigdata_reason_template extends Base_Template {
// single_value
private ExecutorConfigdata_reason.enum_type single_value;
// value_list part
private ArrayList<ExecutorConfigdata_reason_template> value_list;

private void copy_template(final ExecutorConfigdata_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ExecutorConfigdata_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final ExecutorConfigdata_reason_template temp = new ExecutorConfigdata_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorConfigdata_reason.");
}
}

public ExecutorConfigdata_reason_template() {
}

public ExecutorConfigdata_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public ExecutorConfigdata_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!ExecutorConfigdata_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type ExecutorConfigdata_reason with unknown numeric value "+ otherValue +".");
}
single_value = ExecutorConfigdata_reason.enum_type.getValue(otherValue);
}

public ExecutorConfigdata_reason_template(final ExecutorConfigdata_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == ExecutorConfigdata_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorConfigdata_reason. ");
}
single_value = otherValue.enum_value;
}

public ExecutorConfigdata_reason_template(final ExecutorConfigdata_reason_template otherValue) {
copy_template(otherValue);
}

public ExecutorConfigdata_reason_template(final ExecutorConfigdata_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != ExecutorConfigdata_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public ExecutorConfigdata_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public ExecutorConfigdata_reason_template assign(final int otherValue) {
if (!ExecutorConfigdata_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorConfigdata_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public ExecutorConfigdata_reason_template assign(final ExecutorConfigdata_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public ExecutorConfigdata_reason_template assign(final ExecutorConfigdata_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public ExecutorConfigdata_reason_template assign(final ExecutorConfigdata_reason otherValue){
if (otherValue.enum_value == ExecutorConfigdata_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorConfigdata_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public ExecutorConfigdata_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorConfigdata_reason ) {
return assign((ExecutorConfigdata_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason' can not be cast to {1}", otherValue));
}

@Override
public ExecutorConfigdata_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof ExecutorConfigdata_reason_template ) {
return assign((ExecutorConfigdata_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final ExecutorConfigdata_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final ExecutorConfigdata_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorConfigdata_reason.");
}
}

// originally match
public boolean match(final ExecutorConfigdata_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final ExecutorConfigdata_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof ExecutorConfigdata_reason ) {
return match((ExecutorConfigdata_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorConfigdata_reason' can not be cast to {1}", otherValue));
}

public ExecutorConfigdata_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorConfigdata_reason.");
}
return new ExecutorConfigdata_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorConfigdata_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<ExecutorConfigdata_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ExecutorConfigdata_reason_template());
}
}

public ExecutorConfigdata_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorConfigdata_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorConfigdata_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorConfigdata_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(ExecutorConfigdata_reason.enum2str(single_value), ExecutorConfigdata_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ExecutorConfigdata_reason) {
log_match((ExecutorConfigdata_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorConfigdata.reason.");
}
public void log_match(final ExecutorConfigdata_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!ExecutorConfigdata_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.", temp));
}
single_value = ExecutorConfigdata_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ExecutorConfigdata_reason_template>(size);
for(int i = 0; i < size; i++) {
final ExecutorConfigdata_reason_template temp = new ExecutorConfigdata_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorConfigdata.reason.");
}
}
}
public static void ExecutorConfigdata_reason_encoder(final ExecutorConfigdata_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorConfigdata_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorConfigdata_reason_decoder( final TitanOctetString input_stream, final ExecutorConfigdata_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorConfigdata.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorConfigdata_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class QualifiedName extends Base_Type {
		private final TitanCharString module__name; //CharString_Type
		private final TitanCharString testcase__name; //CharString_Type

		public QualifiedName() {
			module__name = new TitanCharString();
			testcase__name = new TitanCharString();
		}

		public QualifiedName( final TitanCharString aModule__name, final TitanCharString aTestcase__name ) {
			module__name = new TitanCharString( aModule__name );
			testcase__name = new TitanCharString( aTestcase__name );
		}

		public QualifiedName( final QualifiedName aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.QualifiedName.");
			}
			module__name = new TitanCharString();
			testcase__name = new TitanCharString();
			assign( aOtherValue );
		}
		public QualifiedName assign(final QualifiedName aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.QualifiedName");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getModule__name().isBound() ) {
					this.module__name.assign( aOtherValue.getModule__name() );
				} else {
					this.module__name.cleanUp();
				}
				if ( aOtherValue.getTestcase__name().isBound() ) {
					this.testcase__name.assign( aOtherValue.getTestcase__name() );
				} else {
					this.testcase__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public QualifiedName assign(final Base_Type otherValue) {
			if (otherValue instanceof QualifiedName ) {
				return assign((QualifiedName) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.QualifiedName", otherValue));
		}

		public void cleanUp() {
			module__name.cleanUp();
			testcase__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( module__name.isBound() ) { return true; }
			if ( testcase__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !module__name.isValue() ) { return false; }
			if ( !testcase__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final QualifiedName aOtherValue ) {
			if ( !this.module__name.operatorEquals( aOtherValue.module__name ) ) { return false; }
			if ( !this.testcase__name.operatorEquals( aOtherValue.testcase__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof QualifiedName ) {
				return operatorEquals((QualifiedName) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.QualifiedName", otherValue));
		}

		public TitanCharString getModule__name() {
			return module__name;
		}

		public TitanCharString constGetModule__name() {
			return module__name;
		}

		public TitanCharString getTestcase__name() {
			return testcase__name;
		}

		public TitanCharString constGetTestcase__name() {
			return testcase__name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" module_name := ");
			module__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" testcase_name := ");
			testcase__name.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (module__name.isBound()) {
				module__name.set_implicit_omit();
			}
			if (testcase__name.isBound()) {
				testcase__name.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			module__name.encode_text(text_buf);
			testcase__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			module__name.decode_text(text_buf);
			testcase__name.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class QualifiedName_template extends Base_Template {

	private TitanCharString_template module__name; //CharString_Type
	private TitanCharString_template testcase__name; //CharString_Type
	//originally value_list/list_value
	List<QualifiedName_template> list_value;

	public TitanCharString_template getModule__name() {
		setSpecific();
		return module__name;
	}

	public TitanCharString_template constGetModule__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field module_name of a non-specific template of type @TitanLoggerApi.QualifiedName.");
		}
		return module__name;
	}

	public TitanCharString_template getTestcase__name() {
		setSpecific();
		return testcase__name;
	}

	public TitanCharString_template constGetTestcase__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field testcase_name of a non-specific template of type @TitanLoggerApi.QualifiedName.");
		}
		return testcase__name;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			module__name = new TitanCharString_template();
			testcase__name = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				module__name.assign(template_sel.ANY_VALUE);
				testcase__name.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public QualifiedName_template() {
	}

	public QualifiedName_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public QualifiedName_template( final QualifiedName otherValue ) {
		copyValue(otherValue);
	}

	public QualifiedName_template( final QualifiedName_template otherValue ) {
		copyTemplate( otherValue );
	}

	public QualifiedName_template( final Optional<QualifiedName> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.QualifiedName from an unbound optional field.");
		}
	}

	//originally operator=
	public QualifiedName_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public QualifiedName_template assign( final QualifiedName other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public QualifiedName_template assign( final QualifiedName_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public QualifiedName_template assign(final Base_Type otherValue) {
			if (otherValue instanceof QualifiedName) {
				return assign((QualifiedName) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `QualifiedName' can not be cast to {1}", otherValue));
		}

		@Override
		public QualifiedName_template assign(final Base_Template otherValue) {
			if (otherValue instanceof QualifiedName_template) {
				return assign((QualifiedName_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `QualifiedName' can not be cast to {1}_template", otherValue));
		}

	public QualifiedName_template assign( final Optional<QualifiedName> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.QualifiedName.");
		}
		return this;
	}

	private void copyValue(final QualifiedName other_value) {
		if (other_value.getModule__name().isBound()) {
			getModule__name().assign(other_value.getModule__name());
		} else {
			getModule__name().cleanUp();
		}
		if (other_value.getTestcase__name().isBound()) {
			getTestcase__name().assign(other_value.getTestcase__name());
		} else {
			getTestcase__name().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final QualifiedName_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getModule__name().get_selection()) {
				getModule__name().cleanUp();
			} else {
				getModule__name().assign(other_value.getModule__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTestcase__name().get_selection()) {
				getTestcase__name().cleanUp();
			} else {
				getTestcase__name().assign(other_value.getTestcase__name());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<QualifiedName_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final QualifiedName_template temp = new QualifiedName_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.QualifiedName.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public QualifiedName valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.QualifiedName.");
			}
			final QualifiedName ret_val = new QualifiedName();
			 if (module__name.isBound()) {
				ret_val.module__name.assign(module__name.valueOf());
			}
			 if (testcase__name.isBound()) {
				ret_val.testcase__name.assign(testcase__name.valueOf());
			}
			return ret_val;
		}

		public QualifiedName_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.QualifiedName.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.QualifiedName.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.QualifiedName.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<QualifiedName_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new QualifiedName_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (module__name.isBound()) {
				return true;
			}
			if (testcase__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!module__name.isValue()) {
				return false;
			}
			if (!testcase__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final QualifiedName other_value) {
			return match(other_value, false);
		}

		public boolean match(final QualifiedName other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getModule__name().isBound()) {
					return false;
				}
				if(!module__name.match(other_value.getModule__name(), legacy)) {
					return false;
				}
				if(!other_value.getTestcase__name().isBound()) {
					return false;
				}
				if(!testcase__name.match(other_value.getTestcase__name(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.QualifiedName.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof QualifiedName) {
		return match((QualifiedName)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type QualifiedName.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.QualifiedName containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.QualifiedName.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" module_name := ");
				module__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" testcase_name := ");
				testcase__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final QualifiedName match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof QualifiedName) {
				log_match((QualifiedName)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.QualifiedName.");
		}

		public void log_match(final QualifiedName match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !module__name.match(match_value.constGetModule__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".module_name");
							module__name.log_match(match_value.constGetModule__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !testcase__name.match(match_value.constGetTestcase__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".testcase_name");
							testcase__name.log_match(match_value.constGetTestcase__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ module_name := ");
				module__name.log_match(match_value.constGetModule__name(), legacy);
				TTCN_Logger.log_event_str("{ testcase_name := ");
				testcase__name.log_match(match_value.constGetTestcase__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				module__name.encode_text(text_buf);
				testcase__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.QualifiedName.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				module__name = new TitanCharString_template();
				module__name.decode_text(text_buf);
				testcase__name = new TitanCharString_template();
				testcase__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<QualifiedName_template>(size);
				for(int i = 0; i < size; i++) {
					final QualifiedName_template temp = new QualifiedName_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.QualifiedName.");
			}
		}
}
public static void QualifiedName_encoder(final QualifiedName input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(QualifiedName_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger QualifiedName_decoder( final TitanOctetString input_stream, final QualifiedName output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(QualifiedName_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Queue_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class FunctionEvent_choice_random extends Base_Type {
		private final RandomAction operation; //Referenced_Type
		private final TitanFloat retval; //Float_Type
		private final TitanInteger intseed; //Integer_Type

		public FunctionEvent_choice_random() {
			operation = new RandomAction();
			retval = new TitanFloat();
			intseed = new TitanInteger();
		}

		public FunctionEvent_choice_random( final RandomAction aOperation, final TitanFloat aRetval, final TitanInteger aIntseed ) {
			operation = new RandomAction( aOperation );
			retval = new TitanFloat( aRetval );
			intseed = new TitanInteger( aIntseed );
		}

		public FunctionEvent_choice_random( final FunctionEvent_choice_random aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			operation = new RandomAction();
			retval = new TitanFloat();
			intseed = new TitanInteger();
			assign( aOtherValue );
		}
		public FunctionEvent_choice_random assign(final FunctionEvent_choice_random aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FunctionEvent.choice.random");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getRetval().isBound() ) {
					this.retval.assign( aOtherValue.getRetval() );
				} else {
					this.retval.cleanUp();
				}
				if ( aOtherValue.getIntseed().isBound() ) {
					this.intseed.assign( aOtherValue.getIntseed() );
				} else {
					this.intseed.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FunctionEvent_choice_random assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random ) {
				return assign((FunctionEvent_choice_random) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent.choice.random", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			retval.cleanUp();
			intseed.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( retval.isBound() ) { return true; }
			if ( intseed.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !retval.isValue() ) { return false; }
			if ( !intseed.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FunctionEvent_choice_random aOtherValue ) {
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.retval.operatorEquals( aOtherValue.retval ) ) { return false; }
			if ( !this.intseed.operatorEquals( aOtherValue.intseed ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random ) {
				return operatorEquals((FunctionEvent_choice_random) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent.choice.random", otherValue));
		}

		public RandomAction getOperation() {
			return operation;
		}

		public RandomAction constGetOperation() {
			return operation;
		}

		public TitanFloat getRetval() {
			return retval;
		}

		public TitanFloat constGetRetval() {
			return retval;
		}

		public TitanInteger getIntseed() {
			return intseed;
		}

		public TitanInteger constGetIntseed() {
			return intseed;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" retval := ");
			retval.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" intseed := ");
			intseed.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (retval.isBound()) {
				retval.set_implicit_omit();
			}
			if (intseed.isBound()) {
				intseed.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			retval.encode_text(text_buf);
			intseed.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			retval.decode_text(text_buf);
			intseed.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class FunctionEvent_choice_random_template extends Base_Template {

	private RandomAction_template operation; //Referenced_Type
	private TitanFloat_template retval; //Float_Type
	private TitanInteger_template intseed; //Integer_Type
	//originally value_list/list_value
	List<FunctionEvent_choice_random_template> list_value;

	public RandomAction_template getOperation() {
		setSpecific();
		return operation;
	}

	public RandomAction_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
		}
		return operation;
	}

	public TitanFloat_template getRetval() {
		setSpecific();
		return retval;
	}

	public TitanFloat_template constGetRetval() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field retval of a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
		}
		return retval;
	}

	public TitanInteger_template getIntseed() {
		setSpecific();
		return intseed;
	}

	public TitanInteger_template constGetIntseed() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field intseed of a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
		}
		return intseed;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			operation = new RandomAction_template();
			retval = new TitanFloat_template();
			intseed = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				operation.assign(template_sel.ANY_VALUE);
				retval.assign(template_sel.ANY_VALUE);
				intseed.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public FunctionEvent_choice_random_template() {
	}

	public FunctionEvent_choice_random_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public FunctionEvent_choice_random_template( final FunctionEvent_choice_random otherValue ) {
		copyValue(otherValue);
	}

	public FunctionEvent_choice_random_template( final FunctionEvent_choice_random_template otherValue ) {
		copyTemplate( otherValue );
	}

	public FunctionEvent_choice_random_template( final Optional<FunctionEvent_choice_random> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.FunctionEvent.choice.random from an unbound optional field.");
		}
	}

	//originally operator=
	public FunctionEvent_choice_random_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public FunctionEvent_choice_random_template assign( final FunctionEvent_choice_random other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public FunctionEvent_choice_random_template assign( final FunctionEvent_choice_random_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public FunctionEvent_choice_random_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random) {
				return assign((FunctionEvent_choice_random) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent_choice_random' can not be cast to {1}", otherValue));
		}

		@Override
		public FunctionEvent_choice_random_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FunctionEvent_choice_random_template) {
				return assign((FunctionEvent_choice_random_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent_choice_random' can not be cast to {1}_template", otherValue));
		}

	public FunctionEvent_choice_random_template assign( final Optional<FunctionEvent_choice_random> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FunctionEvent.choice.random.");
		}
		return this;
	}

	private void copyValue(final FunctionEvent_choice_random other_value) {
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getRetval().isBound()) {
			getRetval().assign(other_value.getRetval());
		} else {
			getRetval().cleanUp();
		}
		if (other_value.getIntseed().isBound()) {
			getIntseed().assign(other_value.getIntseed());
		} else {
			getIntseed().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final FunctionEvent_choice_random_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getRetval().get_selection()) {
				getRetval().cleanUp();
			} else {
				getRetval().assign(other_value.getRetval());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getIntseed().get_selection()) {
				getIntseed().cleanUp();
			} else {
				getIntseed().assign(other_value.getIntseed());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<FunctionEvent_choice_random_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final FunctionEvent_choice_random_template temp = new FunctionEvent_choice_random_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FunctionEvent.choice.random.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FunctionEvent_choice_random valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			final FunctionEvent_choice_random ret_val = new FunctionEvent_choice_random();
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (retval.isBound()) {
				ret_val.retval.assign(retval.valueOf());
			}
			 if (intseed.isBound()) {
				ret_val.intseed.assign(intseed.valueOf());
			}
			return ret_val;
		}

		public FunctionEvent_choice_random_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FunctionEvent_choice_random_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FunctionEvent_choice_random_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (retval.isBound()) {
				return true;
			}
			if (intseed.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!retval.isValue()) {
				return false;
			}
			if (!intseed.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FunctionEvent_choice_random other_value) {
			return match(other_value, false);
		}

		public boolean match(final FunctionEvent_choice_random other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getRetval().isBound()) {
					return false;
				}
				if(!retval.match(other_value.getRetval(), legacy)) {
					return false;
				}
				if(!other_value.getIntseed().isBound()) {
					return false;
				}
				if(!intseed.match(other_value.getIntseed(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof FunctionEvent_choice_random) {
		return match((FunctionEvent_choice_random)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type FunctionEvent_choice_random.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent.choice.random containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" retval := ");
				retval.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" intseed := ");
				intseed.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FunctionEvent_choice_random match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FunctionEvent_choice_random) {
				log_match((FunctionEvent_choice_random)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.random.");
		}

		public void log_match(final FunctionEvent_choice_random match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !retval.match(match_value.constGetRetval(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".retval");
							retval.log_match(match_value.constGetRetval(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !intseed.match(match_value.constGetIntseed(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".intseed");
							intseed.log_match(match_value.constGetIntseed(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ retval := ");
				retval.log_match(match_value.constGetRetval(), legacy);
				TTCN_Logger.log_event_str("{ intseed := ");
				intseed.log_match(match_value.constGetIntseed(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				retval.encode_text(text_buf);
				intseed.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new RandomAction_template();
				operation.decode_text(text_buf);
				retval = new TitanFloat_template();
				retval.decode_text(text_buf);
				intseed = new TitanInteger_template();
				intseed.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FunctionEvent_choice_random_template>(size);
				for(int i = 0; i < size; i++) {
					final FunctionEvent_choice_random_template temp = new FunctionEvent_choice_random_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FunctionEvent.choice.random.");
			}
		}
}
public static void FunctionEvent_choice_random_encoder(final FunctionEvent_choice_random input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice.random' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_choice_random_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_choice_random_decoder( final TitanOctetString input_stream, final FunctionEvent_choice_random output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice.random' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_choice_random_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingEvent_choice_matchingTimeout_encoder(final MatchingTimeout input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_choice_matchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_choice_matchingTimeout_decoder( final TitanOctetString input_stream, final MatchingTimeout output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingTimeout' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_choice_matchingTimeout_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanLogEvent_severity_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLogEvent_severity_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLogEvent_severity_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLogEvent_severity_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__out_sys__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__out_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__out_sys__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__out_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__in_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Misc_tcp__port_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_tcp__port_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_tcp__port_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_tcp__port_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerType_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerType_name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerType_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerType_name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Dualface__mapped extends Base_Type {
		private final TitanBoolean incoming; //Boolean_Type
		private final TitanCharString target__type; //CharString_Type
		private final TitanCharString value__; //CharString_Type
		private final TitanInteger msgid; //Integer_Type

		public Dualface__mapped() {
			incoming = new TitanBoolean();
			target__type = new TitanCharString();
			value__ = new TitanCharString();
			msgid = new TitanInteger();
		}

		public Dualface__mapped( final TitanBoolean aIncoming, final TitanCharString aTarget__type, final TitanCharString aValue__, final TitanInteger aMsgid ) {
			incoming = new TitanBoolean( aIncoming );
			target__type = new TitanCharString( aTarget__type );
			value__ = new TitanCharString( aValue__ );
			msgid = new TitanInteger( aMsgid );
		}

		public Dualface__mapped( final Dualface__mapped aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Dualface_mapped.");
			}
			incoming = new TitanBoolean();
			target__type = new TitanCharString();
			value__ = new TitanCharString();
			msgid = new TitanInteger();
			assign( aOtherValue );
		}
		public Dualface__mapped assign(final Dualface__mapped aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Dualface_mapped");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getIncoming().isBound() ) {
					this.incoming.assign( aOtherValue.getIncoming() );
				} else {
					this.incoming.cleanUp();
				}
				if ( aOtherValue.getTarget__type().isBound() ) {
					this.target__type.assign( aOtherValue.getTarget__type() );
				} else {
					this.target__type.cleanUp();
				}
				if ( aOtherValue.getValue__().isBound() ) {
					this.value__.assign( aOtherValue.getValue__() );
				} else {
					this.value__.cleanUp();
				}
				if ( aOtherValue.getMsgid().isBound() ) {
					this.msgid.assign( aOtherValue.getMsgid() );
				} else {
					this.msgid.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Dualface__mapped assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__mapped ) {
				return assign((Dualface__mapped) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_mapped", otherValue));
		}

		public void cleanUp() {
			incoming.cleanUp();
			target__type.cleanUp();
			value__.cleanUp();
			msgid.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( incoming.isBound() ) { return true; }
			if ( target__type.isBound() ) { return true; }
			if ( value__.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !incoming.isValue() ) { return false; }
			if ( !target__type.isValue() ) { return false; }
			if ( !value__.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Dualface__mapped aOtherValue ) {
			if ( !this.incoming.operatorEquals( aOtherValue.incoming ) ) { return false; }
			if ( !this.target__type.operatorEquals( aOtherValue.target__type ) ) { return false; }
			if ( !this.value__.operatorEquals( aOtherValue.value__ ) ) { return false; }
			if ( !this.msgid.operatorEquals( aOtherValue.msgid ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__mapped ) {
				return operatorEquals((Dualface__mapped) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_mapped", otherValue));
		}

		public TitanBoolean getIncoming() {
			return incoming;
		}

		public TitanBoolean constGetIncoming() {
			return incoming;
		}

		public TitanCharString getTarget__type() {
			return target__type;
		}

		public TitanCharString constGetTarget__type() {
			return target__type;
		}

		public TitanCharString getValue__() {
			return value__;
		}

		public TitanCharString constGetValue__() {
			return value__;
		}

		public TitanInteger getMsgid() {
			return msgid;
		}

		public TitanInteger constGetMsgid() {
			return msgid;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" incoming := ");
			incoming.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" target_type := ");
			target__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" value_ := ");
			value__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (incoming.isBound()) {
				incoming.set_implicit_omit();
			}
			if (target__type.isBound()) {
				target__type.set_implicit_omit();
			}
			if (value__.isBound()) {
				value__.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			incoming.encode_text(text_buf);
			target__type.encode_text(text_buf);
			value__.encode_text(text_buf);
			msgid.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			incoming.decode_text(text_buf);
			target__type.decode_text(text_buf);
			value__.decode_text(text_buf);
			msgid.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Dualface__mapped_template extends Base_Template {

	private TitanBoolean_template incoming; //Boolean_Type
	private TitanCharString_template target__type; //CharString_Type
	private TitanCharString_template value__; //CharString_Type
	private TitanInteger_template msgid; //Integer_Type
	//originally value_list/list_value
	List<Dualface__mapped_template> list_value;

	public TitanBoolean_template getIncoming() {
		setSpecific();
		return incoming;
	}

	public TitanBoolean_template constGetIncoming() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field incoming of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
		}
		return incoming;
	}

	public TitanCharString_template getTarget__type() {
		setSpecific();
		return target__type;
	}

	public TitanCharString_template constGetTarget__type() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field target_type of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
		}
		return target__type;
	}

	public TitanCharString_template getValue__() {
		setSpecific();
		return value__;
	}

	public TitanCharString_template constGetValue__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field value_ of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
		}
		return value__;
	}

	public TitanInteger_template getMsgid() {
		setSpecific();
		return msgid;
	}

	public TitanInteger_template constGetMsgid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
		}
		return msgid;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			incoming = new TitanBoolean_template();
			target__type = new TitanCharString_template();
			value__ = new TitanCharString_template();
			msgid = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				incoming.assign(template_sel.ANY_VALUE);
				target__type.assign(template_sel.ANY_VALUE);
				value__.assign(template_sel.ANY_VALUE);
				msgid.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Dualface__mapped_template() {
	}

	public Dualface__mapped_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Dualface__mapped_template( final Dualface__mapped otherValue ) {
		copyValue(otherValue);
	}

	public Dualface__mapped_template( final Dualface__mapped_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Dualface__mapped_template( final Optional<Dualface__mapped> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Dualface_mapped from an unbound optional field.");
		}
	}

	//originally operator=
	public Dualface__mapped_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Dualface__mapped_template assign( final Dualface__mapped other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Dualface__mapped_template assign( final Dualface__mapped_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Dualface__mapped_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__mapped) {
				return assign((Dualface__mapped) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__mapped' can not be cast to {1}", otherValue));
		}

		@Override
		public Dualface__mapped_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Dualface__mapped_template) {
				return assign((Dualface__mapped_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__mapped' can not be cast to {1}_template", otherValue));
		}

	public Dualface__mapped_template assign( final Optional<Dualface__mapped> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Dualface_mapped.");
		}
		return this;
	}

	private void copyValue(final Dualface__mapped other_value) {
		if (other_value.getIncoming().isBound()) {
			getIncoming().assign(other_value.getIncoming());
		} else {
			getIncoming().cleanUp();
		}
		if (other_value.getTarget__type().isBound()) {
			getTarget__type().assign(other_value.getTarget__type());
		} else {
			getTarget__type().cleanUp();
		}
		if (other_value.getValue__().isBound()) {
			getValue__().assign(other_value.getValue__());
		} else {
			getValue__().cleanUp();
		}
		if (other_value.getMsgid().isBound()) {
			getMsgid().assign(other_value.getMsgid());
		} else {
			getMsgid().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Dualface__mapped_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getIncoming().get_selection()) {
				getIncoming().cleanUp();
			} else {
				getIncoming().assign(other_value.getIncoming());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTarget__type().get_selection()) {
				getTarget__type().cleanUp();
			} else {
				getTarget__type().assign(other_value.getTarget__type());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getValue__().get_selection()) {
				getValue__().cleanUp();
			} else {
				getValue__().assign(other_value.getValue__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getMsgid().get_selection()) {
				getMsgid().cleanUp();
			} else {
				getMsgid().assign(other_value.getMsgid());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Dualface__mapped_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Dualface__mapped_template temp = new Dualface__mapped_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Dualface_mapped.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Dualface__mapped valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Dualface_mapped.");
			}
			final Dualface__mapped ret_val = new Dualface__mapped();
			 if (incoming.isBound()) {
				ret_val.incoming.assign(incoming.valueOf());
			}
			 if (target__type.isBound()) {
				ret_val.target__type.assign(target__type.valueOf());
			}
			 if (value__.isBound()) {
				ret_val.value__.assign(value__.valueOf());
			}
			 if (msgid.isBound()) {
				ret_val.msgid.assign(msgid.valueOf());
			}
			return ret_val;
		}

		public Dualface__mapped_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Dualface_mapped.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Dualface_mapped.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Dualface_mapped.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Dualface__mapped_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Dualface__mapped_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (incoming.isBound()) {
				return true;
			}
			if (target__type.isBound()) {
				return true;
			}
			if (value__.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!incoming.isValue()) {
				return false;
			}
			if (!target__type.isValue()) {
				return false;
			}
			if (!value__.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Dualface__mapped other_value) {
			return match(other_value, false);
		}

		public boolean match(final Dualface__mapped other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getIncoming().isBound()) {
					return false;
				}
				if(!incoming.match(other_value.getIncoming(), legacy)) {
					return false;
				}
				if(!other_value.getTarget__type().isBound()) {
					return false;
				}
				if(!target__type.match(other_value.getTarget__type(), legacy)) {
					return false;
				}
				if(!other_value.getValue__().isBound()) {
					return false;
				}
				if(!value__.match(other_value.getValue__(), legacy)) {
					return false;
				}
				if(!other_value.getMsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getMsgid(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Dualface__mapped) {
		return match((Dualface__mapped)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Dualface__mapped.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_mapped containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" incoming := ");
				incoming.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" target_type := ");
				target__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" value_ := ");
				value__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Dualface__mapped match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Dualface__mapped) {
				log_match((Dualface__mapped)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Dualface_mapped.");
		}

		public void log_match(final Dualface__mapped match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !incoming.match(match_value.constGetIncoming(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".incoming");
							incoming.log_match(match_value.constGetIncoming(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !target__type.match(match_value.constGetTarget__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".target_type");
							target__type.log_match(match_value.constGetTarget__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !value__.match(match_value.constGetValue__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".value_");
							value__.log_match(match_value.constGetValue__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetMsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetMsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ incoming := ");
				incoming.log_match(match_value.constGetIncoming(), legacy);
				TTCN_Logger.log_event_str("{ target_type := ");
				target__type.log_match(match_value.constGetTarget__type(), legacy);
				TTCN_Logger.log_event_str("{ value_ := ");
				value__.log_match(match_value.constGetValue__(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetMsgid(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming.encode_text(text_buf);
				target__type.encode_text(text_buf);
				value__.encode_text(text_buf);
				msgid.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming = new TitanBoolean_template();
				incoming.decode_text(text_buf);
				target__type = new TitanCharString_template();
				target__type.decode_text(text_buf);
				value__ = new TitanCharString_template();
				value__.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Dualface__mapped_template>(size);
				for(int i = 0; i < size; i++) {
					final Dualface__mapped_template temp = new Dualface__mapped_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Dualface_mapped.");
			}
		}
}
public static void Dualface__mapped_encoder(final Dualface__mapped input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__mapped_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__mapped_decoder( final TitanOctetString input_stream, final Dualface__mapped output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__mapped_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class TitanLogEvent_sourceInfo__list extends Base_Type {

	private List<LocationInfo> valueElements;

	public TitanLogEvent_sourceInfo__list() {
	}

	public TitanLogEvent_sourceInfo__list( final TitanLogEvent_sourceInfo__list otherValue ) {
		otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		valueElements = copyList( otherValue.valueElements );
	}

	public TitanLogEvent_sourceInfo__list(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<LocationInfo>();
	}

	private static final List<LocationInfo> copyList( final List<LocationInfo> srcList ) {
		if ( srcList == null ) {
			return null;
		}

		final List<LocationInfo> newList = new ArrayList<LocationInfo>( srcList.size() );
		for (final LocationInfo srcElem : srcList) {
			final LocationInfo newElem = getUnboundElem();
			if (srcElem.isBound()) {
				newElem.assign( srcElem );
			}
			newList.add( ( newElem ) );
		}
		return newList;
	}

	@Override
	public boolean isPresent() {
		return isBound();
	}

	@Override
	public boolean isBound() {
		return valueElements != null;
	}

	public void mustBound( final String aErrorMessage ) {
		if ( !isBound() ) {
			throw new TtcnError( aErrorMessage );
		}
	}

	@Override
	public boolean isValue() {
		if (valueElements == null) {
			return false;
		}
		for (int i=0; i < valueElements.size(); i++) {
			final LocationInfo elem = valueElements.get(i);
			if (elem == null || !elem.isValue()) {
				return false;
			}
		}
		return true;
	}


	@Override
	public boolean operatorEquals(final Base_Type otherValue) {
		if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
			return operatorEquals((TitanLogEvent_sourceInfo__list)otherValue);
		}
		throw new TtcnError("Internal Error: The left operand of comparison is not of type TitanLogEvent_sourceInfo__list.");
	}

	//originally operator==
	public boolean operatorEquals( final TitanLogEvent_sourceInfo__list otherValue ) {
		mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");

		final int size = valueElements.size();
		if ( size != otherValue.valueElements.size() ) {
			return false;
		}

		for ( int i = 0; i < size; i++ ) {
			final LocationInfo leftElem = valueElements.get( i );
			final LocationInfo rightElem = otherValue.valueElements.get( i );
			if (leftElem.isBound()) {
				if (rightElem.isBound()) {
					if ( !leftElem.operatorEquals( rightElem ) ) {
						return false;
					}
				} else {
					return false;
				}
			} else if (rightElem.isBound()) {
				return false;
			}
		}

		return true;
	}

	@Override
	public TitanLogEvent_sourceInfo__list assign(final Base_Type otherValue) {
	if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
		return assign((TitanLogEvent_sourceInfo__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list.");
	}

	//originally operator=
	public TitanLogEvent_sourceInfo__list assign( final TitanLogEvent_sourceInfo__list aOtherValue ) {
		aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );

		valueElements = copyList( aOtherValue.valueElements );
		return this;
	}

	public TitanLogEvent_sourceInfo__list assign(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<LocationInfo>();
		return this;
	}

	//originally operator+
	public TitanLogEvent_sourceInfo__list concatenate(final TitanLogEvent_sourceInfo__list other_value) {
		if (valueElements == null || other_value.valueElements == null) {
			throw new TtcnError("Unbound operand of @TitanLoggerApi.TitanLogEvent.sourceInfo_list concatenation.");
		}
		final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i < valueElements.size(); i++) {
			final LocationInfo elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		for (int i = 0; i < other_value.valueElements.size(); i++) {
			final LocationInfo elem = other_value.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		return ret_val;
	}

	public TitanLogEvent_sourceInfo__list concatenate(final TitanNull_Type nullValue) {
		return new TitanLogEvent_sourceInfo__list(this);
	}

	//originally operator<<=
	public TitanLogEvent_sourceInfo__list rotateLeft(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate left operator.");
		return rotateLeft(rotate_count.getInt());
	}

	//originally operator<<=
	public TitanLogEvent_sourceInfo__list rotateLeft(final int rotate_count) {
		return rotateRight(-rotate_count);
	}

	//originally operator>>=
	public TitanLogEvent_sourceInfo__list rotateRight(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate right operator.");
		return rotateRight(rotate_count.getInt());
	}

	//originally operator>>=
	public TitanLogEvent_sourceInfo__list rotateRight(final int rotate_count) {
		if (valueElements == null) {
			throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		final int size = valueElements.size();
		if (size == 0) {
			return new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
		}
		int rc;
		if (rotate_count >= 0) {
			rc = rotate_count % size;
		} else {
			rc = size - ((-rotate_count) % size);
		}
		if (rc == 0) {
			return new TitanLogEvent_sourceInfo__list(this);
		}
		final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
		for (int i = size - rc; i < size; i++) {
			final LocationInfo elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		for (int i = 0; i < size - rc; i++) {
			final LocationInfo elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		return ret_val;
	}

	//originally clean_up
	public void cleanUp() {
		valueElements = null;
	}

	//originally get_at(int)
	public LocationInfo getAt( final int index_value ) {
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: "+index_value+".");
		}

		if (valueElements == null || index_value >= valueElements.size() ) {
			//increase list size
			setSize(index_value + 1);
		}

		if ( valueElements.get( index_value ) == null ) {
			final LocationInfo newElem = getUnboundElem();
			valueElements.set( index_value, newElem );
		}
		return valueElements.get( index_value );
	}

	//originally get_at(const INTEGER&)
	public LocationInfo getAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );
		return getAt( index_value.getInt() );
	}

	//originally get_at(int) const
	public LocationInfo constGetAt( final int index_value ) {
		if ( !isBound() ) {
			throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );
		}
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: "+index_value+".");
		}
		final int nofElements = n_elem().getInt();
		if ( index_value >= nofElements ) {
			throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
		}

		final LocationInfo elem = valueElements.get( index_value );
		return ( elem != null ) ? elem : getUnboundElem();
	}

	//originally get_at(const INTEGER&) const
	public LocationInfo constGetAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list." );
		return constGetAt( index_value.getInt() );
	}

	public TitanInteger sizeOf() {
		mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		return new TitanInteger(valueElements.size());
	}

	public TitanInteger n_elem() {
		return sizeOf();
	}

	public TitanInteger lengthOf() {
		mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
			final LocationInfo elem = valueElements.get( i );
			if ( elem != null && elem.isBound() ) {
				return new TitanInteger(i + 1);
			}
		}
		return new TitanInteger(0);
	}

	public void setSize(final int newSize) {
		if (newSize < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		if ( valueElements == null ) {
			valueElements = new ArrayList<LocationInfo>();
		}
		if (newSize > valueElements.size()) {
			for ( int i = valueElements.size(); i < newSize; i++ ) {
				valueElements.add( new LocationInfo() );
			}
		} else if (newSize < valueElements.size()) {
			while(valueElements.size() > newSize) {
				valueElements.remove(valueElements.size()-1);
			}
		}
	}

	private static LocationInfo getUnboundElem() {
		return new LocationInfo();
	}
/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */

	@Override
	public String toString() {
		if (!isBound()) {
			return "<unbound>";
		}
		final StringBuilder sb = new StringBuilder();
		sb.append('{');
		final int size = ( valueElements == null ) ? 0 : valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				sb.append(',');
			}
			sb.append(valueElements.get(i).toString());
		}
		sb.append('}');
		return sb.toString();
	}

	public TitanLogEvent_sourceInfo__list substr(final int index, final int returncount) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.TitanLogEvent.sourceInfo_list","element");
		final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i<returncount; i++) {
			if (valueElements.get(i+index) != null) {
				ret_val.valueElements.add(new LocationInfo(valueElements.get(i+index)));
			}
		}
		return ret_val;
	}

	public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list repl) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		if (repl.valueElements == null) {
			throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.TitanLogEvent.sourceInfo_list","element");
		final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
		for (int i = 0; i < index; i++) {
			final LocationInfo elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		for (int i = 0; i < repl.valueElements.size(); i++) {
			final LocationInfo elem = repl.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		for (int i = 0; i < valueElements.size() - index - len; i++) {
			final LocationInfo elem = valueElements.get(index + i + len);
			if (elem != null) {
				ret_val.valueElements.add(new LocationInfo(elem));
			}
		}
		return ret_val;
	}

	public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len, repl.valueOf());
	}

	public TitanLogEvent_sourceInfo__list replace(final int index, final TitanInteger len, final TitanLogEvent_sourceInfo__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len.getInt(), repl.valueOf());
	}

	public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final int len, final TitanLogEvent_sourceInfo__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len, repl.valueOf());
	}

	public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final TitanInteger len, final TitanLogEvent_sourceInfo__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len.getInt(), repl.valueOf());
	}
	public void log() {
		if (valueElements == null) {
			TTCN_Logger.log_event_unbound();
			return;
		}
		TTCN_Logger.log_event_str("{ ");
		final int size = valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				TTCN_Logger.log_event_str(", ");
			}
		valueElements.get(i).log();
		}
		TTCN_Logger.log_event_str(" }");
	}
		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<LocationInfo>(temp);
			for (int i = 0; i < temp; i++) {
				final LocationInfo temp2 = new LocationInfo();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

}
public static class TitanLogEvent_sourceInfo__list_template extends Record_Of_Template {

	//originally single_value/value_elements
	List<LocationInfo_template> value_elements;

	//originally value_list/list_value
	List<TitanLogEvent_sourceInfo__list_template> list_value;

	private final match_function_t match_function_specific = new match_function_t() {
		@Override
		public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
			return match_index((TitanLogEvent_sourceInfo__list)value_ptr, value_index, (TitanLogEvent_sourceInfo__list_template)template_ptr, template_index, legacy);
		}
	};

	public TitanLogEvent_sourceInfo__list_template() {
	}

	public TitanLogEvent_sourceInfo__list_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanLogEvent_sourceInfo__list_template( final TitanLogEvent_sourceInfo__list otherValue ) {
		copy_value( otherValue );
	}

	public TitanLogEvent_sourceInfo__list_template( final TitanLogEvent_sourceInfo__list_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanLogEvent_sourceInfo__list_template( final Optional<TitanLogEvent_sourceInfo__list> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list from an unbound optional field.");
		}
	}

	public TitanLogEvent_sourceInfo__list_template( final TitanNull_Type nullValue ) {
		super( template_sel.SPECIFIC_VALUE );
		value_elements = new ArrayList<LocationInfo_template>();
	}

	private void copy_value(final TitanLogEvent_sourceInfo__list other_value) {
		if (!other_value.isBound()) {
			throw new TtcnError("Initialization of a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list with an unbound value.");
		}
		value_elements = new ArrayList<LocationInfo_template>();
		final int otherSize = other_value.valueElements.size();
		for (int elem_count = 0; elem_count < otherSize; elem_count++) {
			if (other_value.constGetAt(elem_count).isBound()) {
				value_elements.add( new LocationInfo_template(other_value.constGetAt(elem_count)) );
			} else {
				value_elements.add( new LocationInfo_template() );
			}
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanLogEvent_sourceInfo__list_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			value_elements = new ArrayList<LocationInfo_template>();
			final int otherSize = other_value.value_elements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new LocationInfo_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new LocationInfo_template() );
				}
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLogEvent_sourceInfo__list_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanLogEvent_sourceInfo__list_template temp = new TitanLogEvent_sourceInfo__list_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		set_selection(other_value);
	}

	public boolean isPresent() {
		return isPresent(false);
	}

	public boolean isPresent(final boolean legacy) {
		if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
			return false;
		}
		return !match_omit(legacy);
	}

	// originally match
	public boolean match(final TitanLogEvent_sourceInfo__list other_value) {
		return match(other_value, false);
	}

	// originally match
	public boolean match(final TitanLogEvent_sourceInfo__list other_value, final boolean legacy) {
		if(!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case OMIT_VALUE:
			return false;
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for(int i = 0 ; i < list_value.size(); i++) {
				if(list_value.get(i).match(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
				}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
	}

	private boolean match_index(final TitanLogEvent_sourceInfo__list value_ptr, final int value_index, final TitanLogEvent_sourceInfo__list_template template_ptr, final int template_index, final boolean legacy) {
		if (value_index >= 0) {
			return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
		} else {
			return template_ptr.value_elements.get(template_index).is_any_or_omit();
		}
	}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
		if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
			return match((TitanLogEvent_sourceInfo__list)otherValue, legacy);
		}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list.");
	}

	public boolean match_omit(final boolean legacy) {
		if (is_ifPresent) {
			return true;
		}
		switch (templateSelection) {
		case OMIT_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			if (legacy) {
				for (int i = 0 ; i < list_value.size(); i++) {
					if (list_value.get(i).match_omit(legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			}
			return false;
		default:
			return false;
		}
	}

	//originally operator=
	public TitanLogEvent_sourceInfo__list_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanLogEvent_sourceInfo__list_template assign( final TitanLogEvent_sourceInfo__list other_value ) {
		cleanUp();
		copy_value(other_value);
		return this;
	}

	//originally operator=
	public TitanLogEvent_sourceInfo__list_template assign( final TitanLogEvent_sourceInfo__list_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

	@Override
	public TitanLogEvent_sourceInfo__list_template assign(final Base_Type otherValue) {
	if (otherValue instanceof TitanLogEvent_sourceInfo__list) {
		return assign((TitanLogEvent_sourceInfo__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list.");
	}

	@Override
	public TitanLogEvent_sourceInfo__list_template assign(final Base_Template otherValue) {
	if (otherValue instanceof TitanLogEvent_sourceInfo__list_template) {
		return assign((TitanLogEvent_sourceInfo__list_template)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent_sourceInfo__list_template.");
	}

	public TitanLogEvent_sourceInfo__list_template assign( final Optional<TitanLogEvent_sourceInfo__list> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		return this;
	}

	@Override
	public void cleanUp() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			value_elements.clear();
			value_elements = null;
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value.clear();
			list_value = null;
			break;
		default:
			break;
		}
		templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
	}

	public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl.valueOf());
	}

	public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final TitanInteger len, final TitanLogEvent_sourceInfo__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
	}

	public TitanLogEvent_sourceInfo__list replace(final int index, final int len, final TitanLogEvent_sourceInfo__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl);
	}

	public TitanLogEvent_sourceInfo__list replace(final TitanInteger index, final TitanInteger len, final TitanLogEvent_sourceInfo__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl);
	}

	public LocationInfo_template getAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: {0}.", index_value ) );
		}

		switch (templateSelection) {
		case SPECIFIC_VALUE:
			if(index_value < value_elements.size()) {

				break;
			}
			// no break
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case UNINITIALIZED_TEMPLATE:
			setSize(index_value + 1);
			break;
		default:
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		return value_elements.get(index_value);
	}

	public LocationInfo_template getAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}

		return getAt(index_value.getInt());
	}

	public LocationInfo_template constGetAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index: {0}.", index_value ) );
		}

		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}

		if (index_value >= value_elements.size()) {
			throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
		}

		return value_elements.get(index_value);
	}

	public LocationInfo_template constGetAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}

		return constGetAt(index_value.getInt());
	}

	private int get_length_for_concat(final AtomicBoolean is_any_value) {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return value_elements.size();
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				if (templateSelection == template_sel.ANY_VALUE) {
					// ? => { * }
					is_any_value.set( true );
					return 1;
				}
				throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
			case RANGE_LENGTH_RESTRICTION:
				if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
					throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
				}
				// else fall through (range length restriction is allowed if the minimum
				// and maximum value are the same)
			case SINGLE_LENGTH_RESTRICTION:
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
			}
		default:
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}
	}

	private int get_length_for_concat(final TitanLogEvent_sourceInfo__list operand) {
		operand.mustBound("Operand of record of template concatenation is an unbound value.");
		return operand.valueElements.size();
	}


	private int get_length_for_concat(final template_sel operand) {
		if (operand == template_sel.ANY_VALUE) {
			// ? => { * }
			return 1;
		}
		throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
	}

			//TODO: simplify, just use value_elements.add()
	private void concat(final AtomicInteger pos, final TitanLogEvent_sourceInfo__list_template operand) {
		// all errors should have already been caught by the operand's
		// get_length_for_concat() call;
		// the result template (this) should already be set to SPECIFIC_VALUE and
		// single_value.value_elements should already be allocated
		switch (operand.templateSelection) {
		case SPECIFIC_VALUE:
			for (int i = 0; i < operand.value_elements.size(); ++i) {
				value_elements.set( pos.get() + i, new LocationInfo_template(operand.value_elements.get(i)) );
			}
			pos.addAndGet( operand.value_elements.size() );
			break;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (operand.length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				// ? => { * }
				value_elements.set( pos.get(), new LocationInfo_template( template_sel.ANY_OR_OMIT ) );
				pos.incrementAndGet();
				break;
			case RANGE_LENGTH_RESTRICTION:
			case SINGLE_LENGTH_RESTRICTION: {
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
				for (int i = 0; i < N; ++i) {
					value_elements.set( pos.get() + i, new LocationInfo_template( template_sel.ANY_VALUE ) );
				}
				pos.addAndGet( N );
				break; }
			}
		default:
			break;
		}
	}

	public void setSize(final int new_size) {
		if (new_size < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		final template_sel old_selection = templateSelection;
		if (old_selection != template_sel.SPECIFIC_VALUE) {
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = null;
		}
		if (value_elements == null) {
			value_elements = new ArrayList<LocationInfo_template>();
		}
		if (new_size > value_elements.size()) {
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new LocationInfo_template(template_sel.ANY_VALUE) );
				}
			} else {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new LocationInfo_template() );
				}
			}
		} else if (new_size < value_elements.size()) {
			final int oldSize = value_elements.size();
			for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
				value_elements.remove( new_size );
			}
		}
	}

	public TitanInteger sizeOf() {
		return sizeOf(true);
	}

	public TitanInteger lengthOf() {
		return sizeOf(false);
	}

	public TitanInteger sizeOf(final boolean is_size) {
		final String op_name = is_size ? "size" : "length";
		if (is_ifPresent) {
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list which has an ifpresent attribute.", op_name ) );
		}
		int min_size;
		boolean has_any_or_none;
		switch (templateSelection)
		{
		case SPECIFIC_VALUE: {
			min_size = 0;
			has_any_or_none = false;
			int elem_count = value_elements.size();
			if (!is_size) {
				while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
					elem_count--;
				}
			}
			for (int i=0; i<elem_count; i++)
			{
			switch (value_elements.get(i).get_selection())
				{
				case OMIT_VALUE:
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing omit element.", op_name ) );
				case ANY_OR_OMIT:
					has_any_or_none = true;
					break;
				default:
					min_size++;
					break;
				}
			}
		} break;
		case OMIT_VALUE:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing omit value.", op_name ) );
		case ANY_VALUE:
		case ANY_OR_OMIT:
			min_size = 0;
			has_any_or_none = true;
			break;
		case VALUE_LIST:
		{
			if (list_value.size()<1) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing an empty list.", op_name ) );
			}
			final int item_size = list_value.get(0).sizeOf(is_size).getInt();
			for (int i = 1; i < list_value.size(); i++) {
				if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing a value list with different sizes.", op_name ) );
				}
			}
			min_size = item_size;
			has_any_or_none = false;
			break;
		}
		case COMPLEMENTED_LIST:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list containing complemented list.", op_name ) );
		default:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type TitanLogEvent_sourceInfo__list.", op_name ) );
		}
		return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "LocationInfo_template"));
	}

	public TitanInteger n_elem() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return new TitanInteger(value_elements.size());
		case COMPLEMENTED_LIST:
			throw new TtcnError("Performing n_elem() operation on a template of type TitanLogEvent_sourceInfo__list containing complemented list.");
		case UNINITIALIZED_TEMPLATE:
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case VALUE_LIST:
		case VALUE_RANGE:
		case STRING_PATTERN:
		case SUPERSET_MATCH:
		case SUBSET_MATCH:
		case DECODE_MATCH:
			break;
		}
		throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type TitanLogEvent_sourceInfo__list.");
	}

	private boolean matchv(final TitanLogEvent_sourceInfo__list other_value, final boolean legacy) {
		if (!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case OMIT_VALUE:
			return false;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for (int list_count = 0; list_count < list_value.size(); list_count++) {
				if (list_value.get(list_count).matchv(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
		}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type TitanLogEvent_sourceInfo__list.");
		}
	}

	@Override
	public boolean isValue() {
		if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
			return false;
		}
		for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
			if (!value_elements.get(elem_count).isValue()) {
				return false;
			}
		}
		return true;
	}

	public void setType(final template_sel template_type, final int list_length) {
		cleanUp();
		switch (template_type) {
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLogEvent_sourceInfo__list_template>( list_length );
			for (int list_count = 0; list_count < list_length; list_count++) {
				list_value.add( new TitanLogEvent_sourceInfo__list_template() );
			}
			break;
		default:
			throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		set_selection(template_type);
	}

		public TitanLogEvent_sourceInfo__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			return list_value.get(list_index);
		}

	public TitanLogEvent_sourceInfo__list_template get_list_item(final int list_index) {
		if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
			throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		if (list_index < 0) {
			throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list using a negative index ({0}).", list_index ) );
		}
		if (list_index >= list_value.size()) {
			throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
		}
		return list_value.get( list_index );
	}

		public TitanLogEvent_sourceInfo__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
			final TitanLogEvent_sourceInfo__list ret_val = new TitanLogEvent_sourceInfo__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public TitanLogEvent_sourceInfo__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

	public void log_match(final TitanLogEvent_sourceInfo__list match_value) {
		log_match(match_value, false);
	}

	@Override
	public void log_match(final Base_Type match_value, final boolean legacy) {
		if (match_value instanceof TitanLogEvent_sourceInfo__list) {
			log_match((TitanLogEvent_sourceInfo__list)match_value, legacy);
			return;
		}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
	}

	public void log_match(final TitanLogEvent_sourceInfo__list match_value, final boolean legacy) {
		if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
			if(match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
			} else {
				if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
						TTCN_Logger.log_logmatch_info("[%d]", elem_count);
							value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					}
					log_match_length(value_elements.size());
				} else {
					TTCN_Logger.print_logmatch_buffer();
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
			return;
		}
		if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
			TTCN_Logger.log_event_str("{ ");
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (elem_count > 0) {
					TTCN_Logger.log_event_str(", ");
				}
				value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
			}
			TTCN_Logger.log_event_str(" }");
			log_match_length(value_elements.size());
		} else {
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if ( match(match_value, legacy) ) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}
	}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
				}
				value_elements = new ArrayList<LocationInfo_template>(temp);
				for (int i = 0; i < temp; i++) {
					final LocationInfo_template temp2 = new LocationInfo_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLogEvent_sourceInfo__list_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLogEvent_sourceInfo__list_template temp2 = new TitanLogEvent_sourceInfo__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.TitanLogEvent.sourceInfo_list.");
			}
		}

	@Override
	public boolean get_istemplate_kind(final String type) {
		if ("AnyElement".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
			return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
					return true;
				}
			}
			return false;
		} else if ("AnyElementsOrNone".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
					return true;
				}
			}
			return false;
		} else if ("permutation".equals(type)) {
			return get_number_of_permutations() != 0;
		} else if ("length".equals(type)) {
			return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
		} else {
			return super.get_istemplate_kind(type);
		}
	}
}
public static void TitanLogEvent_sourceInfo__list_encoder(final TitanLogEvent_sourceInfo__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent.sourceInfo_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLogEvent_sourceInfo__list_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLogEvent_sourceInfo__list_decoder( final TitanOctetString input_stream, final TitanLogEvent_sourceInfo__list output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent.sourceInfo_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLogEvent_sourceInfo__list_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class VerdictType extends Base_Type {
		private final Verdict fromVerdict; //Referenced_Type
		private final Verdict toVerdict; //Referenced_Type
		private final Optional<TitanCharString> verdictReason; //CharString_Type

		public VerdictType() {
			fromVerdict = new Verdict();
			toVerdict = new Verdict();
			verdictReason = new Optional<TitanCharString>(TitanCharString.class);
		}

		public VerdictType( final Verdict aFromVerdict, final Verdict aToVerdict, final Optional<TitanCharString> aVerdictReason ) {
			fromVerdict = new Verdict( aFromVerdict );
			toVerdict = new Verdict( aToVerdict );
			verdictReason = new Optional<TitanCharString>(TitanCharString.class);
			this.verdictReason.assign( aVerdictReason );
		}

		public VerdictType( final VerdictType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.VerdictType.");
			}
			fromVerdict = new Verdict();
			toVerdict = new Verdict();
			verdictReason = new Optional<TitanCharString>(TitanCharString.class);
			assign( aOtherValue );
		}
		public VerdictType assign(final VerdictType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.VerdictType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getFromVerdict().isBound() ) {
					this.fromVerdict.assign( aOtherValue.getFromVerdict() );
				} else {
					this.fromVerdict.cleanUp();
				}
				if ( aOtherValue.getToVerdict().isBound() ) {
					this.toVerdict.assign( aOtherValue.getToVerdict() );
				} else {
					this.toVerdict.cleanUp();
				}
				if ( aOtherValue.getVerdictReason().isBound() ) {
					this.verdictReason.assign( aOtherValue.getVerdictReason() );
				} else {
					this.verdictReason.cleanUp();
				}
			}

			return this;
		}

		@Override
		public VerdictType assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictType ) {
				return assign((VerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictType", otherValue));
		}

		public void cleanUp() {
			fromVerdict.cleanUp();
			toVerdict.cleanUp();
			verdictReason.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( fromVerdict.isBound() ) { return true; }
			if ( toVerdict.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(verdictReason.get_selection()) || verdictReason.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !fromVerdict.isValue() ) { return false; }
			if ( !toVerdict.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(verdictReason.get_selection()) && !verdictReason.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final VerdictType aOtherValue ) {
			if ( !this.fromVerdict.operatorEquals( aOtherValue.fromVerdict ) ) { return false; }
			if ( !this.toVerdict.operatorEquals( aOtherValue.toVerdict ) ) { return false; }
			if ( !this.verdictReason.operatorEquals( aOtherValue.verdictReason ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof VerdictType ) {
				return operatorEquals((VerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.VerdictType", otherValue));
		}

		public Verdict getFromVerdict() {
			return fromVerdict;
		}

		public Verdict constGetFromVerdict() {
			return fromVerdict;
		}

		public Verdict getToVerdict() {
			return toVerdict;
		}

		public Verdict constGetToVerdict() {
			return toVerdict;
		}

		public Optional<TitanCharString> getVerdictReason() {
			return verdictReason;
		}

		public Optional<TitanCharString> constGetVerdictReason() {
			return verdictReason;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			if (verdictReason.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" fromVerdict := ");
			fromVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" toVerdict := ");
			toVerdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" verdictReason := ");
			verdictReason.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (fromVerdict.isBound()) {
				fromVerdict.set_implicit_omit();
			}
			if (toVerdict.isBound()) {
				toVerdict.set_implicit_omit();
			}
			if (verdictReason.isBound()) {
				verdictReason.set_implicit_omit();
			} else {
				verdictReason.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			fromVerdict.encode_text(text_buf);
			toVerdict.encode_text(text_buf);
			verdictReason.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			fromVerdict.decode_text(text_buf);
			toVerdict.decode_text(text_buf);
			verdictReason.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class VerdictType_template extends Base_Template {

	private Verdict_template fromVerdict; //Referenced_Type
	private Verdict_template toVerdict; //Referenced_Type
	private TitanCharString_template verdictReason; //CharString_Type
	//originally value_list/list_value
	List<VerdictType_template> list_value;

	public Verdict_template getFromVerdict() {
		setSpecific();
		return fromVerdict;
	}

	public Verdict_template constGetFromVerdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field fromVerdict of a non-specific template of type @TitanLoggerApi.VerdictType.");
		}
		return fromVerdict;
	}

	public Verdict_template getToVerdict() {
		setSpecific();
		return toVerdict;
	}

	public Verdict_template constGetToVerdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field toVerdict of a non-specific template of type @TitanLoggerApi.VerdictType.");
		}
		return toVerdict;
	}

	public TitanCharString_template getVerdictReason() {
		setSpecific();
		return verdictReason;
	}

	public TitanCharString_template constGetVerdictReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field verdictReason of a non-specific template of type @TitanLoggerApi.VerdictType.");
		}
		return verdictReason;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			fromVerdict = new Verdict_template();
			toVerdict = new Verdict_template();
			verdictReason = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				fromVerdict.assign(template_sel.ANY_VALUE);
				toVerdict.assign(template_sel.ANY_VALUE);
				verdictReason.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public VerdictType_template() {
	}

	public VerdictType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public VerdictType_template( final VerdictType otherValue ) {
		copyValue(otherValue);
	}

	public VerdictType_template( final VerdictType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public VerdictType_template( final Optional<VerdictType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.VerdictType from an unbound optional field.");
		}
	}

	//originally operator=
	public VerdictType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public VerdictType_template assign( final VerdictType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public VerdictType_template assign( final VerdictType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public VerdictType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof VerdictType) {
				return assign((VerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictType' can not be cast to {1}", otherValue));
		}

		@Override
		public VerdictType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof VerdictType_template) {
				return assign((VerdictType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `VerdictType' can not be cast to {1}_template", otherValue));
		}

	public VerdictType_template assign( final Optional<VerdictType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.VerdictType.");
		}
		return this;
	}

	private void copyValue(final VerdictType other_value) {
		if (other_value.getFromVerdict().isBound()) {
			getFromVerdict().assign(other_value.getFromVerdict());
		} else {
			getFromVerdict().cleanUp();
		}
		if (other_value.getToVerdict().isBound()) {
			getToVerdict().assign(other_value.getToVerdict());
		} else {
			getToVerdict().cleanUp();
		}
		if (other_value.getVerdictReason().isBound()) {
			if (other_value.getVerdictReason().isPresent()) {
				getVerdictReason().assign(other_value.getVerdictReason().get());
			} else {
				getVerdictReason().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getVerdictReason().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final VerdictType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFromVerdict().get_selection()) {
				getFromVerdict().cleanUp();
			} else {
				getFromVerdict().assign(other_value.getFromVerdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getToVerdict().get_selection()) {
				getToVerdict().cleanUp();
			} else {
				getToVerdict().assign(other_value.getToVerdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getVerdictReason().get_selection()) {
				getVerdictReason().cleanUp();
			} else {
				getVerdictReason().assign(other_value.getVerdictReason());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<VerdictType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final VerdictType_template temp = new VerdictType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.VerdictType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public VerdictType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.VerdictType.");
			}
			final VerdictType ret_val = new VerdictType();
			 if (fromVerdict.isBound()) {
				ret_val.fromVerdict.assign(fromVerdict.valueOf());
			}
			 if (toVerdict.isBound()) {
				ret_val.toVerdict.assign(toVerdict.valueOf());
			}
			if (verdictReason.isOmit()) {
				ret_val.verdictReason.assign(template_sel.OMIT_VALUE);
			} else if (verdictReason.isBound()) {
				ret_val.verdictReason.assign(verdictReason.valueOf());
			}
			return ret_val;
		}

		public VerdictType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.VerdictType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.VerdictType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.VerdictType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<VerdictType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new VerdictType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (fromVerdict.isBound()) {
				return true;
			}
			if (toVerdict.isBound()) {
				return true;
			}
			if (verdictReason.isOmit() || verdictReason.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!fromVerdict.isValue()) {
				return false;
			}
			if (!toVerdict.isValue()) {
				return false;
			}
			if (!verdictReason.isOmit() && !verdictReason.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final VerdictType other_value) {
			return match(other_value, false);
		}

		public boolean match(final VerdictType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getFromVerdict().isBound()) {
					return false;
				}
				if(!fromVerdict.match(other_value.getFromVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getToVerdict().isBound()) {
					return false;
				}
				if(!toVerdict.match(other_value.getToVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getVerdictReason().isBound()) {
					return false;
				}
				if((other_value.getVerdictReason().isPresent() ? !verdictReason.match(other_value.getVerdictReason().get(), legacy) : !verdictReason.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.VerdictType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof VerdictType) {
		return match((VerdictType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type VerdictType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				if (verdictReason.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.VerdictType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.VerdictType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" fromVerdict := ");
				fromVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" toVerdict := ");
				toVerdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" verdictReason := ");
				verdictReason.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final VerdictType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof VerdictType) {
				log_match((VerdictType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.VerdictType.");
		}

		public void log_match(final VerdictType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !fromVerdict.match(match_value.constGetFromVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".fromVerdict");
							fromVerdict.log_match(match_value.constGetFromVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !toVerdict.match(match_value.constGetToVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".toVerdict");
							toVerdict.log_match(match_value.constGetToVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetVerdictReason().isPresent()) {
							if( !verdictReason.match(match_value.constGetVerdictReason().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".verdictReason");
								verdictReason.log_match(match_value.constGetVerdictReason().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!verdictReason.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".verdictReason := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								verdictReason.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ fromVerdict := ");
				fromVerdict.log_match(match_value.constGetFromVerdict(), legacy);
				TTCN_Logger.log_event_str("{ toVerdict := ");
				toVerdict.log_match(match_value.constGetToVerdict(), legacy);
				TTCN_Logger.log_event_str("{ verdictReason := ");
				verdictReason.log_match(match_value.constGetVerdictReason(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				fromVerdict.encode_text(text_buf);
				toVerdict.encode_text(text_buf);
				verdictReason.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.VerdictType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				fromVerdict = new Verdict_template();
				fromVerdict.decode_text(text_buf);
				toVerdict = new Verdict_template();
				toVerdict.decode_text(text_buf);
				verdictReason = new TitanCharString_template();
				verdictReason.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<VerdictType_template>(size);
				for(int i = 0; i < size; i++) {
					final VerdictType_template temp = new VerdictType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.VerdictType.");
			}
		}
}
public static void VerdictType_encoder(final VerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictType_decoder( final TitanOctetString input_stream, final VerdictType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_functionEvent_encoder(final FunctionEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_functionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_functionEvent_decoder( final TitanOctetString input_stream, final FunctionEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_functionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_matchingEvent_encoder(final MatchingEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_matchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_matchingEvent_decoder( final TitanOctetString input_stream, final MatchingEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_matchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void DefaultOp_id_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultOp_id_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultOp_id_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultOp_id_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TestcaseType_name_encoder(final QualifiedName input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseType_name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseType_name_decoder( final TitanOctetString input_stream, final QualifiedName output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseType_name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Port__State_operation extends Base_Type {
public enum enum_type {
started (0),
stopped (1),
halted (2),
UNKNOWN_VALUE(3),
UNBOUND_VALUE(4);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return started;
case 1:  return stopped;
case 2:  return halted;
case 3:  return UNKNOWN_VALUE;
case 4:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Port__State_operation() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Port__State_operation(final Port__State_operation otherValue) {
enum_value = otherValue.enum_value;
}

public Port__State_operation(final Port__State_operation.enum_type otherValue ) {
enum_value = otherValue;
}

public Port__State_operation(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__State_operation' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Port__State_operation assign(final Port__State_operation otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Port__State_operation assign(final Base_Type otherValue){
if( otherValue instanceof Port__State_operation ) {
return assign((Port__State_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation' can not be cast to {1}", otherValue));
}

//originally operator=
public Port__State_operation assign(final Port__State_operation.enum_type otherValue){
return assign( new Port__State_operation(otherValue) );
}

//originally operator=
public Port__State_operation assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__State_operation'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Port__State_operation otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Port__State_operation) {
return operatorEquals( (Port__State_operation) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_State.operation.");
}
}

//originally operator==
public boolean operatorEquals(final Port__State_operation.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Port__State_operation otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Port__State_operation.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Port__State_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Port__State_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__State_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__State_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Port__State_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Port__State_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__State_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__State_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__State_operation. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Port__State_operation.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Port__State_operation enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("started".equals(strPar)) {
return enum_type.started;
}
if ("stopped".equals(strPar)) {
return enum_type.stopped;
}
if ("halted".equals(strPar)) {
return enum_type.halted;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_State.operation.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_State.operation.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Port__State_operation_template extends Base_Template {
// single_value
private Port__State_operation.enum_type single_value;
// value_list part
private ArrayList<Port__State_operation_template> value_list;

private void copy_template(final Port__State_operation_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Port__State_operation_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Port__State_operation_template temp = new Port__State_operation_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__State_operation.");
}
}

public Port__State_operation_template() {
}

public Port__State_operation_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Port__State_operation_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Port__State_operation.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Port__State_operation with unknown numeric value "+ otherValue +".");
}
single_value = Port__State_operation.enum_type.getValue(otherValue);
}

public Port__State_operation_template(final Port__State_operation otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Port__State_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Port__State_operation. ");
}
single_value = otherValue.enum_value;
}

public Port__State_operation_template(final Port__State_operation_template otherValue) {
copy_template(otherValue);
}

public Port__State_operation_template(final Port__State_operation.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Port__State_operation.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Port__State_operation_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Port__State_operation_template assign(final int otherValue) {
if (!Port__State_operation.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__State_operation.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Port__State_operation_template assign(final Port__State_operation.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Port__State_operation_template assign(final Port__State_operation_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Port__State_operation_template assign(final Port__State_operation otherValue){
if (otherValue.enum_value == Port__State_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Port__State_operation to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Port__State_operation_template assign(final Base_Type otherValue){
if( otherValue instanceof Port__State_operation ) {
return assign((Port__State_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation' can not be cast to {1}", otherValue));
}

@Override
public Port__State_operation_template assign(final Base_Template otherValue){
if( otherValue instanceof Port__State_operation_template ) {
return assign((Port__State_operation_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Port__State_operation.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Port__State_operation.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__State_operation.");
}
}

// originally match
public boolean match(final Port__State_operation otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Port__State_operation otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Port__State_operation ) {
return match((Port__State_operation) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State_operation' can not be cast to {1}", otherValue));
}

public Port__State_operation valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__State_operation.");
}
return new Port__State_operation(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__State_operation.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Port__State_operation_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Port__State_operation_template());
}
}

public Port__State_operation_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__State_operation.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Port__State_operation.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Port__State_operation.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Port__State_operation.enum2str(single_value), Port__State_operation.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Port__State_operation) {
log_match((Port__State_operation)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_State.operation.");
}
public void log_match(final Port__State_operation match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_State.operation.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Port__State_operation.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_State.operation.", temp));
}
single_value = Port__State_operation.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Port__State_operation_template>(size);
for(int i = 0; i < size; i++) {
final Port__State_operation_template temp = new Port__State_operation_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_State.operation.");
}
}
}
public static void Port__State_operation_encoder(final Port__State_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__State_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__State_operation_decoder( final TitanOctetString input_stream, final Port__State_operation output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__State_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Setstate_info_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Setstate_info_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Setstate_info_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Setstate_info_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_executorEvent_encoder(final ExecutorEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_executorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_executorEvent_decoder( final TitanOctetString input_stream, final ExecutorEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_executorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_controlpartFinish_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_controlpartFinish_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_controlpartFinish_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_controlpartFinish_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorUnqualified_port___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorUnqualified_port___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorUnqualified_port___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorUnqualified_port___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LocationInfo_line_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LocationInfo_line_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LocationInfo_line_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LocationInfo_line_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Port__oper extends Base_Type {
public enum enum_type {
call__op (0),
exception__op (1),
reply__op (2),
UNKNOWN_VALUE(3),
UNBOUND_VALUE(4);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return call__op;
case 1:  return exception__op;
case 2:  return reply__op;
case 3:  return UNKNOWN_VALUE;
case 4:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Port__oper() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Port__oper(final Port__oper otherValue) {
enum_value = otherValue.enum_value;
}

public Port__oper(final Port__oper.enum_type otherValue ) {
enum_value = otherValue;
}

public Port__oper(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__oper' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Port__oper assign(final Port__oper otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Port__oper assign(final Base_Type otherValue){
if( otherValue instanceof Port__oper ) {
return assign((Port__oper) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper' can not be cast to {1}", otherValue));
}

//originally operator=
public Port__oper assign(final Port__oper.enum_type otherValue){
return assign( new Port__oper(otherValue) );
}

//originally operator=
public Port__oper assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__oper'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Port__oper otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Port__oper) {
return operatorEquals( (Port__oper) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_oper.");
}
}

//originally operator==
public boolean operatorEquals(final Port__oper.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Port__oper otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Port__oper.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Port__oper.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Port__oper otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__oper.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__oper otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Port__oper.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Port__oper otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__oper.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__oper otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__oper. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__oper. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Port__oper.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Port__oper enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("call__op".equals(strPar) || "call_op".equals(strPar)) {
return enum_type.call__op;
}
if ("exception__op".equals(strPar) || "exception_op".equals(strPar)) {
return enum_type.exception__op;
}
if ("reply__op".equals(strPar) || "reply_op".equals(strPar)) {
return enum_type.reply__op;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_oper.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_oper.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Port__oper_template extends Base_Template {
// single_value
private Port__oper.enum_type single_value;
// value_list part
private ArrayList<Port__oper_template> value_list;

private void copy_template(final Port__oper_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Port__oper_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Port__oper_template temp = new Port__oper_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__oper.");
}
}

public Port__oper_template() {
}

public Port__oper_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Port__oper_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Port__oper.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Port__oper with unknown numeric value "+ otherValue +".");
}
single_value = Port__oper.enum_type.getValue(otherValue);
}

public Port__oper_template(final Port__oper otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Port__oper.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Port__oper. ");
}
single_value = otherValue.enum_value;
}

public Port__oper_template(final Port__oper_template otherValue) {
copy_template(otherValue);
}

public Port__oper_template(final Port__oper.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Port__oper.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Port__oper_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Port__oper_template assign(final int otherValue) {
if (!Port__oper.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__oper.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Port__oper_template assign(final Port__oper.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Port__oper_template assign(final Port__oper_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Port__oper_template assign(final Port__oper otherValue){
if (otherValue.enum_value == Port__oper.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Port__oper to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Port__oper_template assign(final Base_Type otherValue){
if( otherValue instanceof Port__oper ) {
return assign((Port__oper) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper' can not be cast to {1}", otherValue));
}

@Override
public Port__oper_template assign(final Base_Template otherValue){
if( otherValue instanceof Port__oper_template ) {
return assign((Port__oper_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Port__oper.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Port__oper.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__oper.");
}
}

// originally match
public boolean match(final Port__oper otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Port__oper otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Port__oper ) {
return match((Port__oper) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__oper' can not be cast to {1}", otherValue));
}

public Port__oper valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__oper.");
}
return new Port__oper(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__oper.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Port__oper_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Port__oper_template());
}
}

public Port__oper_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__oper.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Port__oper.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Port__oper.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Port__oper.enum2str(single_value), Port__oper.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Port__oper) {
log_match((Port__oper)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_oper.");
}
public void log_match(final Port__oper match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_oper.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Port__oper.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_oper.", temp));
}
single_value = Port__oper.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Port__oper_template>(size);
for(int i = 0; i < size; i++) {
final Port__oper_template temp = new Port__oper_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_oper.");
}
}
}
public static void Port__oper_encoder(final Port__oper input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__oper_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__oper_decoder( final TitanOctetString input_stream, final Port__oper output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_oper' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__oper_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelEvent_choice_parallelPort_encoder(final ParPort input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelEvent_choice_parallelPort_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelEvent_choice_parallelPort_decoder( final TitanOctetString input_stream, final ParPort output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelEvent_choice_parallelPort_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ComponentIDType_id_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ComponentIDType_id_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ComponentIDType_id_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ComponentIDType_id_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void DefaultOp_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultOp_name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultOp_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultOp_name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingSuccessType_port__type_encoder(final PortType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingSuccessType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingSuccessType_port__type_decoder( final TitanOctetString input_stream, final PortType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingSuccessType_port__type_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParPort_dstPort_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParPort_dstPort_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParPort_dstPort_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParPort_dstPort_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingDoneType_return__type_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingDoneType_return__type_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingDoneType_return__type_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingDoneType_return__type_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void WarningEvent_text_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(WarningEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger WarningEvent_text_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(WarningEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_portQueue_encoder(final Port__Queue input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_portQueue_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_portQueue_decoder( final TitanOctetString input_stream, final Port__Queue output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_portQueue_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TimestampType extends Base_Type {
		private final TitanInteger seconds; //Integer_Type
		private final TitanInteger microSeconds; //Integer_Type

		public TimestampType() {
			seconds = new TitanInteger();
			microSeconds = new TitanInteger();
		}

		public TimestampType( final TitanInteger aSeconds, final TitanInteger aMicroSeconds ) {
			seconds = new TitanInteger( aSeconds );
			microSeconds = new TitanInteger( aMicroSeconds );
		}

		public TimestampType( final TimestampType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimestampType.");
			}
			seconds = new TitanInteger();
			microSeconds = new TitanInteger();
			assign( aOtherValue );
		}
		public TimestampType assign(final TimestampType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimestampType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getSeconds().isBound() ) {
					this.seconds.assign( aOtherValue.getSeconds() );
				} else {
					this.seconds.cleanUp();
				}
				if ( aOtherValue.getMicroSeconds().isBound() ) {
					this.microSeconds.assign( aOtherValue.getMicroSeconds() );
				} else {
					this.microSeconds.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimestampType assign(final Base_Type otherValue) {
			if (otherValue instanceof TimestampType ) {
				return assign((TimestampType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimestampType", otherValue));
		}

		public void cleanUp() {
			seconds.cleanUp();
			microSeconds.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( seconds.isBound() ) { return true; }
			if ( microSeconds.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !seconds.isValue() ) { return false; }
			if ( !microSeconds.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimestampType aOtherValue ) {
			if ( !this.seconds.operatorEquals( aOtherValue.seconds ) ) { return false; }
			if ( !this.microSeconds.operatorEquals( aOtherValue.microSeconds ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimestampType ) {
				return operatorEquals((TimestampType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimestampType", otherValue));
		}

		public TitanInteger getSeconds() {
			return seconds;
		}

		public TitanInteger constGetSeconds() {
			return seconds;
		}

		public TitanInteger getMicroSeconds() {
			return microSeconds;
		}

		public TitanInteger constGetMicroSeconds() {
			return microSeconds;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" seconds := ");
			seconds.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" microSeconds := ");
			microSeconds.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (seconds.isBound()) {
				seconds.set_implicit_omit();
			}
			if (microSeconds.isBound()) {
				microSeconds.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			seconds.encode_text(text_buf);
			microSeconds.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			seconds.decode_text(text_buf);
			microSeconds.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TimestampType_template extends Base_Template {

	private TitanInteger_template seconds; //Integer_Type
	private TitanInteger_template microSeconds; //Integer_Type
	//originally value_list/list_value
	List<TimestampType_template> list_value;

	public TitanInteger_template getSeconds() {
		setSpecific();
		return seconds;
	}

	public TitanInteger_template constGetSeconds() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field seconds of a non-specific template of type @TitanLoggerApi.TimestampType.");
		}
		return seconds;
	}

	public TitanInteger_template getMicroSeconds() {
		setSpecific();
		return microSeconds;
	}

	public TitanInteger_template constGetMicroSeconds() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field microSeconds of a non-specific template of type @TitanLoggerApi.TimestampType.");
		}
		return microSeconds;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			seconds = new TitanInteger_template();
			microSeconds = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				seconds.assign(template_sel.ANY_VALUE);
				microSeconds.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TimestampType_template() {
	}

	public TimestampType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TimestampType_template( final TimestampType otherValue ) {
		copyValue(otherValue);
	}

	public TimestampType_template( final TimestampType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TimestampType_template( final Optional<TimestampType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TimestampType from an unbound optional field.");
		}
	}

	//originally operator=
	public TimestampType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TimestampType_template assign( final TimestampType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TimestampType_template assign( final TimestampType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TimestampType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimestampType) {
				return assign((TimestampType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimestampType' can not be cast to {1}", otherValue));
		}

		@Override
		public TimestampType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimestampType_template) {
				return assign((TimestampType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimestampType' can not be cast to {1}_template", otherValue));
		}

	public TimestampType_template assign( final Optional<TimestampType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimestampType.");
		}
		return this;
	}

	private void copyValue(final TimestampType other_value) {
		if (other_value.getSeconds().isBound()) {
			getSeconds().assign(other_value.getSeconds());
		} else {
			getSeconds().cleanUp();
		}
		if (other_value.getMicroSeconds().isBound()) {
			getMicroSeconds().assign(other_value.getMicroSeconds());
		} else {
			getMicroSeconds().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TimestampType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSeconds().get_selection()) {
				getSeconds().cleanUp();
			} else {
				getSeconds().assign(other_value.getSeconds());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getMicroSeconds().get_selection()) {
				getMicroSeconds().cleanUp();
			} else {
				getMicroSeconds().assign(other_value.getMicroSeconds());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TimestampType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TimestampType_template temp = new TimestampType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimestampType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimestampType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimestampType.");
			}
			final TimestampType ret_val = new TimestampType();
			 if (seconds.isBound()) {
				ret_val.seconds.assign(seconds.valueOf());
			}
			 if (microSeconds.isBound()) {
				ret_val.microSeconds.assign(microSeconds.valueOf());
			}
			return ret_val;
		}

		public TimestampType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimestampType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimestampType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimestampType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimestampType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimestampType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (seconds.isBound()) {
				return true;
			}
			if (microSeconds.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!seconds.isValue()) {
				return false;
			}
			if (!microSeconds.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimestampType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimestampType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getSeconds().isBound()) {
					return false;
				}
				if(!seconds.match(other_value.getSeconds(), legacy)) {
					return false;
				}
				if(!other_value.getMicroSeconds().isBound()) {
					return false;
				}
				if(!microSeconds.match(other_value.getMicroSeconds(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimestampType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TimestampType) {
		return match((TimestampType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TimestampType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimestampType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimestampType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" seconds := ");
				seconds.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" microSeconds := ");
				microSeconds.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimestampType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimestampType) {
				log_match((TimestampType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimestampType.");
		}

		public void log_match(final TimestampType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !seconds.match(match_value.constGetSeconds(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".seconds");
							seconds.log_match(match_value.constGetSeconds(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !microSeconds.match(match_value.constGetMicroSeconds(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".microSeconds");
							microSeconds.log_match(match_value.constGetMicroSeconds(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ seconds := ");
				seconds.log_match(match_value.constGetSeconds(), legacy);
				TTCN_Logger.log_event_str("{ microSeconds := ");
				microSeconds.log_match(match_value.constGetMicroSeconds(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				seconds.encode_text(text_buf);
				microSeconds.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimestampType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				seconds = new TitanInteger_template();
				seconds.decode_text(text_buf);
				microSeconds = new TitanInteger_template();
				microSeconds.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimestampType_template>(size);
				for(int i = 0; i < size; i++) {
					final TimestampType_template temp = new TimestampType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimestampType.");
			}
		}
}
public static void TimestampType_encoder(final TimestampType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimestampType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimestampType_decoder( final TitanOctetString input_stream, final TimestampType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimestampType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Setstate extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final TitanCharString state; //CharString_Type
		private final TitanCharString info; //CharString_Type

		public Setstate() {
			port__name = new TitanCharString();
			state = new TitanCharString();
			info = new TitanCharString();
		}

		public Setstate( final TitanCharString aPort__name, final TitanCharString aState, final TitanCharString aInfo ) {
			port__name = new TitanCharString( aPort__name );
			state = new TitanCharString( aState );
			info = new TitanCharString( aInfo );
		}

		public Setstate( final Setstate aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Setstate.");
			}
			port__name = new TitanCharString();
			state = new TitanCharString();
			info = new TitanCharString();
			assign( aOtherValue );
		}
		public Setstate assign(final Setstate aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Setstate");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getState().isBound() ) {
					this.state.assign( aOtherValue.getState() );
				} else {
					this.state.cleanUp();
				}
				if ( aOtherValue.getInfo().isBound() ) {
					this.info.assign( aOtherValue.getInfo() );
				} else {
					this.info.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Setstate assign(final Base_Type otherValue) {
			if (otherValue instanceof Setstate ) {
				return assign((Setstate) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Setstate", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			state.cleanUp();
			info.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( state.isBound() ) { return true; }
			if ( info.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !state.isValue() ) { return false; }
			if ( !info.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Setstate aOtherValue ) {
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.state.operatorEquals( aOtherValue.state ) ) { return false; }
			if ( !this.info.operatorEquals( aOtherValue.info ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Setstate ) {
				return operatorEquals((Setstate) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Setstate", otherValue));
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanCharString getState() {
			return state;
		}

		public TitanCharString constGetState() {
			return state;
		}

		public TitanCharString getInfo() {
			return info;
		}

		public TitanCharString constGetInfo() {
			return info;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" state := ");
			state.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" info := ");
			info.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (state.isBound()) {
				state.set_implicit_omit();
			}
			if (info.isBound()) {
				info.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			state.encode_text(text_buf);
			info.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			state.decode_text(text_buf);
			info.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Setstate_template extends Base_Template {

	private TitanCharString_template port__name; //CharString_Type
	private TitanCharString_template state; //CharString_Type
	private TitanCharString_template info; //CharString_Type
	//originally value_list/list_value
	List<Setstate_template> list_value;

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Setstate.");
		}
		return port__name;
	}

	public TitanCharString_template getState() {
		setSpecific();
		return state;
	}

	public TitanCharString_template constGetState() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field state of a non-specific template of type @TitanLoggerApi.Setstate.");
		}
		return state;
	}

	public TitanCharString_template getInfo() {
		setSpecific();
		return info;
	}

	public TitanCharString_template constGetInfo() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field info of a non-specific template of type @TitanLoggerApi.Setstate.");
		}
		return info;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__name = new TitanCharString_template();
			state = new TitanCharString_template();
			info = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__name.assign(template_sel.ANY_VALUE);
				state.assign(template_sel.ANY_VALUE);
				info.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Setstate_template() {
	}

	public Setstate_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Setstate_template( final Setstate otherValue ) {
		copyValue(otherValue);
	}

	public Setstate_template( final Setstate_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Setstate_template( final Optional<Setstate> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Setstate from an unbound optional field.");
		}
	}

	//originally operator=
	public Setstate_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Setstate_template assign( final Setstate other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Setstate_template assign( final Setstate_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Setstate_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Setstate) {
				return assign((Setstate) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Setstate' can not be cast to {1}", otherValue));
		}

		@Override
		public Setstate_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Setstate_template) {
				return assign((Setstate_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Setstate' can not be cast to {1}_template", otherValue));
		}

	public Setstate_template assign( final Optional<Setstate> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Setstate.");
		}
		return this;
	}

	private void copyValue(final Setstate other_value) {
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getState().isBound()) {
			getState().assign(other_value.getState());
		} else {
			getState().cleanUp();
		}
		if (other_value.getInfo().isBound()) {
			getInfo().assign(other_value.getInfo());
		} else {
			getInfo().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Setstate_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getState().get_selection()) {
				getState().cleanUp();
			} else {
				getState().assign(other_value.getState());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getInfo().get_selection()) {
				getInfo().cleanUp();
			} else {
				getInfo().assign(other_value.getInfo());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Setstate_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Setstate_template temp = new Setstate_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Setstate.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Setstate valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Setstate.");
			}
			final Setstate ret_val = new Setstate();
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (state.isBound()) {
				ret_val.state.assign(state.valueOf());
			}
			 if (info.isBound()) {
				ret_val.info.assign(info.valueOf());
			}
			return ret_val;
		}

		public Setstate_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Setstate.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Setstate.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Setstate.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Setstate_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Setstate_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (state.isBound()) {
				return true;
			}
			if (info.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!state.isValue()) {
				return false;
			}
			if (!info.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Setstate other_value) {
			return match(other_value, false);
		}

		public boolean match(final Setstate other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getState().isBound()) {
					return false;
				}
				if(!state.match(other_value.getState(), legacy)) {
					return false;
				}
				if(!other_value.getInfo().isBound()) {
					return false;
				}
				if(!info.match(other_value.getInfo(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Setstate.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Setstate) {
		return match((Setstate)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Setstate.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Setstate containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Setstate.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" state := ");
				state.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" info := ");
				info.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Setstate match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Setstate) {
				log_match((Setstate)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Setstate.");
		}

		public void log_match(final Setstate match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !state.match(match_value.constGetState(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".state");
							state.log_match(match_value.constGetState(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !info.match(match_value.constGetInfo(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".info");
							info.log_match(match_value.constGetInfo(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ state := ");
				state.log_match(match_value.constGetState(), legacy);
				TTCN_Logger.log_event_str("{ info := ");
				info.log_match(match_value.constGetInfo(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				state.encode_text(text_buf);
				info.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Setstate.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				state = new TitanCharString_template();
				state.decode_text(text_buf);
				info = new TitanCharString_template();
				info.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Setstate_template>(size);
				for(int i = 0; i < size; i++) {
					final Setstate_template temp = new Setstate_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Setstate.");
			}
		}
}
public static void Setstate_encoder(final Setstate input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Setstate_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Setstate_decoder( final TitanOctetString input_stream, final Setstate output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Setstate' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Setstate_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_verdictOp_encoder(final VerdictOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_verdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_verdictOp_decoder( final TitanOctetString input_stream, final VerdictOp output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.VerdictOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_verdictOp_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_inconcPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_inconcPercent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_inconcPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_inconcPercent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void VerdictType_fromVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictType_fromVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictType_fromVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictType_fromVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelEvent_choice_parallelPTC_encoder(final ParallelPTC input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelEvent_choice_parallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelEvent_choice_parallelPTC_decoder( final TitanOctetString input_stream, final ParallelPTC output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelEvent_choice_parallelPTC_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Proc__port__in extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final Port__oper operation; //Referenced_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanBoolean check__; //Boolean_Type
		private final TitanCharString parameter; //CharString_Type
		private final TitanInteger msgid; //Integer_Type

		public Proc__port__in() {
			port__name = new TitanCharString();
			operation = new Port__oper();
			compref = new TitanInteger();
			check__ = new TitanBoolean();
			parameter = new TitanCharString();
			msgid = new TitanInteger();
		}

		public Proc__port__in( final TitanCharString aPort__name, final Port__oper aOperation, final TitanInteger aCompref, final TitanBoolean aCheck__, final TitanCharString aParameter, final TitanInteger aMsgid ) {
			port__name = new TitanCharString( aPort__name );
			operation = new Port__oper( aOperation );
			compref = new TitanInteger( aCompref );
			check__ = new TitanBoolean( aCheck__ );
			parameter = new TitanCharString( aParameter );
			msgid = new TitanInteger( aMsgid );
		}

		public Proc__port__in( final Proc__port__in aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Proc_port_in.");
			}
			port__name = new TitanCharString();
			operation = new Port__oper();
			compref = new TitanInteger();
			check__ = new TitanBoolean();
			parameter = new TitanCharString();
			msgid = new TitanInteger();
			assign( aOtherValue );
		}
		public Proc__port__in assign(final Proc__port__in aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Proc_port_in");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getCheck__().isBound() ) {
					this.check__.assign( aOtherValue.getCheck__() );
				} else {
					this.check__.cleanUp();
				}
				if ( aOtherValue.getParameter().isBound() ) {
					this.parameter.assign( aOtherValue.getParameter() );
				} else {
					this.parameter.cleanUp();
				}
				if ( aOtherValue.getMsgid().isBound() ) {
					this.msgid.assign( aOtherValue.getMsgid() );
				} else {
					this.msgid.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Proc__port__in assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__in ) {
				return assign((Proc__port__in) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_in", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			operation.cleanUp();
			compref.cleanUp();
			check__.cleanUp();
			parameter.cleanUp();
			msgid.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( check__.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !check__.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Proc__port__in aOtherValue ) {
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.check__.operatorEquals( aOtherValue.check__ ) ) { return false; }
			if ( !this.parameter.operatorEquals( aOtherValue.parameter ) ) { return false; }
			if ( !this.msgid.operatorEquals( aOtherValue.msgid ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__in ) {
				return operatorEquals((Proc__port__in) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Proc_port_in", otherValue));
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public Port__oper getOperation() {
			return operation;
		}

		public Port__oper constGetOperation() {
			return operation;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanBoolean getCheck__() {
			return check__;
		}

		public TitanBoolean constGetCheck__() {
			return check__;
		}

		public TitanCharString getParameter() {
			return parameter;
		}

		public TitanCharString constGetParameter() {
			return parameter;
		}

		public TitanInteger getMsgid() {
			return msgid;
		}

		public TitanInteger constGetMsgid() {
			return msgid;
		}

		public TitanInteger sizeOf() {
			int sizeof = 6;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" check_ := ");
			check__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (check__.isBound()) {
				check__.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			operation.encode_text(text_buf);
			compref.encode_text(text_buf);
			check__.encode_text(text_buf);
			parameter.encode_text(text_buf);
			msgid.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			operation.decode_text(text_buf);
			compref.decode_text(text_buf);
			check__.decode_text(text_buf);
			parameter.decode_text(text_buf);
			msgid.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Proc__port__in_template extends Base_Template {

	private TitanCharString_template port__name; //CharString_Type
	private Port__oper_template operation; //Referenced_Type
	private TitanInteger_template compref; //Integer_Type
	private TitanBoolean_template check__; //Boolean_Type
	private TitanCharString_template parameter; //CharString_Type
	private TitanInteger_template msgid; //Integer_Type
	//originally value_list/list_value
	List<Proc__port__in_template> list_value;

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
		}
		return port__name;
	}

	public Port__oper_template getOperation() {
		setSpecific();
		return operation;
	}

	public Port__oper_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
		}
		return operation;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
		}
		return compref;
	}

	public TitanBoolean_template getCheck__() {
		setSpecific();
		return check__;
	}

	public TitanBoolean_template constGetCheck__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field check_ of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
		}
		return check__;
	}

	public TitanCharString_template getParameter() {
		setSpecific();
		return parameter;
	}

	public TitanCharString_template constGetParameter() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
		}
		return parameter;
	}

	public TitanInteger_template getMsgid() {
		setSpecific();
		return msgid;
	}

	public TitanInteger_template constGetMsgid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Proc_port_in.");
		}
		return msgid;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__name = new TitanCharString_template();
			operation = new Port__oper_template();
			compref = new TitanInteger_template();
			check__ = new TitanBoolean_template();
			parameter = new TitanCharString_template();
			msgid = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__name.assign(template_sel.ANY_VALUE);
				operation.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				check__.assign(template_sel.ANY_VALUE);
				parameter.assign(template_sel.ANY_VALUE);
				msgid.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Proc__port__in_template() {
	}

	public Proc__port__in_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Proc__port__in_template( final Proc__port__in otherValue ) {
		copyValue(otherValue);
	}

	public Proc__port__in_template( final Proc__port__in_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Proc__port__in_template( final Optional<Proc__port__in> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Proc_port_in from an unbound optional field.");
		}
	}

	//originally operator=
	public Proc__port__in_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Proc__port__in_template assign( final Proc__port__in other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Proc__port__in_template assign( final Proc__port__in_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Proc__port__in_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Proc__port__in) {
				return assign((Proc__port__in) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__in' can not be cast to {1}", otherValue));
		}

		@Override
		public Proc__port__in_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Proc__port__in_template) {
				return assign((Proc__port__in_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Proc__port__in' can not be cast to {1}_template", otherValue));
		}

	public Proc__port__in_template assign( final Optional<Proc__port__in> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Proc_port_in.");
		}
		return this;
	}

	private void copyValue(final Proc__port__in other_value) {
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getCheck__().isBound()) {
			getCheck__().assign(other_value.getCheck__());
		} else {
			getCheck__().cleanUp();
		}
		if (other_value.getParameter().isBound()) {
			getParameter().assign(other_value.getParameter());
		} else {
			getParameter().cleanUp();
		}
		if (other_value.getMsgid().isBound()) {
			getMsgid().assign(other_value.getMsgid());
		} else {
			getMsgid().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Proc__port__in_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCheck__().get_selection()) {
				getCheck__().cleanUp();
			} else {
				getCheck__().assign(other_value.getCheck__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParameter().get_selection()) {
				getParameter().cleanUp();
			} else {
				getParameter().assign(other_value.getParameter());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getMsgid().get_selection()) {
				getMsgid().cleanUp();
			} else {
				getMsgid().assign(other_value.getMsgid());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Proc__port__in_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Proc__port__in_template temp = new Proc__port__in_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Proc_port_in.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Proc__port__in valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Proc_port_in.");
			}
			final Proc__port__in ret_val = new Proc__port__in();
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (check__.isBound()) {
				ret_val.check__.assign(check__.valueOf());
			}
			 if (parameter.isBound()) {
				ret_val.parameter.assign(parameter.valueOf());
			}
			 if (msgid.isBound()) {
				ret_val.msgid.assign(msgid.valueOf());
			}
			return ret_val;
		}

		public Proc__port__in_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Proc_port_in.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Proc_port_in.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Proc_port_in.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Proc__port__in_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Proc__port__in_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (check__.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!check__.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Proc__port__in other_value) {
			return match(other_value, false);
		}

		public boolean match(final Proc__port__in other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getCheck__().isBound()) {
					return false;
				}
				if(!check__.match(other_value.getCheck__(), legacy)) {
					return false;
				}
				if(!other_value.getParameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getParameter(), legacy)) {
					return false;
				}
				if(!other_value.getMsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getMsgid(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Proc__port__in) {
		return match((Proc__port__in)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Proc__port__in.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 6;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Proc_port_in containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" check_ := ");
				check__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Proc__port__in match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Proc__port__in) {
				log_match((Proc__port__in)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Proc_port_in.");
		}

		public void log_match(final Proc__port__in match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !check__.match(match_value.constGetCheck__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".check_");
							check__.log_match(match_value.constGetCheck__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetParameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetParameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetMsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetMsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ check_ := ");
				check__.log_match(match_value.constGetCheck__(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetParameter(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetMsgid(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				operation.encode_text(text_buf);
				compref.encode_text(text_buf);
				check__.encode_text(text_buf);
				parameter.encode_text(text_buf);
				msgid.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Proc_port_in.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				operation = new Port__oper_template();
				operation.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				check__ = new TitanBoolean_template();
				check__.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Proc__port__in_template>(size);
				for(int i = 0; i < size; i++) {
					final Proc__port__in_template temp = new Proc__port__in_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Proc_port_in.");
			}
		}
}
public static void Proc__port__in_encoder(final Proc__port__in input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_decoder( final TitanOctetString input_stream, final Proc__port__in output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Proc_port_in' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TitanLogEvent extends Base_Type {
		private final TimestampType timestamp; //Referenced_Type
		private final TitanLogEvent_sourceInfo__list sourceInfo__list; //SequenceOf_Type
		private final TitanInteger severity; //Integer_Type
		private final LogEventType logEvent; //Referenced_Type

		public TitanLogEvent() {
			timestamp = new TimestampType();
			sourceInfo__list = new TitanLogEvent_sourceInfo__list();
			severity = new TitanInteger();
			logEvent = new LogEventType();
		}

		public TitanLogEvent( final TimestampType aTimestamp, final TitanLogEvent_sourceInfo__list aSourceInfo__list, final TitanInteger aSeverity, final LogEventType aLogEvent ) {
			timestamp = new TimestampType( aTimestamp );
			sourceInfo__list = new TitanLogEvent_sourceInfo__list( aSourceInfo__list );
			severity = new TitanInteger( aSeverity );
			logEvent = new LogEventType( aLogEvent );
		}

		public TitanLogEvent( final TitanLogEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanLogEvent.");
			}
			timestamp = new TimestampType();
			sourceInfo__list = new TitanLogEvent_sourceInfo__list();
			severity = new TitanInteger();
			logEvent = new LogEventType();
			assign( aOtherValue );
		}
		public TitanLogEvent assign(final TitanLogEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanLogEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getTimestamp().isBound() ) {
					this.timestamp.assign( aOtherValue.getTimestamp() );
				} else {
					this.timestamp.cleanUp();
				}
				if ( aOtherValue.getSourceInfo__list().isBound() ) {
					this.sourceInfo__list.assign( aOtherValue.getSourceInfo__list() );
				} else {
					this.sourceInfo__list.cleanUp();
				}
				if ( aOtherValue.getSeverity().isBound() ) {
					this.severity.assign( aOtherValue.getSeverity() );
				} else {
					this.severity.cleanUp();
				}
				if ( aOtherValue.getLogEvent().isBound() ) {
					this.logEvent.assign( aOtherValue.getLogEvent() );
				} else {
					this.logEvent.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanLogEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent ) {
				return assign((TitanLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLogEvent", otherValue));
		}

		public void cleanUp() {
			timestamp.cleanUp();
			sourceInfo__list.cleanUp();
			severity.cleanUp();
			logEvent.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( timestamp.isBound() ) { return true; }
			if ( sourceInfo__list.isBound() ) { return true; }
			if ( severity.isBound() ) { return true; }
			if ( logEvent.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !timestamp.isValue() ) { return false; }
			if ( !sourceInfo__list.isValue() ) { return false; }
			if ( !severity.isValue() ) { return false; }
			if ( !logEvent.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanLogEvent aOtherValue ) {
			if ( !this.timestamp.operatorEquals( aOtherValue.timestamp ) ) { return false; }
			if ( !this.sourceInfo__list.operatorEquals( aOtherValue.sourceInfo__list ) ) { return false; }
			if ( !this.severity.operatorEquals( aOtherValue.severity ) ) { return false; }
			if ( !this.logEvent.operatorEquals( aOtherValue.logEvent ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent ) {
				return operatorEquals((TitanLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLogEvent", otherValue));
		}

		public TimestampType getTimestamp() {
			return timestamp;
		}

		public TimestampType constGetTimestamp() {
			return timestamp;
		}

		public TitanLogEvent_sourceInfo__list getSourceInfo__list() {
			return sourceInfo__list;
		}

		public TitanLogEvent_sourceInfo__list constGetSourceInfo__list() {
			return sourceInfo__list;
		}

		public TitanInteger getSeverity() {
			return severity;
		}

		public TitanInteger constGetSeverity() {
			return severity;
		}

		public LogEventType getLogEvent() {
			return logEvent;
		}

		public LogEventType constGetLogEvent() {
			return logEvent;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" timestamp := ");
			timestamp.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sourceInfo_list := ");
			sourceInfo__list.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" severity := ");
			severity.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" logEvent := ");
			logEvent.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (timestamp.isBound()) {
				timestamp.set_implicit_omit();
			}
			if (sourceInfo__list.isBound()) {
				sourceInfo__list.set_implicit_omit();
			}
			if (severity.isBound()) {
				severity.set_implicit_omit();
			}
			if (logEvent.isBound()) {
				logEvent.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			timestamp.encode_text(text_buf);
			sourceInfo__list.encode_text(text_buf);
			severity.encode_text(text_buf);
			logEvent.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			timestamp.decode_text(text_buf);
			sourceInfo__list.decode_text(text_buf);
			severity.decode_text(text_buf);
			logEvent.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TitanLogEvent_template extends Base_Template {

	private TimestampType_template timestamp; //Referenced_Type
	private TitanLogEvent_sourceInfo__list_template sourceInfo__list; //SequenceOf_Type
	private TitanInteger_template severity; //Integer_Type
	private LogEventType_template logEvent; //Referenced_Type
	//originally value_list/list_value
	List<TitanLogEvent_template> list_value;

	public TimestampType_template getTimestamp() {
		setSpecific();
		return timestamp;
	}

	public TimestampType_template constGetTimestamp() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field timestamp of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
		}
		return timestamp;
	}

	public TitanLogEvent_sourceInfo__list_template getSourceInfo__list() {
		setSpecific();
		return sourceInfo__list;
	}

	public TitanLogEvent_sourceInfo__list_template constGetSourceInfo__list() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field sourceInfo_list of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
		}
		return sourceInfo__list;
	}

	public TitanInteger_template getSeverity() {
		setSpecific();
		return severity;
	}

	public TitanInteger_template constGetSeverity() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field severity of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
		}
		return severity;
	}

	public LogEventType_template getLogEvent() {
		setSpecific();
		return logEvent;
	}

	public LogEventType_template constGetLogEvent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field logEvent of a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
		}
		return logEvent;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			timestamp = new TimestampType_template();
			sourceInfo__list = new TitanLogEvent_sourceInfo__list_template();
			severity = new TitanInteger_template();
			logEvent = new LogEventType_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				timestamp.assign(template_sel.ANY_VALUE);
				sourceInfo__list.assign(template_sel.ANY_VALUE);
				severity.assign(template_sel.ANY_VALUE);
				logEvent.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TitanLogEvent_template() {
	}

	public TitanLogEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanLogEvent_template( final TitanLogEvent otherValue ) {
		copyValue(otherValue);
	}

	public TitanLogEvent_template( final TitanLogEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanLogEvent_template( final Optional<TitanLogEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLogEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public TitanLogEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanLogEvent_template assign( final TitanLogEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TitanLogEvent_template assign( final TitanLogEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TitanLogEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLogEvent) {
				return assign((TitanLogEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLogEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanLogEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLogEvent_template) {
				return assign((TitanLogEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLogEvent' can not be cast to {1}_template", otherValue));
		}

	public TitanLogEvent_template assign( final Optional<TitanLogEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLogEvent.");
		}
		return this;
	}

	private void copyValue(final TitanLogEvent other_value) {
		if (other_value.getTimestamp().isBound()) {
			getTimestamp().assign(other_value.getTimestamp());
		} else {
			getTimestamp().cleanUp();
		}
		if (other_value.getSourceInfo__list().isBound()) {
			getSourceInfo__list().assign(other_value.getSourceInfo__list());
		} else {
			getSourceInfo__list().cleanUp();
		}
		if (other_value.getSeverity().isBound()) {
			getSeverity().assign(other_value.getSeverity());
		} else {
			getSeverity().cleanUp();
		}
		if (other_value.getLogEvent().isBound()) {
			getLogEvent().assign(other_value.getLogEvent());
		} else {
			getLogEvent().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanLogEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTimestamp().get_selection()) {
				getTimestamp().cleanUp();
			} else {
				getTimestamp().assign(other_value.getTimestamp());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSourceInfo__list().get_selection()) {
				getSourceInfo__list().cleanUp();
			} else {
				getSourceInfo__list().assign(other_value.getSourceInfo__list());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSeverity().get_selection()) {
				getSeverity().cleanUp();
			} else {
				getSeverity().assign(other_value.getSeverity());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getLogEvent().get_selection()) {
				getLogEvent().cleanUp();
			} else {
				getLogEvent().assign(other_value.getLogEvent());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLogEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanLogEvent_template temp = new TitanLogEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLogEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanLogEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLogEvent.");
			}
			final TitanLogEvent ret_val = new TitanLogEvent();
			 if (timestamp.isBound()) {
				ret_val.timestamp.assign(timestamp.valueOf());
			}
			 if (sourceInfo__list.isBound()) {
				ret_val.sourceInfo__list.assign(sourceInfo__list.valueOf());
			}
			 if (severity.isBound()) {
				ret_val.severity.assign(severity.valueOf());
			}
			 if (logEvent.isBound()) {
				ret_val.logEvent.assign(logEvent.valueOf());
			}
			return ret_val;
		}

		public TitanLogEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLogEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLogEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanLogEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanLogEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanLogEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (timestamp.isBound()) {
				return true;
			}
			if (sourceInfo__list.isBound()) {
				return true;
			}
			if (severity.isBound()) {
				return true;
			}
			if (logEvent.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!timestamp.isValue()) {
				return false;
			}
			if (!sourceInfo__list.isValue()) {
				return false;
			}
			if (!severity.isValue()) {
				return false;
			}
			if (!logEvent.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanLogEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanLogEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getTimestamp().isBound()) {
					return false;
				}
				if(!timestamp.match(other_value.getTimestamp(), legacy)) {
					return false;
				}
				if(!other_value.getSourceInfo__list().isBound()) {
					return false;
				}
				if(!sourceInfo__list.match(other_value.getSourceInfo__list(), legacy)) {
					return false;
				}
				if(!other_value.getSeverity().isBound()) {
					return false;
				}
				if(!severity.match(other_value.getSeverity(), legacy)) {
					return false;
				}
				if(!other_value.getLogEvent().isBound()) {
					return false;
				}
				if(!logEvent.match(other_value.getLogEvent(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TitanLogEvent) {
		return match((TitanLogEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLogEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLogEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" timestamp := ");
				timestamp.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sourceInfo_list := ");
				sourceInfo__list.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" severity := ");
				severity.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" logEvent := ");
				logEvent.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanLogEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLogEvent) {
				log_match((TitanLogEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLogEvent.");
		}

		public void log_match(final TitanLogEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !timestamp.match(match_value.constGetTimestamp(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".timestamp");
							timestamp.log_match(match_value.constGetTimestamp(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !sourceInfo__list.match(match_value.constGetSourceInfo__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sourceInfo_list");
							sourceInfo__list.log_match(match_value.constGetSourceInfo__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !severity.match(match_value.constGetSeverity(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".severity");
							severity.log_match(match_value.constGetSeverity(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !logEvent.match(match_value.constGetLogEvent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".logEvent");
							logEvent.log_match(match_value.constGetLogEvent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ timestamp := ");
				timestamp.log_match(match_value.constGetTimestamp(), legacy);
				TTCN_Logger.log_event_str("{ sourceInfo_list := ");
				sourceInfo__list.log_match(match_value.constGetSourceInfo__list(), legacy);
				TTCN_Logger.log_event_str("{ severity := ");
				severity.log_match(match_value.constGetSeverity(), legacy);
				TTCN_Logger.log_event_str("{ logEvent := ");
				logEvent.log_match(match_value.constGetLogEvent(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timestamp.encode_text(text_buf);
				sourceInfo__list.encode_text(text_buf);
				severity.encode_text(text_buf);
				logEvent.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				timestamp = new TimestampType_template();
				timestamp.decode_text(text_buf);
				sourceInfo__list = new TitanLogEvent_sourceInfo__list_template();
				sourceInfo__list.decode_text(text_buf);
				severity = new TitanInteger_template();
				severity.decode_text(text_buf);
				logEvent = new LogEventType_template();
				logEvent.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLogEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final TitanLogEvent_template temp = new TitanLogEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanLogEvent.");
			}
		}
}
public static void TitanLogEvent_encoder(final TitanLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLogEvent_decoder( final TitanOctetString input_stream, final TitanLogEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLogEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class StatisticsType_choice_verdictStatistics extends Base_Type {
		private final TitanInteger none__; //Integer_Type
		private final TitanFloat nonePercent; //Float_Type
		private final TitanInteger pass__; //Integer_Type
		private final TitanFloat passPercent; //Float_Type
		private final TitanInteger inconc__; //Integer_Type
		private final TitanFloat inconcPercent; //Float_Type
		private final TitanInteger fail__; //Integer_Type
		private final TitanFloat failPercent; //Float_Type
		private final TitanInteger error__; //Integer_Type
		private final TitanFloat errorPercent; //Float_Type

		public StatisticsType_choice_verdictStatistics() {
			none__ = new TitanInteger();
			nonePercent = new TitanFloat();
			pass__ = new TitanInteger();
			passPercent = new TitanFloat();
			inconc__ = new TitanInteger();
			inconcPercent = new TitanFloat();
			fail__ = new TitanInteger();
			failPercent = new TitanFloat();
			error__ = new TitanInteger();
			errorPercent = new TitanFloat();
		}

		public StatisticsType_choice_verdictStatistics( final TitanInteger aNone__, final TitanFloat aNonePercent, final TitanInteger aPass__, final TitanFloat aPassPercent, final TitanInteger aInconc__, final TitanFloat aInconcPercent, final TitanInteger aFail__, final TitanFloat aFailPercent, final TitanInteger aError__, final TitanFloat aErrorPercent ) {
			none__ = new TitanInteger( aNone__ );
			nonePercent = new TitanFloat( aNonePercent );
			pass__ = new TitanInteger( aPass__ );
			passPercent = new TitanFloat( aPassPercent );
			inconc__ = new TitanInteger( aInconc__ );
			inconcPercent = new TitanFloat( aInconcPercent );
			fail__ = new TitanInteger( aFail__ );
			failPercent = new TitanFloat( aFailPercent );
			error__ = new TitanInteger( aError__ );
			errorPercent = new TitanFloat( aErrorPercent );
		}

		public StatisticsType_choice_verdictStatistics( final StatisticsType_choice_verdictStatistics aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			none__ = new TitanInteger();
			nonePercent = new TitanFloat();
			pass__ = new TitanInteger();
			passPercent = new TitanFloat();
			inconc__ = new TitanInteger();
			inconcPercent = new TitanFloat();
			fail__ = new TitanInteger();
			failPercent = new TitanFloat();
			error__ = new TitanInteger();
			errorPercent = new TitanFloat();
			assign( aOtherValue );
		}
		public StatisticsType_choice_verdictStatistics assign(final StatisticsType_choice_verdictStatistics aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getNone__().isBound() ) {
					this.none__.assign( aOtherValue.getNone__() );
				} else {
					this.none__.cleanUp();
				}
				if ( aOtherValue.getNonePercent().isBound() ) {
					this.nonePercent.assign( aOtherValue.getNonePercent() );
				} else {
					this.nonePercent.cleanUp();
				}
				if ( aOtherValue.getPass__().isBound() ) {
					this.pass__.assign( aOtherValue.getPass__() );
				} else {
					this.pass__.cleanUp();
				}
				if ( aOtherValue.getPassPercent().isBound() ) {
					this.passPercent.assign( aOtherValue.getPassPercent() );
				} else {
					this.passPercent.cleanUp();
				}
				if ( aOtherValue.getInconc__().isBound() ) {
					this.inconc__.assign( aOtherValue.getInconc__() );
				} else {
					this.inconc__.cleanUp();
				}
				if ( aOtherValue.getInconcPercent().isBound() ) {
					this.inconcPercent.assign( aOtherValue.getInconcPercent() );
				} else {
					this.inconcPercent.cleanUp();
				}
				if ( aOtherValue.getFail__().isBound() ) {
					this.fail__.assign( aOtherValue.getFail__() );
				} else {
					this.fail__.cleanUp();
				}
				if ( aOtherValue.getFailPercent().isBound() ) {
					this.failPercent.assign( aOtherValue.getFailPercent() );
				} else {
					this.failPercent.cleanUp();
				}
				if ( aOtherValue.getError__().isBound() ) {
					this.error__.assign( aOtherValue.getError__() );
				} else {
					this.error__.cleanUp();
				}
				if ( aOtherValue.getErrorPercent().isBound() ) {
					this.errorPercent.assign( aOtherValue.getErrorPercent() );
				} else {
					this.errorPercent.cleanUp();
				}
			}

			return this;
		}

		@Override
		public StatisticsType_choice_verdictStatistics assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics ) {
				return assign((StatisticsType_choice_verdictStatistics) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType.choice.verdictStatistics", otherValue));
		}

		public void cleanUp() {
			none__.cleanUp();
			nonePercent.cleanUp();
			pass__.cleanUp();
			passPercent.cleanUp();
			inconc__.cleanUp();
			inconcPercent.cleanUp();
			fail__.cleanUp();
			failPercent.cleanUp();
			error__.cleanUp();
			errorPercent.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( none__.isBound() ) { return true; }
			if ( nonePercent.isBound() ) { return true; }
			if ( pass__.isBound() ) { return true; }
			if ( passPercent.isBound() ) { return true; }
			if ( inconc__.isBound() ) { return true; }
			if ( inconcPercent.isBound() ) { return true; }
			if ( fail__.isBound() ) { return true; }
			if ( failPercent.isBound() ) { return true; }
			if ( error__.isBound() ) { return true; }
			if ( errorPercent.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !none__.isValue() ) { return false; }
			if ( !nonePercent.isValue() ) { return false; }
			if ( !pass__.isValue() ) { return false; }
			if ( !passPercent.isValue() ) { return false; }
			if ( !inconc__.isValue() ) { return false; }
			if ( !inconcPercent.isValue() ) { return false; }
			if ( !fail__.isValue() ) { return false; }
			if ( !failPercent.isValue() ) { return false; }
			if ( !error__.isValue() ) { return false; }
			if ( !errorPercent.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final StatisticsType_choice_verdictStatistics aOtherValue ) {
			if ( !this.none__.operatorEquals( aOtherValue.none__ ) ) { return false; }
			if ( !this.nonePercent.operatorEquals( aOtherValue.nonePercent ) ) { return false; }
			if ( !this.pass__.operatorEquals( aOtherValue.pass__ ) ) { return false; }
			if ( !this.passPercent.operatorEquals( aOtherValue.passPercent ) ) { return false; }
			if ( !this.inconc__.operatorEquals( aOtherValue.inconc__ ) ) { return false; }
			if ( !this.inconcPercent.operatorEquals( aOtherValue.inconcPercent ) ) { return false; }
			if ( !this.fail__.operatorEquals( aOtherValue.fail__ ) ) { return false; }
			if ( !this.failPercent.operatorEquals( aOtherValue.failPercent ) ) { return false; }
			if ( !this.error__.operatorEquals( aOtherValue.error__ ) ) { return false; }
			if ( !this.errorPercent.operatorEquals( aOtherValue.errorPercent ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics ) {
				return operatorEquals((StatisticsType_choice_verdictStatistics) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType.choice.verdictStatistics", otherValue));
		}

		public TitanInteger getNone__() {
			return none__;
		}

		public TitanInteger constGetNone__() {
			return none__;
		}

		public TitanFloat getNonePercent() {
			return nonePercent;
		}

		public TitanFloat constGetNonePercent() {
			return nonePercent;
		}

		public TitanInteger getPass__() {
			return pass__;
		}

		public TitanInteger constGetPass__() {
			return pass__;
		}

		public TitanFloat getPassPercent() {
			return passPercent;
		}

		public TitanFloat constGetPassPercent() {
			return passPercent;
		}

		public TitanInteger getInconc__() {
			return inconc__;
		}

		public TitanInteger constGetInconc__() {
			return inconc__;
		}

		public TitanFloat getInconcPercent() {
			return inconcPercent;
		}

		public TitanFloat constGetInconcPercent() {
			return inconcPercent;
		}

		public TitanInteger getFail__() {
			return fail__;
		}

		public TitanInteger constGetFail__() {
			return fail__;
		}

		public TitanFloat getFailPercent() {
			return failPercent;
		}

		public TitanFloat constGetFailPercent() {
			return failPercent;
		}

		public TitanInteger getError__() {
			return error__;
		}

		public TitanInteger constGetError__() {
			return error__;
		}

		public TitanFloat getErrorPercent() {
			return errorPercent;
		}

		public TitanFloat constGetErrorPercent() {
			return errorPercent;
		}

		public TitanInteger sizeOf() {
			int sizeof = 10;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" none_ := ");
			none__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" nonePercent := ");
			nonePercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" pass_ := ");
			pass__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" passPercent := ");
			passPercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" inconc_ := ");
			inconc__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" inconcPercent := ");
			inconcPercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" fail_ := ");
			fail__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" failPercent := ");
			failPercent.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" error_ := ");
			error__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" errorPercent := ");
			errorPercent.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (none__.isBound()) {
				none__.set_implicit_omit();
			}
			if (nonePercent.isBound()) {
				nonePercent.set_implicit_omit();
			}
			if (pass__.isBound()) {
				pass__.set_implicit_omit();
			}
			if (passPercent.isBound()) {
				passPercent.set_implicit_omit();
			}
			if (inconc__.isBound()) {
				inconc__.set_implicit_omit();
			}
			if (inconcPercent.isBound()) {
				inconcPercent.set_implicit_omit();
			}
			if (fail__.isBound()) {
				fail__.set_implicit_omit();
			}
			if (failPercent.isBound()) {
				failPercent.set_implicit_omit();
			}
			if (error__.isBound()) {
				error__.set_implicit_omit();
			}
			if (errorPercent.isBound()) {
				errorPercent.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			none__.encode_text(text_buf);
			nonePercent.encode_text(text_buf);
			pass__.encode_text(text_buf);
			passPercent.encode_text(text_buf);
			inconc__.encode_text(text_buf);
			inconcPercent.encode_text(text_buf);
			fail__.encode_text(text_buf);
			failPercent.encode_text(text_buf);
			error__.encode_text(text_buf);
			errorPercent.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			none__.decode_text(text_buf);
			nonePercent.decode_text(text_buf);
			pass__.decode_text(text_buf);
			passPercent.decode_text(text_buf);
			inconc__.decode_text(text_buf);
			inconcPercent.decode_text(text_buf);
			fail__.decode_text(text_buf);
			failPercent.decode_text(text_buf);
			error__.decode_text(text_buf);
			errorPercent.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class StatisticsType_choice_verdictStatistics_template extends Base_Template {

	private TitanInteger_template none__; //Integer_Type
	private TitanFloat_template nonePercent; //Float_Type
	private TitanInteger_template pass__; //Integer_Type
	private TitanFloat_template passPercent; //Float_Type
	private TitanInteger_template inconc__; //Integer_Type
	private TitanFloat_template inconcPercent; //Float_Type
	private TitanInteger_template fail__; //Integer_Type
	private TitanFloat_template failPercent; //Float_Type
	private TitanInteger_template error__; //Integer_Type
	private TitanFloat_template errorPercent; //Float_Type
	//originally value_list/list_value
	List<StatisticsType_choice_verdictStatistics_template> list_value;

	public TitanInteger_template getNone__() {
		setSpecific();
		return none__;
	}

	public TitanInteger_template constGetNone__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field none_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return none__;
	}

	public TitanFloat_template getNonePercent() {
		setSpecific();
		return nonePercent;
	}

	public TitanFloat_template constGetNonePercent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field nonePercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return nonePercent;
	}

	public TitanInteger_template getPass__() {
		setSpecific();
		return pass__;
	}

	public TitanInteger_template constGetPass__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field pass_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return pass__;
	}

	public TitanFloat_template getPassPercent() {
		setSpecific();
		return passPercent;
	}

	public TitanFloat_template constGetPassPercent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field passPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return passPercent;
	}

	public TitanInteger_template getInconc__() {
		setSpecific();
		return inconc__;
	}

	public TitanInteger_template constGetInconc__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field inconc_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return inconc__;
	}

	public TitanFloat_template getInconcPercent() {
		setSpecific();
		return inconcPercent;
	}

	public TitanFloat_template constGetInconcPercent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field inconcPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return inconcPercent;
	}

	public TitanInteger_template getFail__() {
		setSpecific();
		return fail__;
	}

	public TitanInteger_template constGetFail__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field fail_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return fail__;
	}

	public TitanFloat_template getFailPercent() {
		setSpecific();
		return failPercent;
	}

	public TitanFloat_template constGetFailPercent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field failPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return failPercent;
	}

	public TitanInteger_template getError__() {
		setSpecific();
		return error__;
	}

	public TitanInteger_template constGetError__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field error_ of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return error__;
	}

	public TitanFloat_template getErrorPercent() {
		setSpecific();
		return errorPercent;
	}

	public TitanFloat_template constGetErrorPercent() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field errorPercent of a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return errorPercent;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			none__ = new TitanInteger_template();
			nonePercent = new TitanFloat_template();
			pass__ = new TitanInteger_template();
			passPercent = new TitanFloat_template();
			inconc__ = new TitanInteger_template();
			inconcPercent = new TitanFloat_template();
			fail__ = new TitanInteger_template();
			failPercent = new TitanFloat_template();
			error__ = new TitanInteger_template();
			errorPercent = new TitanFloat_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				none__.assign(template_sel.ANY_VALUE);
				nonePercent.assign(template_sel.ANY_VALUE);
				pass__.assign(template_sel.ANY_VALUE);
				passPercent.assign(template_sel.ANY_VALUE);
				inconc__.assign(template_sel.ANY_VALUE);
				inconcPercent.assign(template_sel.ANY_VALUE);
				fail__.assign(template_sel.ANY_VALUE);
				failPercent.assign(template_sel.ANY_VALUE);
				error__.assign(template_sel.ANY_VALUE);
				errorPercent.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public StatisticsType_choice_verdictStatistics_template() {
	}

	public StatisticsType_choice_verdictStatistics_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public StatisticsType_choice_verdictStatistics_template( final StatisticsType_choice_verdictStatistics otherValue ) {
		copyValue(otherValue);
	}

	public StatisticsType_choice_verdictStatistics_template( final StatisticsType_choice_verdictStatistics_template otherValue ) {
		copyTemplate( otherValue );
	}

	public StatisticsType_choice_verdictStatistics_template( final Optional<StatisticsType_choice_verdictStatistics> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics from an unbound optional field.");
		}
	}

	//originally operator=
	public StatisticsType_choice_verdictStatistics_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public StatisticsType_choice_verdictStatistics_template assign( final StatisticsType_choice_verdictStatistics other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public StatisticsType_choice_verdictStatistics_template assign( final StatisticsType_choice_verdictStatistics_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public StatisticsType_choice_verdictStatistics_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics) {
				return assign((StatisticsType_choice_verdictStatistics) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType_choice_verdictStatistics' can not be cast to {1}", otherValue));
		}

		@Override
		public StatisticsType_choice_verdictStatistics_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StatisticsType_choice_verdictStatistics_template) {
				return assign((StatisticsType_choice_verdictStatistics_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType_choice_verdictStatistics' can not be cast to {1}_template", otherValue));
		}

	public StatisticsType_choice_verdictStatistics_template assign( final Optional<StatisticsType_choice_verdictStatistics> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		return this;
	}

	private void copyValue(final StatisticsType_choice_verdictStatistics other_value) {
		if (other_value.getNone__().isBound()) {
			getNone__().assign(other_value.getNone__());
		} else {
			getNone__().cleanUp();
		}
		if (other_value.getNonePercent().isBound()) {
			getNonePercent().assign(other_value.getNonePercent());
		} else {
			getNonePercent().cleanUp();
		}
		if (other_value.getPass__().isBound()) {
			getPass__().assign(other_value.getPass__());
		} else {
			getPass__().cleanUp();
		}
		if (other_value.getPassPercent().isBound()) {
			getPassPercent().assign(other_value.getPassPercent());
		} else {
			getPassPercent().cleanUp();
		}
		if (other_value.getInconc__().isBound()) {
			getInconc__().assign(other_value.getInconc__());
		} else {
			getInconc__().cleanUp();
		}
		if (other_value.getInconcPercent().isBound()) {
			getInconcPercent().assign(other_value.getInconcPercent());
		} else {
			getInconcPercent().cleanUp();
		}
		if (other_value.getFail__().isBound()) {
			getFail__().assign(other_value.getFail__());
		} else {
			getFail__().cleanUp();
		}
		if (other_value.getFailPercent().isBound()) {
			getFailPercent().assign(other_value.getFailPercent());
		} else {
			getFailPercent().cleanUp();
		}
		if (other_value.getError__().isBound()) {
			getError__().assign(other_value.getError__());
		} else {
			getError__().cleanUp();
		}
		if (other_value.getErrorPercent().isBound()) {
			getErrorPercent().assign(other_value.getErrorPercent());
		} else {
			getErrorPercent().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final StatisticsType_choice_verdictStatistics_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNone__().get_selection()) {
				getNone__().cleanUp();
			} else {
				getNone__().assign(other_value.getNone__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNonePercent().get_selection()) {
				getNonePercent().cleanUp();
			} else {
				getNonePercent().assign(other_value.getNonePercent());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPass__().get_selection()) {
				getPass__().cleanUp();
			} else {
				getPass__().assign(other_value.getPass__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPassPercent().get_selection()) {
				getPassPercent().cleanUp();
			} else {
				getPassPercent().assign(other_value.getPassPercent());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getInconc__().get_selection()) {
				getInconc__().cleanUp();
			} else {
				getInconc__().assign(other_value.getInconc__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getInconcPercent().get_selection()) {
				getInconcPercent().cleanUp();
			} else {
				getInconcPercent().assign(other_value.getInconcPercent());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFail__().get_selection()) {
				getFail__().cleanUp();
			} else {
				getFail__().assign(other_value.getFail__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFailPercent().get_selection()) {
				getFailPercent().cleanUp();
			} else {
				getFailPercent().assign(other_value.getFailPercent());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getError__().get_selection()) {
				getError__().cleanUp();
			} else {
				getError__().assign(other_value.getError__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getErrorPercent().get_selection()) {
				getErrorPercent().cleanUp();
			} else {
				getErrorPercent().assign(other_value.getErrorPercent());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<StatisticsType_choice_verdictStatistics_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final StatisticsType_choice_verdictStatistics_template temp = new StatisticsType_choice_verdictStatistics_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public StatisticsType_choice_verdictStatistics valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			final StatisticsType_choice_verdictStatistics ret_val = new StatisticsType_choice_verdictStatistics();
			 if (none__.isBound()) {
				ret_val.none__.assign(none__.valueOf());
			}
			 if (nonePercent.isBound()) {
				ret_val.nonePercent.assign(nonePercent.valueOf());
			}
			 if (pass__.isBound()) {
				ret_val.pass__.assign(pass__.valueOf());
			}
			 if (passPercent.isBound()) {
				ret_val.passPercent.assign(passPercent.valueOf());
			}
			 if (inconc__.isBound()) {
				ret_val.inconc__.assign(inconc__.valueOf());
			}
			 if (inconcPercent.isBound()) {
				ret_val.inconcPercent.assign(inconcPercent.valueOf());
			}
			 if (fail__.isBound()) {
				ret_val.fail__.assign(fail__.valueOf());
			}
			 if (failPercent.isBound()) {
				ret_val.failPercent.assign(failPercent.valueOf());
			}
			 if (error__.isBound()) {
				ret_val.error__.assign(error__.valueOf());
			}
			 if (errorPercent.isBound()) {
				ret_val.errorPercent.assign(errorPercent.valueOf());
			}
			return ret_val;
		}

		public StatisticsType_choice_verdictStatistics_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<StatisticsType_choice_verdictStatistics_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new StatisticsType_choice_verdictStatistics_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (none__.isBound()) {
				return true;
			}
			if (nonePercent.isBound()) {
				return true;
			}
			if (pass__.isBound()) {
				return true;
			}
			if (passPercent.isBound()) {
				return true;
			}
			if (inconc__.isBound()) {
				return true;
			}
			if (inconcPercent.isBound()) {
				return true;
			}
			if (fail__.isBound()) {
				return true;
			}
			if (failPercent.isBound()) {
				return true;
			}
			if (error__.isBound()) {
				return true;
			}
			if (errorPercent.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!none__.isValue()) {
				return false;
			}
			if (!nonePercent.isValue()) {
				return false;
			}
			if (!pass__.isValue()) {
				return false;
			}
			if (!passPercent.isValue()) {
				return false;
			}
			if (!inconc__.isValue()) {
				return false;
			}
			if (!inconcPercent.isValue()) {
				return false;
			}
			if (!fail__.isValue()) {
				return false;
			}
			if (!failPercent.isValue()) {
				return false;
			}
			if (!error__.isValue()) {
				return false;
			}
			if (!errorPercent.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final StatisticsType_choice_verdictStatistics other_value) {
			return match(other_value, false);
		}

		public boolean match(final StatisticsType_choice_verdictStatistics other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getNone__().isBound()) {
					return false;
				}
				if(!none__.match(other_value.getNone__(), legacy)) {
					return false;
				}
				if(!other_value.getNonePercent().isBound()) {
					return false;
				}
				if(!nonePercent.match(other_value.getNonePercent(), legacy)) {
					return false;
				}
				if(!other_value.getPass__().isBound()) {
					return false;
				}
				if(!pass__.match(other_value.getPass__(), legacy)) {
					return false;
				}
				if(!other_value.getPassPercent().isBound()) {
					return false;
				}
				if(!passPercent.match(other_value.getPassPercent(), legacy)) {
					return false;
				}
				if(!other_value.getInconc__().isBound()) {
					return false;
				}
				if(!inconc__.match(other_value.getInconc__(), legacy)) {
					return false;
				}
				if(!other_value.getInconcPercent().isBound()) {
					return false;
				}
				if(!inconcPercent.match(other_value.getInconcPercent(), legacy)) {
					return false;
				}
				if(!other_value.getFail__().isBound()) {
					return false;
				}
				if(!fail__.match(other_value.getFail__(), legacy)) {
					return false;
				}
				if(!other_value.getFailPercent().isBound()) {
					return false;
				}
				if(!failPercent.match(other_value.getFailPercent(), legacy)) {
					return false;
				}
				if(!other_value.getError__().isBound()) {
					return false;
				}
				if(!error__.match(other_value.getError__(), legacy)) {
					return false;
				}
				if(!other_value.getErrorPercent().isBound()) {
					return false;
				}
				if(!errorPercent.match(other_value.getErrorPercent(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof StatisticsType_choice_verdictStatistics) {
		return match((StatisticsType_choice_verdictStatistics)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StatisticsType_choice_verdictStatistics.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 10;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" none_ := ");
				none__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" nonePercent := ");
				nonePercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" pass_ := ");
				pass__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" passPercent := ");
				passPercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" inconc_ := ");
				inconc__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" inconcPercent := ");
				inconcPercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" fail_ := ");
				fail__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" failPercent := ");
				failPercent.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" error_ := ");
				error__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" errorPercent := ");
				errorPercent.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final StatisticsType_choice_verdictStatistics match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StatisticsType_choice_verdictStatistics) {
				log_match((StatisticsType_choice_verdictStatistics)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
		}

		public void log_match(final StatisticsType_choice_verdictStatistics match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !none__.match(match_value.constGetNone__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".none_");
							none__.log_match(match_value.constGetNone__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !nonePercent.match(match_value.constGetNonePercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".nonePercent");
							nonePercent.log_match(match_value.constGetNonePercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !pass__.match(match_value.constGetPass__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".pass_");
							pass__.log_match(match_value.constGetPass__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !passPercent.match(match_value.constGetPassPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".passPercent");
							passPercent.log_match(match_value.constGetPassPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !inconc__.match(match_value.constGetInconc__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".inconc_");
							inconc__.log_match(match_value.constGetInconc__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !inconcPercent.match(match_value.constGetInconcPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".inconcPercent");
							inconcPercent.log_match(match_value.constGetInconcPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !fail__.match(match_value.constGetFail__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".fail_");
							fail__.log_match(match_value.constGetFail__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !failPercent.match(match_value.constGetFailPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".failPercent");
							failPercent.log_match(match_value.constGetFailPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !error__.match(match_value.constGetError__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".error_");
							error__.log_match(match_value.constGetError__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !errorPercent.match(match_value.constGetErrorPercent(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".errorPercent");
							errorPercent.log_match(match_value.constGetErrorPercent(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ none_ := ");
				none__.log_match(match_value.constGetNone__(), legacy);
				TTCN_Logger.log_event_str("{ nonePercent := ");
				nonePercent.log_match(match_value.constGetNonePercent(), legacy);
				TTCN_Logger.log_event_str("{ pass_ := ");
				pass__.log_match(match_value.constGetPass__(), legacy);
				TTCN_Logger.log_event_str("{ passPercent := ");
				passPercent.log_match(match_value.constGetPassPercent(), legacy);
				TTCN_Logger.log_event_str("{ inconc_ := ");
				inconc__.log_match(match_value.constGetInconc__(), legacy);
				TTCN_Logger.log_event_str("{ inconcPercent := ");
				inconcPercent.log_match(match_value.constGetInconcPercent(), legacy);
				TTCN_Logger.log_event_str("{ fail_ := ");
				fail__.log_match(match_value.constGetFail__(), legacy);
				TTCN_Logger.log_event_str("{ failPercent := ");
				failPercent.log_match(match_value.constGetFailPercent(), legacy);
				TTCN_Logger.log_event_str("{ error_ := ");
				error__.log_match(match_value.constGetError__(), legacy);
				TTCN_Logger.log_event_str("{ errorPercent := ");
				errorPercent.log_match(match_value.constGetErrorPercent(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				none__.encode_text(text_buf);
				nonePercent.encode_text(text_buf);
				pass__.encode_text(text_buf);
				passPercent.encode_text(text_buf);
				inconc__.encode_text(text_buf);
				inconcPercent.encode_text(text_buf);
				fail__.encode_text(text_buf);
				failPercent.encode_text(text_buf);
				error__.encode_text(text_buf);
				errorPercent.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				none__ = new TitanInteger_template();
				none__.decode_text(text_buf);
				nonePercent = new TitanFloat_template();
				nonePercent.decode_text(text_buf);
				pass__ = new TitanInteger_template();
				pass__.decode_text(text_buf);
				passPercent = new TitanFloat_template();
				passPercent.decode_text(text_buf);
				inconc__ = new TitanInteger_template();
				inconc__.decode_text(text_buf);
				inconcPercent = new TitanFloat_template();
				inconcPercent.decode_text(text_buf);
				fail__ = new TitanInteger_template();
				fail__.decode_text(text_buf);
				failPercent = new TitanFloat_template();
				failPercent.decode_text(text_buf);
				error__ = new TitanInteger_template();
				error__.decode_text(text_buf);
				errorPercent = new TitanFloat_template();
				errorPercent.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StatisticsType_choice_verdictStatistics_template>(size);
				for(int i = 0; i < size; i++) {
					final StatisticsType_choice_verdictStatistics_template temp = new StatisticsType_choice_verdictStatistics_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.StatisticsType.choice.verdictStatistics.");
			}
		}
}
public static void StatisticsType_choice_verdictStatistics_encoder(final StatisticsType_choice_verdictStatistics input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice.verdictStatistics' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_decoder( final TitanOctetString input_stream, final StatisticsType_choice_verdictStatistics output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType.choice.verdictStatistics' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParPort_dstCompref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParPort_dstCompref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParPort_dstCompref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParPort_dstCompref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingSuccessType_info_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingSuccessType_info_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingSuccessType_info_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingSuccessType_info_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__send_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__send_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__send_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__send_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__send_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__send_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__send_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__send_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_none___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_none___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_none___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_none___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class LogEventType extends Base_Type {
		private final LogEventType_choice choice; //TTCN3_Choice_Type

		public LogEventType() {
			choice = new LogEventType_choice();
		}

		public LogEventType( final LogEventType_choice aChoice ) {
			choice = new LogEventType_choice( aChoice );
		}

		public LogEventType( final LogEventType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.LogEventType.");
			}
			choice = new LogEventType_choice();
			assign( aOtherValue );
		}
		public LogEventType assign(final LogEventType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.LogEventType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public LogEventType assign(final Base_Type otherValue) {
			if (otherValue instanceof LogEventType ) {
				return assign((LogEventType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LogEventType", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final LogEventType aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof LogEventType ) {
				return operatorEquals((LogEventType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.LogEventType", otherValue));
		}

		public LogEventType_choice getChoice() {
			return choice;
		}

		public LogEventType_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class LogEventType_template extends Base_Template {

	private LogEventType_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<LogEventType_template> list_value;

	public LogEventType_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public LogEventType_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.LogEventType.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new LogEventType_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public LogEventType_template() {
	}

	public LogEventType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public LogEventType_template( final LogEventType otherValue ) {
		copyValue(otherValue);
	}

	public LogEventType_template( final LogEventType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public LogEventType_template( final Optional<LogEventType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.LogEventType from an unbound optional field.");
		}
	}

	//originally operator=
	public LogEventType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public LogEventType_template assign( final LogEventType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public LogEventType_template assign( final LogEventType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public LogEventType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof LogEventType) {
				return assign((LogEventType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LogEventType' can not be cast to {1}", otherValue));
		}

		@Override
		public LogEventType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof LogEventType_template) {
				return assign((LogEventType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `LogEventType' can not be cast to {1}_template", otherValue));
		}

	public LogEventType_template assign( final Optional<LogEventType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.LogEventType.");
		}
		return this;
	}

	private void copyValue(final LogEventType other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final LogEventType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<LogEventType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final LogEventType_template temp = new LogEventType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.LogEventType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public LogEventType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.LogEventType.");
			}
			final LogEventType ret_val = new LogEventType();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public LogEventType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.LogEventType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.LogEventType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.LogEventType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<LogEventType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new LogEventType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final LogEventType other_value) {
			return match(other_value, false);
		}

		public boolean match(final LogEventType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.LogEventType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof LogEventType) {
		return match((LogEventType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type LogEventType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.LogEventType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.LogEventType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final LogEventType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof LogEventType) {
				log_match((LogEventType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.LogEventType.");
		}

		public void log_match(final LogEventType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.LogEventType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new LogEventType_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<LogEventType_template>(size);
				for(int i = 0; i < size; i++) {
					final LogEventType_template temp = new LogEventType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.LogEventType.");
			}
		}
}
public static void LogEventType_encoder(final LogEventType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_decoder( final TitanOctetString input_stream, final LogEventType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Port__State extends Base_Type {
		private final Port__State_operation operation; //TTCN3_Enumerated_Type
		private final TitanCharString port__name; //CharString_Type

		public Port__State() {
			operation = new Port__State_operation();
			port__name = new TitanCharString();
		}

		public Port__State( final Port__State_operation aOperation, final TitanCharString aPort__name ) {
			operation = new Port__State_operation( aOperation );
			port__name = new TitanCharString( aPort__name );
		}

		public Port__State( final Port__State aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Port_State.");
			}
			operation = new Port__State_operation();
			port__name = new TitanCharString();
			assign( aOtherValue );
		}
		public Port__State assign(final Port__State aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Port_State");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Port__State assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__State ) {
				return assign((Port__State) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_State", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			port__name.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Port__State aOtherValue ) {
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Port__State ) {
				return operatorEquals((Port__State) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_State", otherValue));
		}

		public Port__State_operation getOperation() {
			return operation;
		}

		public Port__State_operation constGetOperation() {
			return operation;
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			port__name.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			port__name.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Port__State_template extends Base_Template {

	private Port__State_operation_template operation; //TTCN3_Enumerated_Type
	private TitanCharString_template port__name; //CharString_Type
	//originally value_list/list_value
	List<Port__State_template> list_value;

	public Port__State_operation_template getOperation() {
		setSpecific();
		return operation;
	}

	public Port__State_operation_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Port_State.");
		}
		return operation;
	}

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Port_State.");
		}
		return port__name;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			operation = new Port__State_operation_template();
			port__name = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				operation.assign(template_sel.ANY_VALUE);
				port__name.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Port__State_template() {
	}

	public Port__State_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Port__State_template( final Port__State otherValue ) {
		copyValue(otherValue);
	}

	public Port__State_template( final Port__State_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Port__State_template( final Optional<Port__State> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Port_State from an unbound optional field.");
		}
	}

	//originally operator=
	public Port__State_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Port__State_template assign( final Port__State other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Port__State_template assign( final Port__State_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Port__State_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__State) {
				return assign((Port__State) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__State_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Port__State_template) {
				return assign((Port__State_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__State' can not be cast to {1}_template", otherValue));
		}

	public Port__State_template assign( final Optional<Port__State> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Port_State.");
		}
		return this;
	}

	private void copyValue(final Port__State other_value) {
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Port__State_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Port__State_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Port__State_template temp = new Port__State_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Port_State.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Port__State valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Port_State.");
			}
			final Port__State ret_val = new Port__State();
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			return ret_val;
		}

		public Port__State_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Port_State.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Port_State.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Port_State.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Port__State_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Port__State_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Port__State other_value) {
			return match(other_value, false);
		}

		public boolean match(final Port__State other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Port_State.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Port__State) {
		return match((Port__State)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Port__State.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_State containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Port_State.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Port__State match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__State) {
				log_match((Port__State)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_State.");
		}

		public void log_match(final Port__State match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				port__name.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Port_State.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new Port__State_operation_template();
				operation.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Port__State_template>(size);
				for(int i = 0; i < size; i++) {
					final Port__State_template temp = new Port__State_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Port_State.");
			}
		}
}
public static void Port__State_encoder(final Port__State input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__State_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__State_decoder( final TitanOctetString input_stream, final Port__State output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_State' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__State_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TestcaseType extends Base_Type {
		private final QualifiedName name; //Referenced_Type
		private final Verdict verdict; //Referenced_Type
		private final TitanCharString reason; //CharString_Type

		public TestcaseType() {
			name = new QualifiedName();
			verdict = new Verdict();
			reason = new TitanCharString();
		}

		public TestcaseType( final QualifiedName aName, final Verdict aVerdict, final TitanCharString aReason ) {
			name = new QualifiedName( aName );
			verdict = new Verdict( aVerdict );
			reason = new TitanCharString( aReason );
		}

		public TestcaseType( final TestcaseType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TestcaseType.");
			}
			name = new QualifiedName();
			verdict = new Verdict();
			reason = new TitanCharString();
			assign( aOtherValue );
		}
		public TestcaseType assign(final TestcaseType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TestcaseType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getName().isBound() ) {
					this.name.assign( aOtherValue.getName() );
				} else {
					this.name.cleanUp();
				}
				if ( aOtherValue.getVerdict().isBound() ) {
					this.verdict.assign( aOtherValue.getVerdict() );
				} else {
					this.verdict.cleanUp();
				}
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TestcaseType assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseType ) {
				return assign((TestcaseType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseType", otherValue));
		}

		public void cleanUp() {
			name.cleanUp();
			verdict.cleanUp();
			reason.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( name.isBound() ) { return true; }
			if ( verdict.isBound() ) { return true; }
			if ( reason.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !name.isValue() ) { return false; }
			if ( !verdict.isValue() ) { return false; }
			if ( !reason.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TestcaseType aOtherValue ) {
			if ( !this.name.operatorEquals( aOtherValue.name ) ) { return false; }
			if ( !this.verdict.operatorEquals( aOtherValue.verdict ) ) { return false; }
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseType ) {
				return operatorEquals((TestcaseType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TestcaseType", otherValue));
		}

		public QualifiedName getName() {
			return name;
		}

		public QualifiedName constGetName() {
			return name;
		}

		public Verdict getVerdict() {
			return verdict;
		}

		public Verdict constGetVerdict() {
			return verdict;
		}

		public TitanCharString getReason() {
			return reason;
		}

		public TitanCharString constGetReason() {
			return reason;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" verdict := ");
			verdict.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (verdict.isBound()) {
				verdict.set_implicit_omit();
			}
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			name.encode_text(text_buf);
			verdict.encode_text(text_buf);
			reason.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			name.decode_text(text_buf);
			verdict.decode_text(text_buf);
			reason.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TestcaseType_template extends Base_Template {

	private QualifiedName_template name; //Referenced_Type
	private Verdict_template verdict; //Referenced_Type
	private TitanCharString_template reason; //CharString_Type
	//originally value_list/list_value
	List<TestcaseType_template> list_value;

	public QualifiedName_template getName() {
		setSpecific();
		return name;
	}

	public QualifiedName_template constGetName() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.TestcaseType.");
		}
		return name;
	}

	public Verdict_template getVerdict() {
		setSpecific();
		return verdict;
	}

	public Verdict_template constGetVerdict() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field verdict of a non-specific template of type @TitanLoggerApi.TestcaseType.");
		}
		return verdict;
	}

	public TitanCharString_template getReason() {
		setSpecific();
		return reason;
	}

	public TitanCharString_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.TestcaseType.");
		}
		return reason;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			name = new QualifiedName_template();
			verdict = new Verdict_template();
			reason = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				name.assign(template_sel.ANY_VALUE);
				verdict.assign(template_sel.ANY_VALUE);
				reason.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TestcaseType_template() {
	}

	public TestcaseType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TestcaseType_template( final TestcaseType otherValue ) {
		copyValue(otherValue);
	}

	public TestcaseType_template( final TestcaseType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TestcaseType_template( final Optional<TestcaseType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TestcaseType from an unbound optional field.");
		}
	}

	//originally operator=
	public TestcaseType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TestcaseType_template assign( final TestcaseType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TestcaseType_template assign( final TestcaseType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TestcaseType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TestcaseType) {
				return assign((TestcaseType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseType' can not be cast to {1}", otherValue));
		}

		@Override
		public TestcaseType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TestcaseType_template) {
				return assign((TestcaseType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TestcaseType' can not be cast to {1}_template", otherValue));
		}

	public TestcaseType_template assign( final Optional<TestcaseType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TestcaseType.");
		}
		return this;
	}

	private void copyValue(final TestcaseType other_value) {
		if (other_value.getName().isBound()) {
			getName().assign(other_value.getName());
		} else {
			getName().cleanUp();
		}
		if (other_value.getVerdict().isBound()) {
			getVerdict().assign(other_value.getVerdict());
		} else {
			getVerdict().cleanUp();
		}
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TestcaseType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getName().get_selection()) {
				getName().cleanUp();
			} else {
				getName().assign(other_value.getName());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getVerdict().get_selection()) {
				getVerdict().cleanUp();
			} else {
				getVerdict().assign(other_value.getVerdict());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TestcaseType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TestcaseType_template temp = new TestcaseType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TestcaseType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TestcaseType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TestcaseType.");
			}
			final TestcaseType ret_val = new TestcaseType();
			 if (name.isBound()) {
				ret_val.name.assign(name.valueOf());
			}
			 if (verdict.isBound()) {
				ret_val.verdict.assign(verdict.valueOf());
			}
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			return ret_val;
		}

		public TestcaseType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TestcaseType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TestcaseType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TestcaseType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TestcaseType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TestcaseType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (verdict.isBound()) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!verdict.isValue()) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TestcaseType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TestcaseType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getName().isBound()) {
					return false;
				}
				if(!name.match(other_value.getName(), legacy)) {
					return false;
				}
				if(!other_value.getVerdict().isBound()) {
					return false;
				}
				if(!verdict.match(other_value.getVerdict(), legacy)) {
					return false;
				}
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TestcaseType) {
		return match((TestcaseType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TestcaseType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TestcaseType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" verdict := ");
				verdict.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TestcaseType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TestcaseType) {
				log_match((TestcaseType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TestcaseType.");
		}

		public void log_match(final TestcaseType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !name.match(match_value.constGetName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !verdict.match(match_value.constGetVerdict(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".verdict");
							verdict.log_match(match_value.constGetVerdict(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetName(), legacy);
				TTCN_Logger.log_event_str("{ verdict := ");
				verdict.log_match(match_value.constGetVerdict(), legacy);
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name.encode_text(text_buf);
				verdict.encode_text(text_buf);
				reason.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TestcaseType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name = new QualifiedName_template();
				name.decode_text(text_buf);
				verdict = new Verdict_template();
				verdict.decode_text(text_buf);
				reason = new TitanCharString_template();
				reason.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TestcaseType_template>(size);
				for(int i = 0; i < size; i++) {
					final TestcaseType_template temp = new TestcaseType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TestcaseType.");
			}
		}
}
public static void TestcaseType_encoder(final TestcaseType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseType_decoder( final TitanOctetString input_stream, final TestcaseType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanLogEvent_timestamp_encoder(final TimestampType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLogEvent_timestamp_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLogEvent_timestamp_decoder( final TitanOctetString input_stream, final TimestampType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimestampType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLogEvent_timestamp_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ParallelEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_ParallelPTC,  ALT_ParallelPTC__exit,  ALT_ParallelPort };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public ParallelEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public ParallelEvent_choice(final ParallelEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final ParallelEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_ParallelPTC:
field = new ParallelPTC((ParallelPTC)otherValue.field);
break;
case ALT_ParallelPTC__exit:
field = new PTC__exit((PTC__exit)otherValue.field);
break;
case ALT_ParallelPort:
field = new ParPort((ParPort)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.ParallelEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public ParallelEvent_choice assign( final ParallelEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public ParallelEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof ParallelEvent_choice) {
return assign((ParallelEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_ParallelPTC:
return field.isValue();
case ALT_ParallelPTC__exit:
return field.isValue();
case ALT_ParallelPort:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final ParallelEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.ParallelEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.ParallelEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_ParallelPTC:
return ((ParallelPTC)field).operatorEquals((ParallelPTC)otherValue.field);
case ALT_ParallelPTC__exit:
return ((PTC__exit)field).operatorEquals((PTC__exit)otherValue.field);
case ALT_ParallelPort:
return ((ParPort)field).operatorEquals((ParPort)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof ParallelEvent_choice) {
return operatorEquals((ParallelEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final ParallelEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public ParallelPTC getParallelPTC() {
if (union_selection != union_selection_type.ALT_ParallelPTC) {
cleanUp();
field = new ParallelPTC();
union_selection = union_selection_type.ALT_ParallelPTC;
}
return (ParallelPTC)field;
}

public ParallelPTC constGetParallelPTC() {
if (union_selection != union_selection_type.ALT_ParallelPTC) {
throw new TtcnError("Using non-selected field parallelPTC in a value of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return (ParallelPTC)field;
}

public PTC__exit getParallelPTC__exit() {
if (union_selection != union_selection_type.ALT_ParallelPTC__exit) {
cleanUp();
field = new PTC__exit();
union_selection = union_selection_type.ALT_ParallelPTC__exit;
}
return (PTC__exit)field;
}

public PTC__exit constGetParallelPTC__exit() {
if (union_selection != union_selection_type.ALT_ParallelPTC__exit) {
throw new TtcnError("Using non-selected field parallelPTC_exit in a value of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return (PTC__exit)field;
}

public ParPort getParallelPort() {
if (union_selection != union_selection_type.ALT_ParallelPort) {
cleanUp();
field = new ParPort();
union_selection = union_selection_type.ALT_ParallelPort;
}
return (ParPort)field;
}

public ParPort constGetParallelPort() {
if (union_selection != union_selection_type.ALT_ParallelPort) {
throw new TtcnError("Using non-selected field parallelPort in a value of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return (ParPort)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_ParallelPTC:
TTCN_Logger.log_event_str("{ parallelPTC := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ParallelPTC__exit:
TTCN_Logger.log_event_str("{ parallelPTC_exit := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ParallelPort:
TTCN_Logger.log_event_str("{ parallelPort := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_ParallelPTC:
case ALT_ParallelPTC__exit:
case ALT_ParallelPort:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_ParallelPTC:
text_buf.push_int(0);
break;
case ALT_ParallelPTC__exit:
text_buf.push_int(1);
break;
case ALT_ParallelPort:
text_buf.push_int(2);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.ParallelEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getParallelPTC().decode_text(text_buf);
break;
case 1:
getParallelPTC__exit().decode_text(text_buf);
break;
case 2:
getParallelPort().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.ParallelEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class ParallelEvent_choice_template extends Base_Template {
//if single value which value?
private ParallelEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<ParallelEvent_choice_template> value_list;

private void copy_value(final ParallelEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_ParallelPTC:
single_value = new ParallelPTC_template(other_value.constGetParallelPTC());
break;
case ALT_ParallelPTC__exit:
single_value = new PTC__exit_template(other_value.constGetParallelPTC__exit());
break;
case ALT_ParallelPort:
single_value = new ParPort_template(other_value.constGetParallelPort());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.ParallelEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final ParallelEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_ParallelPTC:
single_value = new ParallelPTC_template(other_value.constGetParallelPTC());
break;
case ALT_ParallelPTC__exit:
single_value = new PTC__exit_template(other_value.constGetParallelPTC__exit());
break;
case ALT_ParallelPort:
single_value = new ParPort_template(other_value.constGetParallelPort());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.ParallelEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ParallelEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final ParallelEvent_choice_template temp = new ParallelEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
set_selection(other_value);
}

public ParallelEvent_choice_template() {
}
public ParallelEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public ParallelEvent_choice_template(final ParallelEvent_choice other_value) {
copy_value(other_value);
}
public ParallelEvent_choice_template(final ParallelEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_ParallelPTC:
((ParallelPTC_template)single_value).cleanUp();
break;
case ALT_ParallelPTC__exit:
((PTC__exit_template)single_value).cleanUp();
break;
case ALT_ParallelPort:
((ParPort_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public ParallelEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public ParallelEvent_choice_template assign( final ParallelEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public ParallelEvent_choice_template assign( final ParallelEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public ParallelEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof ParallelEvent_choice) {
return assign((ParallelEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to ParallelEvent_choice.");
}

@Override
public ParallelEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof ParallelEvent_choice_template) {
return assign((ParallelEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to ParallelEvent_choice_template.");
}

// originally match
public boolean match(final ParallelEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final ParallelEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final ParallelEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == ParallelEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_ParallelPTC:
return ((ParallelPTC_template)single_value).match(other_value.getParallelPTC(), legacy);
case ALT_ParallelPTC__exit:
return ((PTC__exit_template)single_value).match(other_value.getParallelPTC__exit(), legacy);
case ALT_ParallelPort:
return ((ParPort_template)single_value).match(other_value.getParallelPort(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ParallelEvent_choice) {
		return match((ParallelEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ParallelEvent_choice.");
	}
public boolean isChosen(final ParallelEvent_choice.union_selection_type checked_selection) {
if(checked_selection == ParallelEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.ParallelEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == ParallelEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.ParallelEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_ParallelPTC:
return ((ParallelPTC_template)single_value).isValue();
case ALT_ParallelPTC__exit:
return ((PTC__exit_template)single_value).isValue();
case ALT_ParallelPort:
return ((ParPort_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
}

public ParallelEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
final ParallelEvent_choice ret_val = new ParallelEvent_choice();
switch (single_value_union_selection) {
case ALT_ParallelPTC:
ret_val.getParallelPTC().assign(((ParallelPTC_template)single_value).valueOf());
break;
case ALT_ParallelPTC__exit:
ret_val.getParallelPTC__exit().assign(((PTC__exit_template)single_value).valueOf());
break;
case ALT_ParallelPort:
ret_val.getParallelPort().assign(((ParPort_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<ParallelEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ParallelEvent_choice_template());
}
}

public ParallelEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public ParallelPTC_template getParallelPTC() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_ParallelPTC) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ParallelPTC_template(template_sel.ANY_VALUE);
} else {
single_value = new ParallelPTC_template();
}
single_value_union_selection = ParallelEvent_choice.union_selection_type.ALT_ParallelPTC;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ParallelPTC_template)single_value;
}

public ParallelPTC_template constGetParallelPTC() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field parallelPTC in a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
if (single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_ParallelPTC) {
throw new TtcnError("Accessing non-selected field parallelPTC in a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return (ParallelPTC_template)single_value;
}

public PTC__exit_template getParallelPTC__exit() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_ParallelPTC__exit) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new PTC__exit_template(template_sel.ANY_VALUE);
} else {
single_value = new PTC__exit_template();
}
single_value_union_selection = ParallelEvent_choice.union_selection_type.ALT_ParallelPTC__exit;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (PTC__exit_template)single_value;
}

public PTC__exit_template constGetParallelPTC__exit() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field parallelPTC_exit in a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
if (single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_ParallelPTC__exit) {
throw new TtcnError("Accessing non-selected field parallelPTC_exit in a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return (PTC__exit_template)single_value;
}

public ParPort_template getParallelPort() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_ParallelPort) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new ParPort_template(template_sel.ANY_VALUE);
} else {
single_value = new ParPort_template();
}
single_value_union_selection = ParallelEvent_choice.union_selection_type.ALT_ParallelPort;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (ParPort_template)single_value;
}

public ParPort_template constGetParallelPort() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field parallelPort in a non-specific template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
if (single_value_union_selection != ParallelEvent_choice.union_selection_type.ALT_ParallelPort) {
throw new TtcnError("Accessing non-selected field parallelPort in a template of union type @TitanLoggerApi.ParallelEvent.choice.");
}
return (ParPort_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ParallelEvent_choice) {
log_match((ParallelEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.choice.");
}

public void log_match(final ParallelEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_ParallelPTC:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".parallelPTC");
single_value.log_match(match_value.getParallelPTC(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ parallelPTC := ");
single_value.log_match(match_value.getParallelPTC(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ParallelPTC__exit:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".parallelPTC_exit");
single_value.log_match(match_value.getParallelPTC__exit(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ parallelPTC_exit := ");
single_value.log_match(match_value.getParallelPTC__exit(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ParallelPort:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".parallelPort");
single_value.log_match(match_value.getParallelPort(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ parallelPort := ");
single_value.log_match(match_value.getParallelPort(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.ParallelEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new ParallelPTC_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new PTC__exit_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new ParPort_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ParallelEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final ParallelEvent_choice_template temp2 = new ParallelEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.ParallelEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void ParallelEvent_choice_encoder(final ParallelEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelEvent_choice_decoder( final TitanOctetString input_stream, final ParallelEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingTimeout_timer__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingTimeout_timer__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingTimeout_timer__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingTimeout_timer__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class anytype extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE };
private union_selection_type union_selection;
public anytype() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public anytype(final anytype otherValue) {
copy_value(otherValue);
};

private void copy_value(final anytype otherValue) {
union_selection = otherValue.union_selection;
}

//originally operator=
public anytype assign( final anytype otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public anytype assign( final Base_Type otherValue ) {
if (otherValue instanceof anytype) {
return assign((anytype)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.anytype.");
}

//originally clean_up
public void cleanUp() {
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.anytype.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final anytype otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.anytype." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.anytype." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof anytype) {
return operatorEquals((anytype)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.anytype.");
}

//originally operator!=
public boolean operatorNotEquals( final anytype otherValue ) {
return !operatorEquals(otherValue);
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.anytype.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.anytype.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class anytype_template extends Base_Template {
//if single value which value?
private anytype.union_selection_type single_value_union_selection;
// value_list part
private ArrayList<anytype_template> value_list;

private void copy_value(final anytype other_value) {
single_value_union_selection = other_value.get_selection();
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final anytype_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<anytype_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final anytype_template temp = new anytype_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.anytype.");
}
set_selection(other_value);
}

public anytype_template() {
}
public anytype_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public anytype_template(final anytype other_value) {
copy_value(other_value);
}
public anytype_template(final anytype_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public anytype_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public anytype_template assign( final anytype other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public anytype_template assign( final anytype_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public anytype_template assign( final Base_Type otherValue ) {
if (otherValue instanceof anytype) {
return assign((anytype)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to anytype.");
}

@Override
public anytype_template assign( final Base_Template otherValue ) {
if (otherValue instanceof anytype_template) {
return assign((anytype_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to anytype_template.");
}

// originally match
public boolean match(final anytype other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final anytype other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final anytype.union_selection_type value_selection = other_value.get_selection();
if (value_selection == anytype.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.anytype.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof anytype) {
		return match((anytype)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type anytype.");
	}
public boolean isChosen(final anytype.union_selection_type checked_selection) {
if(checked_selection == anytype.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.anytype.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == anytype.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.anytype.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.anytype containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.anytype.");
}
}

public anytype valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.anytype.");
}
switch (single_value_union_selection) {
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.anytype.");
}
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.anytype.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<anytype_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new anytype_template());
}
}

public anytype_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.anytype.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.anytype.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.anytype.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof anytype) {
log_match((anytype)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.anytype.");
}

public void log_match(final anytype match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.anytype.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<anytype_template>(size);
for (int i = 0; i < size; i++) {
final anytype_template temp2 = new anytype_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.anytype.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void anytype_encoder(final anytype input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.anytype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(anytype_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger anytype_decoder( final TitanOctetString input_stream, final anytype output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.anytype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(anytype_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class PortEvent extends Base_Type {
		private final PortEvent_choice choice; //TTCN3_Choice_Type

		public PortEvent() {
			choice = new PortEvent_choice();
		}

		public PortEvent( final PortEvent_choice aChoice ) {
			choice = new PortEvent_choice( aChoice );
		}

		public PortEvent( final PortEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.PortEvent.");
			}
			choice = new PortEvent_choice();
			assign( aOtherValue );
		}
		public PortEvent assign(final PortEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.PortEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public PortEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof PortEvent ) {
				return assign((PortEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PortEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final PortEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof PortEvent ) {
				return operatorEquals((PortEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PortEvent", otherValue));
		}

		public PortEvent_choice getChoice() {
			return choice;
		}

		public PortEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class PortEvent_template extends Base_Template {

	private PortEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<PortEvent_template> list_value;

	public PortEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public PortEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.PortEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new PortEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public PortEvent_template() {
	}

	public PortEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public PortEvent_template( final PortEvent otherValue ) {
		copyValue(otherValue);
	}

	public PortEvent_template( final PortEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public PortEvent_template( final Optional<PortEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.PortEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public PortEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public PortEvent_template assign( final PortEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public PortEvent_template assign( final PortEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public PortEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof PortEvent) {
				return assign((PortEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public PortEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof PortEvent_template) {
				return assign((PortEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PortEvent' can not be cast to {1}_template", otherValue));
		}

	public PortEvent_template assign( final Optional<PortEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.PortEvent.");
		}
		return this;
	}

	private void copyValue(final PortEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final PortEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<PortEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final PortEvent_template temp = new PortEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.PortEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public PortEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.PortEvent.");
			}
			final PortEvent ret_val = new PortEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public PortEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.PortEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.PortEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.PortEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<PortEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new PortEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final PortEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final PortEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.PortEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof PortEvent) {
		return match((PortEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type PortEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PortEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.PortEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final PortEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PortEvent) {
				log_match((PortEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.");
		}

		public void log_match(final PortEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.PortEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new PortEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<PortEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final PortEvent_template temp = new PortEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.PortEvent.");
			}
		}
}
public static void PortEvent_encoder(final PortEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_decoder( final TitanOctetString input_stream, final PortEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_warningLog_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_warningLog_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_warningLog_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_warningLog_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class PortEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_PortQueue,  ALT_PortState,  ALT_ProcPortSend,  ALT_ProcPortRecv,  ALT_MsgPortSend,  ALT_MsgPortRecv,  ALT_DualMapped,  ALT_DualDiscard,  ALT_SetState,  ALT_PortMisc };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public PortEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public PortEvent_choice(final PortEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final PortEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_PortQueue:
field = new Port__Queue((Port__Queue)otherValue.field);
break;
case ALT_PortState:
field = new Port__State((Port__State)otherValue.field);
break;
case ALT_ProcPortSend:
field = new Proc__port__out((Proc__port__out)otherValue.field);
break;
case ALT_ProcPortRecv:
field = new Proc__port__in((Proc__port__in)otherValue.field);
break;
case ALT_MsgPortSend:
field = new Msg__port__send((Msg__port__send)otherValue.field);
break;
case ALT_MsgPortRecv:
field = new Msg__port__recv((Msg__port__recv)otherValue.field);
break;
case ALT_DualMapped:
field = new Dualface__mapped((Dualface__mapped)otherValue.field);
break;
case ALT_DualDiscard:
field = new Dualface__discard((Dualface__discard)otherValue.field);
break;
case ALT_SetState:
field = new Setstate((Setstate)otherValue.field);
break;
case ALT_PortMisc:
field = new Port__Misc((Port__Misc)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.PortEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public PortEvent_choice assign( final PortEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public PortEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof PortEvent_choice) {
return assign((PortEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.PortEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_PortQueue:
return field.isValue();
case ALT_PortState:
return field.isValue();
case ALT_ProcPortSend:
return field.isValue();
case ALT_ProcPortRecv:
return field.isValue();
case ALT_MsgPortSend:
return field.isValue();
case ALT_MsgPortRecv:
return field.isValue();
case ALT_DualMapped:
return field.isValue();
case ALT_DualDiscard:
return field.isValue();
case ALT_SetState:
return field.isValue();
case ALT_PortMisc:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final PortEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.PortEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.PortEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_PortQueue:
return ((Port__Queue)field).operatorEquals((Port__Queue)otherValue.field);
case ALT_PortState:
return ((Port__State)field).operatorEquals((Port__State)otherValue.field);
case ALT_ProcPortSend:
return ((Proc__port__out)field).operatorEquals((Proc__port__out)otherValue.field);
case ALT_ProcPortRecv:
return ((Proc__port__in)field).operatorEquals((Proc__port__in)otherValue.field);
case ALT_MsgPortSend:
return ((Msg__port__send)field).operatorEquals((Msg__port__send)otherValue.field);
case ALT_MsgPortRecv:
return ((Msg__port__recv)field).operatorEquals((Msg__port__recv)otherValue.field);
case ALT_DualMapped:
return ((Dualface__mapped)field).operatorEquals((Dualface__mapped)otherValue.field);
case ALT_DualDiscard:
return ((Dualface__discard)field).operatorEquals((Dualface__discard)otherValue.field);
case ALT_SetState:
return ((Setstate)field).operatorEquals((Setstate)otherValue.field);
case ALT_PortMisc:
return ((Port__Misc)field).operatorEquals((Port__Misc)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof PortEvent_choice) {
return operatorEquals((PortEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final PortEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public Port__Queue getPortQueue() {
if (union_selection != union_selection_type.ALT_PortQueue) {
cleanUp();
field = new Port__Queue();
union_selection = union_selection_type.ALT_PortQueue;
}
return (Port__Queue)field;
}

public Port__Queue constGetPortQueue() {
if (union_selection != union_selection_type.ALT_PortQueue) {
throw new TtcnError("Using non-selected field portQueue in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Port__Queue)field;
}

public Port__State getPortState() {
if (union_selection != union_selection_type.ALT_PortState) {
cleanUp();
field = new Port__State();
union_selection = union_selection_type.ALT_PortState;
}
return (Port__State)field;
}

public Port__State constGetPortState() {
if (union_selection != union_selection_type.ALT_PortState) {
throw new TtcnError("Using non-selected field portState in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Port__State)field;
}

public Proc__port__out getProcPortSend() {
if (union_selection != union_selection_type.ALT_ProcPortSend) {
cleanUp();
field = new Proc__port__out();
union_selection = union_selection_type.ALT_ProcPortSend;
}
return (Proc__port__out)field;
}

public Proc__port__out constGetProcPortSend() {
if (union_selection != union_selection_type.ALT_ProcPortSend) {
throw new TtcnError("Using non-selected field procPortSend in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Proc__port__out)field;
}

public Proc__port__in getProcPortRecv() {
if (union_selection != union_selection_type.ALT_ProcPortRecv) {
cleanUp();
field = new Proc__port__in();
union_selection = union_selection_type.ALT_ProcPortRecv;
}
return (Proc__port__in)field;
}

public Proc__port__in constGetProcPortRecv() {
if (union_selection != union_selection_type.ALT_ProcPortRecv) {
throw new TtcnError("Using non-selected field procPortRecv in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Proc__port__in)field;
}

public Msg__port__send getMsgPortSend() {
if (union_selection != union_selection_type.ALT_MsgPortSend) {
cleanUp();
field = new Msg__port__send();
union_selection = union_selection_type.ALT_MsgPortSend;
}
return (Msg__port__send)field;
}

public Msg__port__send constGetMsgPortSend() {
if (union_selection != union_selection_type.ALT_MsgPortSend) {
throw new TtcnError("Using non-selected field msgPortSend in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Msg__port__send)field;
}

public Msg__port__recv getMsgPortRecv() {
if (union_selection != union_selection_type.ALT_MsgPortRecv) {
cleanUp();
field = new Msg__port__recv();
union_selection = union_selection_type.ALT_MsgPortRecv;
}
return (Msg__port__recv)field;
}

public Msg__port__recv constGetMsgPortRecv() {
if (union_selection != union_selection_type.ALT_MsgPortRecv) {
throw new TtcnError("Using non-selected field msgPortRecv in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Msg__port__recv)field;
}

public Dualface__mapped getDualMapped() {
if (union_selection != union_selection_type.ALT_DualMapped) {
cleanUp();
field = new Dualface__mapped();
union_selection = union_selection_type.ALT_DualMapped;
}
return (Dualface__mapped)field;
}

public Dualface__mapped constGetDualMapped() {
if (union_selection != union_selection_type.ALT_DualMapped) {
throw new TtcnError("Using non-selected field dualMapped in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Dualface__mapped)field;
}

public Dualface__discard getDualDiscard() {
if (union_selection != union_selection_type.ALT_DualDiscard) {
cleanUp();
field = new Dualface__discard();
union_selection = union_selection_type.ALT_DualDiscard;
}
return (Dualface__discard)field;
}

public Dualface__discard constGetDualDiscard() {
if (union_selection != union_selection_type.ALT_DualDiscard) {
throw new TtcnError("Using non-selected field dualDiscard in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Dualface__discard)field;
}

public Setstate getSetState() {
if (union_selection != union_selection_type.ALT_SetState) {
cleanUp();
field = new Setstate();
union_selection = union_selection_type.ALT_SetState;
}
return (Setstate)field;
}

public Setstate constGetSetState() {
if (union_selection != union_selection_type.ALT_SetState) {
throw new TtcnError("Using non-selected field setState in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Setstate)field;
}

public Port__Misc getPortMisc() {
if (union_selection != union_selection_type.ALT_PortMisc) {
cleanUp();
field = new Port__Misc();
union_selection = union_selection_type.ALT_PortMisc;
}
return (Port__Misc)field;
}

public Port__Misc constGetPortMisc() {
if (union_selection != union_selection_type.ALT_PortMisc) {
throw new TtcnError("Using non-selected field portMisc in a value of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Port__Misc)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_PortQueue:
TTCN_Logger.log_event_str("{ portQueue := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_PortState:
TTCN_Logger.log_event_str("{ portState := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ProcPortSend:
TTCN_Logger.log_event_str("{ procPortSend := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_ProcPortRecv:
TTCN_Logger.log_event_str("{ procPortRecv := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MsgPortSend:
TTCN_Logger.log_event_str("{ msgPortSend := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MsgPortRecv:
TTCN_Logger.log_event_str("{ msgPortRecv := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_DualMapped:
TTCN_Logger.log_event_str("{ dualMapped := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_DualDiscard:
TTCN_Logger.log_event_str("{ dualDiscard := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_SetState:
TTCN_Logger.log_event_str("{ setState := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_PortMisc:
TTCN_Logger.log_event_str("{ portMisc := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_PortQueue:
case ALT_PortState:
case ALT_ProcPortSend:
case ALT_ProcPortRecv:
case ALT_MsgPortSend:
case ALT_MsgPortRecv:
case ALT_DualMapped:
case ALT_DualDiscard:
case ALT_SetState:
case ALT_PortMisc:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_PortQueue:
text_buf.push_int(0);
break;
case ALT_PortState:
text_buf.push_int(1);
break;
case ALT_ProcPortSend:
text_buf.push_int(2);
break;
case ALT_ProcPortRecv:
text_buf.push_int(3);
break;
case ALT_MsgPortSend:
text_buf.push_int(4);
break;
case ALT_MsgPortRecv:
text_buf.push_int(5);
break;
case ALT_DualMapped:
text_buf.push_int(6);
break;
case ALT_DualDiscard:
text_buf.push_int(7);
break;
case ALT_SetState:
text_buf.push_int(8);
break;
case ALT_PortMisc:
text_buf.push_int(9);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.PortEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getPortQueue().decode_text(text_buf);
break;
case 1:
getPortState().decode_text(text_buf);
break;
case 2:
getProcPortSend().decode_text(text_buf);
break;
case 3:
getProcPortRecv().decode_text(text_buf);
break;
case 4:
getMsgPortSend().decode_text(text_buf);
break;
case 5:
getMsgPortRecv().decode_text(text_buf);
break;
case 6:
getDualMapped().decode_text(text_buf);
break;
case 7:
getDualDiscard().decode_text(text_buf);
break;
case 8:
getSetState().decode_text(text_buf);
break;
case 9:
getPortMisc().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.PortEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class PortEvent_choice_template extends Base_Template {
//if single value which value?
private PortEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<PortEvent_choice_template> value_list;

private void copy_value(final PortEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_PortQueue:
single_value = new Port__Queue_template(other_value.constGetPortQueue());
break;
case ALT_PortState:
single_value = new Port__State_template(other_value.constGetPortState());
break;
case ALT_ProcPortSend:
single_value = new Proc__port__out_template(other_value.constGetProcPortSend());
break;
case ALT_ProcPortRecv:
single_value = new Proc__port__in_template(other_value.constGetProcPortRecv());
break;
case ALT_MsgPortSend:
single_value = new Msg__port__send_template(other_value.constGetMsgPortSend());
break;
case ALT_MsgPortRecv:
single_value = new Msg__port__recv_template(other_value.constGetMsgPortRecv());
break;
case ALT_DualMapped:
single_value = new Dualface__mapped_template(other_value.constGetDualMapped());
break;
case ALT_DualDiscard:
single_value = new Dualface__discard_template(other_value.constGetDualDiscard());
break;
case ALT_SetState:
single_value = new Setstate_template(other_value.constGetSetState());
break;
case ALT_PortMisc:
single_value = new Port__Misc_template(other_value.constGetPortMisc());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.PortEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final PortEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_PortQueue:
single_value = new Port__Queue_template(other_value.constGetPortQueue());
break;
case ALT_PortState:
single_value = new Port__State_template(other_value.constGetPortState());
break;
case ALT_ProcPortSend:
single_value = new Proc__port__out_template(other_value.constGetProcPortSend());
break;
case ALT_ProcPortRecv:
single_value = new Proc__port__in_template(other_value.constGetProcPortRecv());
break;
case ALT_MsgPortSend:
single_value = new Msg__port__send_template(other_value.constGetMsgPortSend());
break;
case ALT_MsgPortRecv:
single_value = new Msg__port__recv_template(other_value.constGetMsgPortRecv());
break;
case ALT_DualMapped:
single_value = new Dualface__mapped_template(other_value.constGetDualMapped());
break;
case ALT_DualDiscard:
single_value = new Dualface__discard_template(other_value.constGetDualDiscard());
break;
case ALT_SetState:
single_value = new Setstate_template(other_value.constGetSetState());
break;
case ALT_PortMisc:
single_value = new Port__Misc_template(other_value.constGetPortMisc());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.PortEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<PortEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final PortEvent_choice_template temp = new PortEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.PortEvent.choice.");
}
set_selection(other_value);
}

public PortEvent_choice_template() {
}
public PortEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public PortEvent_choice_template(final PortEvent_choice other_value) {
copy_value(other_value);
}
public PortEvent_choice_template(final PortEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_PortQueue:
((Port__Queue_template)single_value).cleanUp();
break;
case ALT_PortState:
((Port__State_template)single_value).cleanUp();
break;
case ALT_ProcPortSend:
((Proc__port__out_template)single_value).cleanUp();
break;
case ALT_ProcPortRecv:
((Proc__port__in_template)single_value).cleanUp();
break;
case ALT_MsgPortSend:
((Msg__port__send_template)single_value).cleanUp();
break;
case ALT_MsgPortRecv:
((Msg__port__recv_template)single_value).cleanUp();
break;
case ALT_DualMapped:
((Dualface__mapped_template)single_value).cleanUp();
break;
case ALT_DualDiscard:
((Dualface__discard_template)single_value).cleanUp();
break;
case ALT_SetState:
((Setstate_template)single_value).cleanUp();
break;
case ALT_PortMisc:
((Port__Misc_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public PortEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public PortEvent_choice_template assign( final PortEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public PortEvent_choice_template assign( final PortEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public PortEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof PortEvent_choice) {
return assign((PortEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to PortEvent_choice.");
}

@Override
public PortEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof PortEvent_choice_template) {
return assign((PortEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to PortEvent_choice_template.");
}

// originally match
public boolean match(final PortEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final PortEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final PortEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == PortEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_PortQueue:
return ((Port__Queue_template)single_value).match(other_value.getPortQueue(), legacy);
case ALT_PortState:
return ((Port__State_template)single_value).match(other_value.getPortState(), legacy);
case ALT_ProcPortSend:
return ((Proc__port__out_template)single_value).match(other_value.getProcPortSend(), legacy);
case ALT_ProcPortRecv:
return ((Proc__port__in_template)single_value).match(other_value.getProcPortRecv(), legacy);
case ALT_MsgPortSend:
return ((Msg__port__send_template)single_value).match(other_value.getMsgPortSend(), legacy);
case ALT_MsgPortRecv:
return ((Msg__port__recv_template)single_value).match(other_value.getMsgPortRecv(), legacy);
case ALT_DualMapped:
return ((Dualface__mapped_template)single_value).match(other_value.getDualMapped(), legacy);
case ALT_DualDiscard:
return ((Dualface__discard_template)single_value).match(other_value.getDualDiscard(), legacy);
case ALT_SetState:
return ((Setstate_template)single_value).match(other_value.getSetState(), legacy);
case ALT_PortMisc:
return ((Port__Misc_template)single_value).match(other_value.getPortMisc(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.PortEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof PortEvent_choice) {
		return match((PortEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type PortEvent_choice.");
	}
public boolean isChosen(final PortEvent_choice.union_selection_type checked_selection) {
if(checked_selection == PortEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.PortEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == PortEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.PortEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_PortQueue:
return ((Port__Queue_template)single_value).isValue();
case ALT_PortState:
return ((Port__State_template)single_value).isValue();
case ALT_ProcPortSend:
return ((Proc__port__out_template)single_value).isValue();
case ALT_ProcPortRecv:
return ((Proc__port__in_template)single_value).isValue();
case ALT_MsgPortSend:
return ((Msg__port__send_template)single_value).isValue();
case ALT_MsgPortRecv:
return ((Msg__port__recv_template)single_value).isValue();
case ALT_DualMapped:
return ((Dualface__mapped_template)single_value).isValue();
case ALT_DualDiscard:
return ((Dualface__discard_template)single_value).isValue();
case ALT_SetState:
return ((Setstate_template)single_value).isValue();
case ALT_PortMisc:
return ((Port__Misc_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
}
}

public PortEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
final PortEvent_choice ret_val = new PortEvent_choice();
switch (single_value_union_selection) {
case ALT_PortQueue:
ret_val.getPortQueue().assign(((Port__Queue_template)single_value).valueOf());
break;
case ALT_PortState:
ret_val.getPortState().assign(((Port__State_template)single_value).valueOf());
break;
case ALT_ProcPortSend:
ret_val.getProcPortSend().assign(((Proc__port__out_template)single_value).valueOf());
break;
case ALT_ProcPortRecv:
ret_val.getProcPortRecv().assign(((Proc__port__in_template)single_value).valueOf());
break;
case ALT_MsgPortSend:
ret_val.getMsgPortSend().assign(((Msg__port__send_template)single_value).valueOf());
break;
case ALT_MsgPortRecv:
ret_val.getMsgPortRecv().assign(((Msg__port__recv_template)single_value).valueOf());
break;
case ALT_DualMapped:
ret_val.getDualMapped().assign(((Dualface__mapped_template)single_value).valueOf());
break;
case ALT_DualDiscard:
ret_val.getDualDiscard().assign(((Dualface__discard_template)single_value).valueOf());
break;
case ALT_SetState:
ret_val.getSetState().assign(((Setstate_template)single_value).valueOf());
break;
case ALT_PortMisc:
ret_val.getPortMisc().assign(((Port__Misc_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.PortEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<PortEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new PortEvent_choice_template());
}
}

public PortEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.PortEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.PortEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public Port__Queue_template getPortQueue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_PortQueue) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Port__Queue_template(template_sel.ANY_VALUE);
} else {
single_value = new Port__Queue_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_PortQueue;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Port__Queue_template)single_value;
}

public Port__Queue_template constGetPortQueue() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field portQueue in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_PortQueue) {
throw new TtcnError("Accessing non-selected field portQueue in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Port__Queue_template)single_value;
}

public Port__State_template getPortState() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_PortState) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Port__State_template(template_sel.ANY_VALUE);
} else {
single_value = new Port__State_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_PortState;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Port__State_template)single_value;
}

public Port__State_template constGetPortState() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field portState in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_PortState) {
throw new TtcnError("Accessing non-selected field portState in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Port__State_template)single_value;
}

public Proc__port__out_template getProcPortSend() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_ProcPortSend) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Proc__port__out_template(template_sel.ANY_VALUE);
} else {
single_value = new Proc__port__out_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_ProcPortSend;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Proc__port__out_template)single_value;
}

public Proc__port__out_template constGetProcPortSend() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field procPortSend in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_ProcPortSend) {
throw new TtcnError("Accessing non-selected field procPortSend in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Proc__port__out_template)single_value;
}

public Proc__port__in_template getProcPortRecv() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_ProcPortRecv) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Proc__port__in_template(template_sel.ANY_VALUE);
} else {
single_value = new Proc__port__in_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_ProcPortRecv;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Proc__port__in_template)single_value;
}

public Proc__port__in_template constGetProcPortRecv() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field procPortRecv in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_ProcPortRecv) {
throw new TtcnError("Accessing non-selected field procPortRecv in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Proc__port__in_template)single_value;
}

public Msg__port__send_template getMsgPortSend() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_MsgPortSend) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Msg__port__send_template(template_sel.ANY_VALUE);
} else {
single_value = new Msg__port__send_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_MsgPortSend;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Msg__port__send_template)single_value;
}

public Msg__port__send_template constGetMsgPortSend() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field msgPortSend in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_MsgPortSend) {
throw new TtcnError("Accessing non-selected field msgPortSend in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Msg__port__send_template)single_value;
}

public Msg__port__recv_template getMsgPortRecv() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_MsgPortRecv) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Msg__port__recv_template(template_sel.ANY_VALUE);
} else {
single_value = new Msg__port__recv_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_MsgPortRecv;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Msg__port__recv_template)single_value;
}

public Msg__port__recv_template constGetMsgPortRecv() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field msgPortRecv in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_MsgPortRecv) {
throw new TtcnError("Accessing non-selected field msgPortRecv in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Msg__port__recv_template)single_value;
}

public Dualface__mapped_template getDualMapped() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_DualMapped) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Dualface__mapped_template(template_sel.ANY_VALUE);
} else {
single_value = new Dualface__mapped_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_DualMapped;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Dualface__mapped_template)single_value;
}

public Dualface__mapped_template constGetDualMapped() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field dualMapped in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_DualMapped) {
throw new TtcnError("Accessing non-selected field dualMapped in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Dualface__mapped_template)single_value;
}

public Dualface__discard_template getDualDiscard() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_DualDiscard) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Dualface__discard_template(template_sel.ANY_VALUE);
} else {
single_value = new Dualface__discard_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_DualDiscard;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Dualface__discard_template)single_value;
}

public Dualface__discard_template constGetDualDiscard() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field dualDiscard in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_DualDiscard) {
throw new TtcnError("Accessing non-selected field dualDiscard in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Dualface__discard_template)single_value;
}

public Setstate_template getSetState() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_SetState) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Setstate_template(template_sel.ANY_VALUE);
} else {
single_value = new Setstate_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_SetState;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Setstate_template)single_value;
}

public Setstate_template constGetSetState() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field setState in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_SetState) {
throw new TtcnError("Accessing non-selected field setState in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Setstate_template)single_value;
}

public Port__Misc_template getPortMisc() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != PortEvent_choice.union_selection_type.ALT_PortMisc) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new Port__Misc_template(template_sel.ANY_VALUE);
} else {
single_value = new Port__Misc_template();
}
single_value_union_selection = PortEvent_choice.union_selection_type.ALT_PortMisc;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (Port__Misc_template)single_value;
}

public Port__Misc_template constGetPortMisc() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field portMisc in a non-specific template of union type @TitanLoggerApi.PortEvent.choice.");
}
if (single_value_union_selection != PortEvent_choice.union_selection_type.ALT_PortMisc) {
throw new TtcnError("Accessing non-selected field portMisc in a template of union type @TitanLoggerApi.PortEvent.choice.");
}
return (Port__Misc_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof PortEvent_choice) {
log_match((PortEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PortEvent.choice.");
}

public void log_match(final PortEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_PortQueue:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".portQueue");
single_value.log_match(match_value.getPortQueue(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ portQueue := ");
single_value.log_match(match_value.getPortQueue(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_PortState:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".portState");
single_value.log_match(match_value.getPortState(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ portState := ");
single_value.log_match(match_value.getPortState(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ProcPortSend:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".procPortSend");
single_value.log_match(match_value.getProcPortSend(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ procPortSend := ");
single_value.log_match(match_value.getProcPortSend(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_ProcPortRecv:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".procPortRecv");
single_value.log_match(match_value.getProcPortRecv(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ procPortRecv := ");
single_value.log_match(match_value.getProcPortRecv(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MsgPortSend:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".msgPortSend");
single_value.log_match(match_value.getMsgPortSend(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ msgPortSend := ");
single_value.log_match(match_value.getMsgPortSend(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MsgPortRecv:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".msgPortRecv");
single_value.log_match(match_value.getMsgPortRecv(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ msgPortRecv := ");
single_value.log_match(match_value.getMsgPortRecv(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_DualMapped:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".dualMapped");
single_value.log_match(match_value.getDualMapped(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ dualMapped := ");
single_value.log_match(match_value.getDualMapped(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_DualDiscard:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".dualDiscard");
single_value.log_match(match_value.getDualDiscard(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ dualDiscard := ");
single_value.log_match(match_value.getDualDiscard(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_SetState:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".setState");
single_value.log_match(match_value.getSetState(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ setState := ");
single_value.log_match(match_value.getSetState(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_PortMisc:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".portMisc");
single_value.log_match(match_value.getPortMisc(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ portMisc := ");
single_value.log_match(match_value.getPortMisc(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.PortEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new Port__Queue_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new Port__State_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new Proc__port__out_template();
single_value.decode_text(text_buf);
break;
case 3:
single_value = new Proc__port__in_template();
single_value.decode_text(text_buf);
break;
case 4:
single_value = new Msg__port__send_template();
single_value.decode_text(text_buf);
break;
case 5:
single_value = new Msg__port__recv_template();
single_value.decode_text(text_buf);
break;
case 6:
single_value = new Dualface__mapped_template();
single_value.decode_text(text_buf);
break;
case 7:
single_value = new Dualface__discard_template();
single_value.decode_text(text_buf);
break;
case 8:
single_value = new Setstate_template();
single_value.decode_text(text_buf);
break;
case 9:
single_value = new Port__Misc_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<PortEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final PortEvent_choice_template temp2 = new PortEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.PortEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void PortEvent_choice_encoder(final PortEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_decoder( final TitanOctetString input_stream, final PortEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Msg__port__send extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString parameter; //CharString_Type

		public Msg__port__send() {
			port__name = new TitanCharString();
			compref = new TitanInteger();
			parameter = new TitanCharString();
		}

		public Msg__port__send( final TitanCharString aPort__name, final TitanInteger aCompref, final TitanCharString aParameter ) {
			port__name = new TitanCharString( aPort__name );
			compref = new TitanInteger( aCompref );
			parameter = new TitanCharString( aParameter );
		}

		public Msg__port__send( final Msg__port__send aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Msg_port_send.");
			}
			port__name = new TitanCharString();
			compref = new TitanInteger();
			parameter = new TitanCharString();
			assign( aOtherValue );
		}
		public Msg__port__send assign(final Msg__port__send aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Msg_port_send");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getParameter().isBound() ) {
					this.parameter.assign( aOtherValue.getParameter() );
				} else {
					this.parameter.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Msg__port__send assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__send ) {
				return assign((Msg__port__send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_send", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			compref.cleanUp();
			parameter.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Msg__port__send aOtherValue ) {
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.parameter.operatorEquals( aOtherValue.parameter ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__send ) {
				return operatorEquals((Msg__port__send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_send", otherValue));
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanCharString getParameter() {
			return parameter;
		}

		public TitanCharString constGetParameter() {
			return parameter;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			compref.encode_text(text_buf);
			parameter.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			compref.decode_text(text_buf);
			parameter.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Msg__port__send_template extends Base_Template {

	private TitanCharString_template port__name; //CharString_Type
	private TitanInteger_template compref; //Integer_Type
	private TitanCharString_template parameter; //CharString_Type
	//originally value_list/list_value
	List<Msg__port__send_template> list_value;

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Msg_port_send.");
		}
		return port__name;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Msg_port_send.");
		}
		return compref;
	}

	public TitanCharString_template getParameter() {
		setSpecific();
		return parameter;
	}

	public TitanCharString_template constGetParameter() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Msg_port_send.");
		}
		return parameter;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__name = new TitanCharString_template();
			compref = new TitanInteger_template();
			parameter = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__name.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				parameter.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Msg__port__send_template() {
	}

	public Msg__port__send_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Msg__port__send_template( final Msg__port__send otherValue ) {
		copyValue(otherValue);
	}

	public Msg__port__send_template( final Msg__port__send_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Msg__port__send_template( final Optional<Msg__port__send> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Msg_port_send from an unbound optional field.");
		}
	}

	//originally operator=
	public Msg__port__send_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Msg__port__send_template assign( final Msg__port__send other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Msg__port__send_template assign( final Msg__port__send_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Msg__port__send_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__send) {
				return assign((Msg__port__send) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__send' can not be cast to {1}", otherValue));
		}

		@Override
		public Msg__port__send_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Msg__port__send_template) {
				return assign((Msg__port__send_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__send' can not be cast to {1}_template", otherValue));
		}

	public Msg__port__send_template assign( final Optional<Msg__port__send> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Msg_port_send.");
		}
		return this;
	}

	private void copyValue(final Msg__port__send other_value) {
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getParameter().isBound()) {
			getParameter().assign(other_value.getParameter());
		} else {
			getParameter().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Msg__port__send_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParameter().get_selection()) {
				getParameter().cleanUp();
			} else {
				getParameter().assign(other_value.getParameter());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Msg__port__send_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Msg__port__send_template temp = new Msg__port__send_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Msg_port_send.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Msg__port__send valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Msg_port_send.");
			}
			final Msg__port__send ret_val = new Msg__port__send();
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (parameter.isBound()) {
				ret_val.parameter.assign(parameter.valueOf());
			}
			return ret_val;
		}

		public Msg__port__send_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Msg_port_send.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Msg_port_send.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Msg_port_send.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Msg__port__send_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Msg__port__send_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Msg__port__send other_value) {
			return match(other_value, false);
		}

		public boolean match(final Msg__port__send other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getParameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getParameter(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Msg__port__send) {
		return match((Msg__port__send)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Msg__port__send.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_send containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Msg__port__send match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Msg__port__send) {
				log_match((Msg__port__send)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_send.");
		}

		public void log_match(final Msg__port__send match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetParameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetParameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetParameter(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				compref.encode_text(text_buf);
				parameter.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_send.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Msg__port__send_template>(size);
				for(int i = 0; i < size; i++) {
					final Msg__port__send_template temp = new Msg__port__send_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Msg_port_send.");
			}
		}
}
public static void Msg__port__send_encoder(final Msg__port__send input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__send_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__send_decoder( final TitanOctetString input_stream, final Msg__port__send output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_send' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__send_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StartFunction_parameter__list_0_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StartFunction_parameter__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StartFunction_parameter__list_0_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StartFunction_parameter__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ComponentIDType_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ComponentIDType_name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ComponentIDType_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ComponentIDType_name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__in_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingEvent_choice_matchingSuccess_encoder(final MatchingSuccessType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_choice_matchingSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_choice_matchingSuccess_decoder( final TitanOctetString input_stream, final MatchingSuccessType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingSuccessType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_choice_matchingSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_fail___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_fail___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_fail___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_fail___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__recv_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_executorRuntime_encoder(final ExecutorRuntime input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_executorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_executorRuntime_decoder( final TitanOctetString input_stream, final ExecutorRuntime output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_executorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_defaultEvent_encoder(final DefaultEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_defaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_defaultEvent_decoder( final TitanOctetString input_stream, final DefaultEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_defaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_errorLog_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_errorLog_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_errorLog_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_errorLog_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_errorPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_errorPercent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_errorPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_errorPercent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_local__verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_local__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_local__verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_local__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Parallel_src__compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_src__compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_src__compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_src__compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class FunctionEvent extends Base_Type {
		private final FunctionEvent_choice choice; //TTCN3_Choice_Type

		public FunctionEvent() {
			choice = new FunctionEvent_choice();
		}

		public FunctionEvent( final FunctionEvent_choice aChoice ) {
			choice = new FunctionEvent_choice( aChoice );
		}

		public FunctionEvent( final FunctionEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FunctionEvent.");
			}
			choice = new FunctionEvent_choice();
			assign( aOtherValue );
		}
		public FunctionEvent assign(final FunctionEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FunctionEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FunctionEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent ) {
				return assign((FunctionEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FunctionEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent ) {
				return operatorEquals((FunctionEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FunctionEvent", otherValue));
		}

		public FunctionEvent_choice getChoice() {
			return choice;
		}

		public FunctionEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class FunctionEvent_template extends Base_Template {

	private FunctionEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<FunctionEvent_template> list_value;

	public FunctionEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public FunctionEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.FunctionEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new FunctionEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public FunctionEvent_template() {
	}

	public FunctionEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public FunctionEvent_template( final FunctionEvent otherValue ) {
		copyValue(otherValue);
	}

	public FunctionEvent_template( final FunctionEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public FunctionEvent_template( final Optional<FunctionEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.FunctionEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public FunctionEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public FunctionEvent_template assign( final FunctionEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public FunctionEvent_template assign( final FunctionEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public FunctionEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FunctionEvent) {
				return assign((FunctionEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public FunctionEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FunctionEvent_template) {
				return assign((FunctionEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FunctionEvent' can not be cast to {1}_template", otherValue));
		}

	public FunctionEvent_template assign( final Optional<FunctionEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FunctionEvent.");
		}
		return this;
	}

	private void copyValue(final FunctionEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final FunctionEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<FunctionEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final FunctionEvent_template temp = new FunctionEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FunctionEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FunctionEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FunctionEvent.");
			}
			final FunctionEvent ret_val = new FunctionEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public FunctionEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FunctionEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FunctionEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FunctionEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FunctionEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FunctionEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FunctionEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final FunctionEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof FunctionEvent) {
		return match((FunctionEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type FunctionEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FunctionEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FunctionEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FunctionEvent) {
				log_match((FunctionEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.");
		}

		public void log_match(final FunctionEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FunctionEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new FunctionEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FunctionEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final FunctionEvent_template temp = new FunctionEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FunctionEvent.");
			}
		}
}
public static void FunctionEvent_encoder(final FunctionEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_decoder( final TitanOctetString input_stream, final FunctionEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_stopTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_stopTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_stopTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_stopTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ErrorEvent_text_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ErrorEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ErrorEvent_text_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ErrorEvent_text_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutionSummaryType_overallStatistics_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutionSummaryType_overallStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutionSummaryType_overallStatistics_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutionSummaryType_overallStatistics_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__send_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__send_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__send_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__send_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_executorComponent_encoder(final ExecutorComponent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_executorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_executorComponent_decoder( final TitanOctetString input_stream, final ExecutorComponent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_executorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorRuntime_fd__setsize_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorRuntime_fd__setsize_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorRuntime_fd__setsize_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorRuntime_fd__setsize_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Parallel_function__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_function__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_testcaseOp_encoder(final TestcaseEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_testcaseOp_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_testcaseOp_decoder( final TitanOctetString input_stream, final TestcaseEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TestcaseEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_testcaseOp_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class MatchingFailureType extends Base_Type {
		private final PortType port__type; //Referenced_Type
		private final TitanCharString port__name; //CharString_Type
		private final MatchingFailureType_choice choice; //TTCN3_Choice_Type
		private final MatchingFailureType_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString info; //CharString_Type

		public MatchingFailureType() {
			port__type = new PortType();
			port__name = new TitanCharString();
			choice = new MatchingFailureType_choice();
			reason = new MatchingFailureType_reason();
			info = new TitanCharString();
		}

		public MatchingFailureType( final PortType aPort__type, final TitanCharString aPort__name, final MatchingFailureType_choice aChoice, final MatchingFailureType_reason aReason, final TitanCharString aInfo ) {
			port__type = new PortType( aPort__type );
			port__name = new TitanCharString( aPort__name );
			choice = new MatchingFailureType_choice( aChoice );
			reason = new MatchingFailureType_reason( aReason );
			info = new TitanCharString( aInfo );
		}

		public MatchingFailureType( final MatchingFailureType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingFailureType.");
			}
			port__type = new PortType();
			port__name = new TitanCharString();
			choice = new MatchingFailureType_choice();
			reason = new MatchingFailureType_reason();
			info = new TitanCharString();
			assign( aOtherValue );
		}
		public MatchingFailureType assign(final MatchingFailureType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingFailureType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__type().isBound() ) {
					this.port__type.assign( aOtherValue.getPort__type() );
				} else {
					this.port__type.cleanUp();
				}
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getInfo().isBound() ) {
					this.info.assign( aOtherValue.getInfo() );
				} else {
					this.info.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingFailureType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingFailureType ) {
				return assign((MatchingFailureType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingFailureType", otherValue));
		}

		public void cleanUp() {
			port__type.cleanUp();
			port__name.cleanUp();
			choice.cleanUp();
			reason.cleanUp();
			info.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__type.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( choice.isBound() ) { return true; }
			if ( reason.isBound() ) { return true; }
			if ( info.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__type.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !choice.isValue() ) { return false; }
			if ( !reason.isValue() ) { return false; }
			if ( !info.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingFailureType aOtherValue ) {
			if ( !this.port__type.operatorEquals( aOtherValue.port__type ) ) { return false; }
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.info.operatorEquals( aOtherValue.info ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingFailureType ) {
				return operatorEquals((MatchingFailureType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingFailureType", otherValue));
		}

		public PortType getPort__type() {
			return port__type;
		}

		public PortType constGetPort__type() {
			return port__type;
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public MatchingFailureType_choice getChoice() {
			return choice;
		}

		public MatchingFailureType_choice constGetChoice() {
			return choice;
		}

		public MatchingFailureType_reason getReason() {
			return reason;
		}

		public MatchingFailureType_reason constGetReason() {
			return reason;
		}

		public TitanCharString getInfo() {
			return info;
		}

		public TitanCharString constGetInfo() {
			return info;
		}

		public TitanInteger sizeOf() {
			int sizeof = 5;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_type := ");
			port__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" info := ");
			info.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__type.isBound()) {
				port__type.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (info.isBound()) {
				info.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__type.encode_text(text_buf);
			port__name.encode_text(text_buf);
			choice.encode_text(text_buf);
			reason.encode_text(text_buf);
			info.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__type.decode_text(text_buf);
			port__name.decode_text(text_buf);
			choice.decode_text(text_buf);
			reason.decode_text(text_buf);
			info.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class MatchingFailureType_template extends Base_Template {

	private PortType_template port__type; //Referenced_Type
	private TitanCharString_template port__name; //CharString_Type
	private MatchingFailureType_choice_template choice; //TTCN3_Choice_Type
	private MatchingFailureType_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template info; //CharString_Type
	//originally value_list/list_value
	List<MatchingFailureType_template> list_value;

	public PortType_template getPort__type() {
		setSpecific();
		return port__type;
	}

	public PortType_template constGetPort__type() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_type of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
		}
		return port__type;
	}

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
		}
		return port__name;
	}

	public MatchingFailureType_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public MatchingFailureType_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
		}
		return choice;
	}

	public MatchingFailureType_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public MatchingFailureType_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
		}
		return reason;
	}

	public TitanCharString_template getInfo() {
		setSpecific();
		return info;
	}

	public TitanCharString_template constGetInfo() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field info of a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
		}
		return info;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__type = new PortType_template();
			port__name = new TitanCharString_template();
			choice = new MatchingFailureType_choice_template();
			reason = new MatchingFailureType_reason_template();
			info = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__type.assign(template_sel.ANY_VALUE);
				port__name.assign(template_sel.ANY_VALUE);
				choice.assign(template_sel.ANY_VALUE);
				reason.assign(template_sel.ANY_VALUE);
				info.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public MatchingFailureType_template() {
	}

	public MatchingFailureType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public MatchingFailureType_template( final MatchingFailureType otherValue ) {
		copyValue(otherValue);
	}

	public MatchingFailureType_template( final MatchingFailureType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public MatchingFailureType_template( final Optional<MatchingFailureType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingFailureType from an unbound optional field.");
		}
	}

	//originally operator=
	public MatchingFailureType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public MatchingFailureType_template assign( final MatchingFailureType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public MatchingFailureType_template assign( final MatchingFailureType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public MatchingFailureType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingFailureType) {
				return assign((MatchingFailureType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingFailureType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingFailureType_template) {
				return assign((MatchingFailureType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingFailureType' can not be cast to {1}_template", otherValue));
		}

	public MatchingFailureType_template assign( final Optional<MatchingFailureType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingFailureType.");
		}
		return this;
	}

	private void copyValue(final MatchingFailureType other_value) {
		if (other_value.getPort__type().isBound()) {
			getPort__type().assign(other_value.getPort__type());
		} else {
			getPort__type().cleanUp();
		}
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getInfo().isBound()) {
			getInfo().assign(other_value.getInfo());
		} else {
			getInfo().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final MatchingFailureType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__type().get_selection()) {
				getPort__type().cleanUp();
			} else {
				getPort__type().assign(other_value.getPort__type());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getInfo().get_selection()) {
				getInfo().cleanUp();
			} else {
				getInfo().assign(other_value.getInfo());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<MatchingFailureType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final MatchingFailureType_template temp = new MatchingFailureType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingFailureType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingFailureType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingFailureType.");
			}
			final MatchingFailureType ret_val = new MatchingFailureType();
			 if (port__type.isBound()) {
				ret_val.port__type.assign(port__type.valueOf());
			}
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (info.isBound()) {
				ret_val.info.assign(info.valueOf());
			}
			return ret_val;
		}

		public MatchingFailureType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingFailureType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingFailureType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingFailureType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingFailureType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingFailureType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__type.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (info.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__type.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!info.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingFailureType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingFailureType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__type().isBound()) {
					return false;
				}
				if(!port__type.match(other_value.getPort__type(), legacy)) {
					return false;
				}
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getInfo().isBound()) {
					return false;
				}
				if(!info.match(other_value.getInfo(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingFailureType) {
		return match((MatchingFailureType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingFailureType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 5;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingFailureType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_type := ");
				port__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" info := ");
				info.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingFailureType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingFailureType) {
				log_match((MatchingFailureType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingFailureType.");
		}

		public void log_match(final MatchingFailureType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__type.match(match_value.constGetPort__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_type");
							port__type.log_match(match_value.constGetPort__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !info.match(match_value.constGetInfo(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".info");
							info.log_match(match_value.constGetInfo(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_type := ");
				port__type.log_match(match_value.constGetPort__type(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ info := ");
				info.log_match(match_value.constGetInfo(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type.encode_text(text_buf);
				port__name.encode_text(text_buf);
				choice.encode_text(text_buf);
				reason.encode_text(text_buf);
				info.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__type = new PortType_template();
				port__type.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				choice = new MatchingFailureType_choice_template();
				choice.decode_text(text_buf);
				reason = new MatchingFailureType_reason_template();
				reason.decode_text(text_buf);
				info = new TitanCharString_template();
				info.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingFailureType_template>(size);
				for(int i = 0; i < size; i++) {
					final MatchingFailureType_template temp = new MatchingFailureType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingFailureType.");
			}
		}
}
public static void MatchingFailureType_encoder(final MatchingFailureType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_decoder( final TitanOctetString input_stream, final MatchingFailureType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingFailureType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingProblemType_check___encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingProblemType_check___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingProblemType_check___decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingProblemType_check___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LocationInfo_ent__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LocationInfo_ent__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LocationInfo_ent__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LocationInfo_ent__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingEvent_choice_matchingDone_encoder(final MatchingDoneType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_choice_matchingDone_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_choice_matchingDone_decoder( final TitanOctetString input_stream, final MatchingDoneType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_choice_matchingDone_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__recv_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_timeoutAnyTimer_encoder(final TimerAnyTimeoutType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_timeoutAnyTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_timeoutAnyTimer_decoder( final TitanOctetString input_stream, final TimerAnyTimeoutType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerAnyTimeoutType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_timeoutAnyTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingFailureType_info_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_info_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_info_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_info_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void DefaultEvent_choice_defaultopDeactivate_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultEvent_choice_defaultopDeactivate_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultEvent_choice_defaultopDeactivate_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultEvent_choice_defaultopDeactivate_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_new__verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_new__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_new__verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_new__verdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Parallel_dst__port_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_dst__port_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_dst__port_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_dst__port_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_ptc__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_ptc__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_ptc__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_ptc__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Queue_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TestcaseEvent_choice_testcaseStarted_encoder(final QualifiedName input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseEvent_choice_testcaseStarted_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseEvent_choice_testcaseStarted_decoder( final TitanOctetString input_stream, final QualifiedName output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.QualifiedName' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseEvent_choice_testcaseStarted_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictInfo_ptc__compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictInfo_ptc__compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictInfo_ptc__compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictInfo_ptc__compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ParPort extends Base_Type {
		private final ParPort_operation operation; //TTCN3_Enumerated_Type
		private final TitanInteger srcCompref; //Integer_Type
		private final TitanInteger dstCompref; //Integer_Type
		private final TitanCharString srcPort; //CharString_Type
		private final TitanCharString dstPort; //CharString_Type

		public ParPort() {
			operation = new ParPort_operation();
			srcCompref = new TitanInteger();
			dstCompref = new TitanInteger();
			srcPort = new TitanCharString();
			dstPort = new TitanCharString();
		}

		public ParPort( final ParPort_operation aOperation, final TitanInteger aSrcCompref, final TitanInteger aDstCompref, final TitanCharString aSrcPort, final TitanCharString aDstPort ) {
			operation = new ParPort_operation( aOperation );
			srcCompref = new TitanInteger( aSrcCompref );
			dstCompref = new TitanInteger( aDstCompref );
			srcPort = new TitanCharString( aSrcPort );
			dstPort = new TitanCharString( aDstPort );
		}

		public ParPort( final ParPort aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ParPort.");
			}
			operation = new ParPort_operation();
			srcCompref = new TitanInteger();
			dstCompref = new TitanInteger();
			srcPort = new TitanCharString();
			dstPort = new TitanCharString();
			assign( aOtherValue );
		}
		public ParPort assign(final ParPort aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ParPort");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getSrcCompref().isBound() ) {
					this.srcCompref.assign( aOtherValue.getSrcCompref() );
				} else {
					this.srcCompref.cleanUp();
				}
				if ( aOtherValue.getDstCompref().isBound() ) {
					this.dstCompref.assign( aOtherValue.getDstCompref() );
				} else {
					this.dstCompref.cleanUp();
				}
				if ( aOtherValue.getSrcPort().isBound() ) {
					this.srcPort.assign( aOtherValue.getSrcPort() );
				} else {
					this.srcPort.cleanUp();
				}
				if ( aOtherValue.getDstPort().isBound() ) {
					this.dstPort.assign( aOtherValue.getDstPort() );
				} else {
					this.dstPort.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ParPort assign(final Base_Type otherValue) {
			if (otherValue instanceof ParPort ) {
				return assign((ParPort) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParPort", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			srcCompref.cleanUp();
			dstCompref.cleanUp();
			srcPort.cleanUp();
			dstPort.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( srcCompref.isBound() ) { return true; }
			if ( dstCompref.isBound() ) { return true; }
			if ( srcPort.isBound() ) { return true; }
			if ( dstPort.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !srcCompref.isValue() ) { return false; }
			if ( !dstCompref.isValue() ) { return false; }
			if ( !srcPort.isValue() ) { return false; }
			if ( !dstPort.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ParPort aOtherValue ) {
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.srcCompref.operatorEquals( aOtherValue.srcCompref ) ) { return false; }
			if ( !this.dstCompref.operatorEquals( aOtherValue.dstCompref ) ) { return false; }
			if ( !this.srcPort.operatorEquals( aOtherValue.srcPort ) ) { return false; }
			if ( !this.dstPort.operatorEquals( aOtherValue.dstPort ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ParPort ) {
				return operatorEquals((ParPort) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParPort", otherValue));
		}

		public ParPort_operation getOperation() {
			return operation;
		}

		public ParPort_operation constGetOperation() {
			return operation;
		}

		public TitanInteger getSrcCompref() {
			return srcCompref;
		}

		public TitanInteger constGetSrcCompref() {
			return srcCompref;
		}

		public TitanInteger getDstCompref() {
			return dstCompref;
		}

		public TitanInteger constGetDstCompref() {
			return dstCompref;
		}

		public TitanCharString getSrcPort() {
			return srcPort;
		}

		public TitanCharString constGetSrcPort() {
			return srcPort;
		}

		public TitanCharString getDstPort() {
			return dstPort;
		}

		public TitanCharString constGetDstPort() {
			return dstPort;
		}

		public TitanInteger sizeOf() {
			int sizeof = 5;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" srcCompref := ");
			srcCompref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dstCompref := ");
			dstCompref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" srcPort := ");
			srcPort.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dstPort := ");
			dstPort.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (srcCompref.isBound()) {
				srcCompref.set_implicit_omit();
			}
			if (dstCompref.isBound()) {
				dstCompref.set_implicit_omit();
			}
			if (srcPort.isBound()) {
				srcPort.set_implicit_omit();
			}
			if (dstPort.isBound()) {
				dstPort.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			srcCompref.encode_text(text_buf);
			dstCompref.encode_text(text_buf);
			srcPort.encode_text(text_buf);
			dstPort.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			srcCompref.decode_text(text_buf);
			dstCompref.decode_text(text_buf);
			srcPort.decode_text(text_buf);
			dstPort.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ParPort_template extends Base_Template {

	private ParPort_operation_template operation; //TTCN3_Enumerated_Type
	private TitanInteger_template srcCompref; //Integer_Type
	private TitanInteger_template dstCompref; //Integer_Type
	private TitanCharString_template srcPort; //CharString_Type
	private TitanCharString_template dstPort; //CharString_Type
	//originally value_list/list_value
	List<ParPort_template> list_value;

	public ParPort_operation_template getOperation() {
		setSpecific();
		return operation;
	}

	public ParPort_operation_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.ParPort.");
		}
		return operation;
	}

	public TitanInteger_template getSrcCompref() {
		setSpecific();
		return srcCompref;
	}

	public TitanInteger_template constGetSrcCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field srcCompref of a non-specific template of type @TitanLoggerApi.ParPort.");
		}
		return srcCompref;
	}

	public TitanInteger_template getDstCompref() {
		setSpecific();
		return dstCompref;
	}

	public TitanInteger_template constGetDstCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field dstCompref of a non-specific template of type @TitanLoggerApi.ParPort.");
		}
		return dstCompref;
	}

	public TitanCharString_template getSrcPort() {
		setSpecific();
		return srcPort;
	}

	public TitanCharString_template constGetSrcPort() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field srcPort of a non-specific template of type @TitanLoggerApi.ParPort.");
		}
		return srcPort;
	}

	public TitanCharString_template getDstPort() {
		setSpecific();
		return dstPort;
	}

	public TitanCharString_template constGetDstPort() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field dstPort of a non-specific template of type @TitanLoggerApi.ParPort.");
		}
		return dstPort;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			operation = new ParPort_operation_template();
			srcCompref = new TitanInteger_template();
			dstCompref = new TitanInteger_template();
			srcPort = new TitanCharString_template();
			dstPort = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				operation.assign(template_sel.ANY_VALUE);
				srcCompref.assign(template_sel.ANY_VALUE);
				dstCompref.assign(template_sel.ANY_VALUE);
				srcPort.assign(template_sel.ANY_VALUE);
				dstPort.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ParPort_template() {
	}

	public ParPort_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ParPort_template( final ParPort otherValue ) {
		copyValue(otherValue);
	}

	public ParPort_template( final ParPort_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ParPort_template( final Optional<ParPort> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ParPort from an unbound optional field.");
		}
	}

	//originally operator=
	public ParPort_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ParPort_template assign( final ParPort other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ParPort_template assign( final ParPort_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ParPort_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ParPort) {
				return assign((ParPort) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort' can not be cast to {1}", otherValue));
		}

		@Override
		public ParPort_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ParPort_template) {
				return assign((ParPort_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParPort' can not be cast to {1}_template", otherValue));
		}

	public ParPort_template assign( final Optional<ParPort> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ParPort.");
		}
		return this;
	}

	private void copyValue(final ParPort other_value) {
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getSrcCompref().isBound()) {
			getSrcCompref().assign(other_value.getSrcCompref());
		} else {
			getSrcCompref().cleanUp();
		}
		if (other_value.getDstCompref().isBound()) {
			getDstCompref().assign(other_value.getDstCompref());
		} else {
			getDstCompref().cleanUp();
		}
		if (other_value.getSrcPort().isBound()) {
			getSrcPort().assign(other_value.getSrcPort());
		} else {
			getSrcPort().cleanUp();
		}
		if (other_value.getDstPort().isBound()) {
			getDstPort().assign(other_value.getDstPort());
		} else {
			getDstPort().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ParPort_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSrcCompref().get_selection()) {
				getSrcCompref().cleanUp();
			} else {
				getSrcCompref().assign(other_value.getSrcCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getDstCompref().get_selection()) {
				getDstCompref().cleanUp();
			} else {
				getDstCompref().assign(other_value.getDstCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSrcPort().get_selection()) {
				getSrcPort().cleanUp();
			} else {
				getSrcPort().assign(other_value.getSrcPort());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getDstPort().get_selection()) {
				getDstPort().cleanUp();
			} else {
				getDstPort().assign(other_value.getDstPort());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ParPort_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ParPort_template temp = new ParPort_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ParPort.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ParPort valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ParPort.");
			}
			final ParPort ret_val = new ParPort();
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (srcCompref.isBound()) {
				ret_val.srcCompref.assign(srcCompref.valueOf());
			}
			 if (dstCompref.isBound()) {
				ret_val.dstCompref.assign(dstCompref.valueOf());
			}
			 if (srcPort.isBound()) {
				ret_val.srcPort.assign(srcPort.valueOf());
			}
			 if (dstPort.isBound()) {
				ret_val.dstPort.assign(dstPort.valueOf());
			}
			return ret_val;
		}

		public ParPort_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ParPort.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ParPort.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ParPort.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ParPort_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ParPort_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (srcCompref.isBound()) {
				return true;
			}
			if (dstCompref.isBound()) {
				return true;
			}
			if (srcPort.isBound()) {
				return true;
			}
			if (dstPort.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!srcCompref.isValue()) {
				return false;
			}
			if (!dstCompref.isValue()) {
				return false;
			}
			if (!srcPort.isValue()) {
				return false;
			}
			if (!dstPort.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ParPort other_value) {
			return match(other_value, false);
		}

		public boolean match(final ParPort other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getSrcCompref().isBound()) {
					return false;
				}
				if(!srcCompref.match(other_value.getSrcCompref(), legacy)) {
					return false;
				}
				if(!other_value.getDstCompref().isBound()) {
					return false;
				}
				if(!dstCompref.match(other_value.getDstCompref(), legacy)) {
					return false;
				}
				if(!other_value.getSrcPort().isBound()) {
					return false;
				}
				if(!srcPort.match(other_value.getSrcPort(), legacy)) {
					return false;
				}
				if(!other_value.getDstPort().isBound()) {
					return false;
				}
				if(!dstPort.match(other_value.getDstPort(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ParPort.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ParPort) {
		return match((ParPort)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ParPort.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 5;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParPort containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ParPort.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" srcCompref := ");
				srcCompref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dstCompref := ");
				dstCompref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" srcPort := ");
				srcPort.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dstPort := ");
				dstPort.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ParPort match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParPort) {
				log_match((ParPort)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParPort.");
		}

		public void log_match(final ParPort match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !srcCompref.match(match_value.constGetSrcCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".srcCompref");
							srcCompref.log_match(match_value.constGetSrcCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dstCompref.match(match_value.constGetDstCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dstCompref");
							dstCompref.log_match(match_value.constGetDstCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !srcPort.match(match_value.constGetSrcPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".srcPort");
							srcPort.log_match(match_value.constGetSrcPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dstPort.match(match_value.constGetDstPort(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dstPort");
							dstPort.log_match(match_value.constGetDstPort(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ srcCompref := ");
				srcCompref.log_match(match_value.constGetSrcCompref(), legacy);
				TTCN_Logger.log_event_str("{ dstCompref := ");
				dstCompref.log_match(match_value.constGetDstCompref(), legacy);
				TTCN_Logger.log_event_str("{ srcPort := ");
				srcPort.log_match(match_value.constGetSrcPort(), legacy);
				TTCN_Logger.log_event_str("{ dstPort := ");
				dstPort.log_match(match_value.constGetDstPort(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				srcCompref.encode_text(text_buf);
				dstCompref.encode_text(text_buf);
				srcPort.encode_text(text_buf);
				dstPort.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ParPort.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new ParPort_operation_template();
				operation.decode_text(text_buf);
				srcCompref = new TitanInteger_template();
				srcCompref.decode_text(text_buf);
				dstCompref = new TitanInteger_template();
				dstCompref.decode_text(text_buf);
				srcPort = new TitanCharString_template();
				srcPort.decode_text(text_buf);
				dstPort = new TitanCharString_template();
				dstPort.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ParPort_template>(size);
				for(int i = 0; i < size; i++) {
					final ParPort_template temp = new ParPort_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ParPort.");
			}
		}
}
public static void ParPort_encoder(final ParPort input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParPort_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParPort_decoder( final TitanOctetString input_stream, final ParPort output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParPort' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParPort_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_actionEvent_encoder(final Strings input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_actionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_actionEvent_decoder( final TitanOctetString input_stream, final Strings output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_actionEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class MatchingDoneType extends Base_Type {
		private final MatchingDoneType_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString type__; //CharString_Type
		private final TitanInteger ptc; //Integer_Type
		private final TitanCharString return__type; //CharString_Type

		public MatchingDoneType() {
			reason = new MatchingDoneType_reason();
			type__ = new TitanCharString();
			ptc = new TitanInteger();
			return__type = new TitanCharString();
		}

		public MatchingDoneType( final MatchingDoneType_reason aReason, final TitanCharString aType__, final TitanInteger aPtc, final TitanCharString aReturn__type ) {
			reason = new MatchingDoneType_reason( aReason );
			type__ = new TitanCharString( aType__ );
			ptc = new TitanInteger( aPtc );
			return__type = new TitanCharString( aReturn__type );
		}

		public MatchingDoneType( final MatchingDoneType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingDoneType.");
			}
			reason = new MatchingDoneType_reason();
			type__ = new TitanCharString();
			ptc = new TitanInteger();
			return__type = new TitanCharString();
			assign( aOtherValue );
		}
		public MatchingDoneType assign(final MatchingDoneType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingDoneType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getType__().isBound() ) {
					this.type__.assign( aOtherValue.getType__() );
				} else {
					this.type__.cleanUp();
				}
				if ( aOtherValue.getPtc().isBound() ) {
					this.ptc.assign( aOtherValue.getPtc() );
				} else {
					this.ptc.cleanUp();
				}
				if ( aOtherValue.getReturn__type().isBound() ) {
					this.return__type.assign( aOtherValue.getReturn__type() );
				} else {
					this.return__type.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingDoneType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingDoneType ) {
				return assign((MatchingDoneType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingDoneType", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			type__.cleanUp();
			ptc.cleanUp();
			return__type.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( type__.isBound() ) { return true; }
			if ( ptc.isBound() ) { return true; }
			if ( return__type.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !type__.isValue() ) { return false; }
			if ( !ptc.isValue() ) { return false; }
			if ( !return__type.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingDoneType aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.type__.operatorEquals( aOtherValue.type__ ) ) { return false; }
			if ( !this.ptc.operatorEquals( aOtherValue.ptc ) ) { return false; }
			if ( !this.return__type.operatorEquals( aOtherValue.return__type ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingDoneType ) {
				return operatorEquals((MatchingDoneType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingDoneType", otherValue));
		}

		public MatchingDoneType_reason getReason() {
			return reason;
		}

		public MatchingDoneType_reason constGetReason() {
			return reason;
		}

		public TitanCharString getType__() {
			return type__;
		}

		public TitanCharString constGetType__() {
			return type__;
		}

		public TitanInteger getPtc() {
			return ptc;
		}

		public TitanInteger constGetPtc() {
			return ptc;
		}

		public TitanCharString getReturn__type() {
			return return__type;
		}

		public TitanCharString constGetReturn__type() {
			return return__type;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" type_ := ");
			type__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" ptc := ");
			ptc.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" return_type := ");
			return__type.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (type__.isBound()) {
				type__.set_implicit_omit();
			}
			if (ptc.isBound()) {
				ptc.set_implicit_omit();
			}
			if (return__type.isBound()) {
				return__type.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			type__.encode_text(text_buf);
			ptc.encode_text(text_buf);
			return__type.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			type__.decode_text(text_buf);
			ptc.decode_text(text_buf);
			return__type.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class MatchingDoneType_template extends Base_Template {

	private MatchingDoneType_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template type__; //CharString_Type
	private TitanInteger_template ptc; //Integer_Type
	private TitanCharString_template return__type; //CharString_Type
	//originally value_list/list_value
	List<MatchingDoneType_template> list_value;

	public MatchingDoneType_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public MatchingDoneType_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
		}
		return reason;
	}

	public TitanCharString_template getType__() {
		setSpecific();
		return type__;
	}

	public TitanCharString_template constGetType__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field type_ of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
		}
		return type__;
	}

	public TitanInteger_template getPtc() {
		setSpecific();
		return ptc;
	}

	public TitanInteger_template constGetPtc() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field ptc of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
		}
		return ptc;
	}

	public TitanCharString_template getReturn__type() {
		setSpecific();
		return return__type;
	}

	public TitanCharString_template constGetReturn__type() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field return_type of a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
		}
		return return__type;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new MatchingDoneType_reason_template();
			type__ = new TitanCharString_template();
			ptc = new TitanInteger_template();
			return__type = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				type__.assign(template_sel.ANY_VALUE);
				ptc.assign(template_sel.ANY_VALUE);
				return__type.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public MatchingDoneType_template() {
	}

	public MatchingDoneType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public MatchingDoneType_template( final MatchingDoneType otherValue ) {
		copyValue(otherValue);
	}

	public MatchingDoneType_template( final MatchingDoneType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public MatchingDoneType_template( final Optional<MatchingDoneType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingDoneType from an unbound optional field.");
		}
	}

	//originally operator=
	public MatchingDoneType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public MatchingDoneType_template assign( final MatchingDoneType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public MatchingDoneType_template assign( final MatchingDoneType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public MatchingDoneType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingDoneType) {
				return assign((MatchingDoneType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingDoneType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingDoneType_template) {
				return assign((MatchingDoneType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingDoneType' can not be cast to {1}_template", otherValue));
		}

	public MatchingDoneType_template assign( final Optional<MatchingDoneType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingDoneType.");
		}
		return this;
	}

	private void copyValue(final MatchingDoneType other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getType__().isBound()) {
			getType__().assign(other_value.getType__());
		} else {
			getType__().cleanUp();
		}
		if (other_value.getPtc().isBound()) {
			getPtc().assign(other_value.getPtc());
		} else {
			getPtc().cleanUp();
		}
		if (other_value.getReturn__type().isBound()) {
			getReturn__type().assign(other_value.getReturn__type());
		} else {
			getReturn__type().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final MatchingDoneType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getType__().get_selection()) {
				getType__().cleanUp();
			} else {
				getType__().assign(other_value.getType__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPtc().get_selection()) {
				getPtc().cleanUp();
			} else {
				getPtc().assign(other_value.getPtc());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReturn__type().get_selection()) {
				getReturn__type().cleanUp();
			} else {
				getReturn__type().assign(other_value.getReturn__type());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<MatchingDoneType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final MatchingDoneType_template temp = new MatchingDoneType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingDoneType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingDoneType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingDoneType.");
			}
			final MatchingDoneType ret_val = new MatchingDoneType();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (type__.isBound()) {
				ret_val.type__.assign(type__.valueOf());
			}
			 if (ptc.isBound()) {
				ret_val.ptc.assign(ptc.valueOf());
			}
			 if (return__type.isBound()) {
				ret_val.return__type.assign(return__type.valueOf());
			}
			return ret_val;
		}

		public MatchingDoneType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingDoneType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingDoneType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingDoneType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingDoneType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingDoneType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (type__.isBound()) {
				return true;
			}
			if (ptc.isBound()) {
				return true;
			}
			if (return__type.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!type__.isValue()) {
				return false;
			}
			if (!ptc.isValue()) {
				return false;
			}
			if (!return__type.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingDoneType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingDoneType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getType__().isBound()) {
					return false;
				}
				if(!type__.match(other_value.getType__(), legacy)) {
					return false;
				}
				if(!other_value.getPtc().isBound()) {
					return false;
				}
				if(!ptc.match(other_value.getPtc(), legacy)) {
					return false;
				}
				if(!other_value.getReturn__type().isBound()) {
					return false;
				}
				if(!return__type.match(other_value.getReturn__type(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingDoneType) {
		return match((MatchingDoneType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingDoneType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingDoneType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" type_ := ");
				type__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" ptc := ");
				ptc.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" return_type := ");
				return__type.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingDoneType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingDoneType) {
				log_match((MatchingDoneType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingDoneType.");
		}

		public void log_match(final MatchingDoneType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !type__.match(match_value.constGetType__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".type_");
							type__.log_match(match_value.constGetType__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !ptc.match(match_value.constGetPtc(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".ptc");
							ptc.log_match(match_value.constGetPtc(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !return__type.match(match_value.constGetReturn__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".return_type");
							return__type.log_match(match_value.constGetReturn__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ type_ := ");
				type__.log_match(match_value.constGetType__(), legacy);
				TTCN_Logger.log_event_str("{ ptc := ");
				ptc.log_match(match_value.constGetPtc(), legacy);
				TTCN_Logger.log_event_str("{ return_type := ");
				return__type.log_match(match_value.constGetReturn__type(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				type__.encode_text(text_buf);
				ptc.encode_text(text_buf);
				return__type.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new MatchingDoneType_reason_template();
				reason.decode_text(text_buf);
				type__ = new TitanCharString_template();
				type__.decode_text(text_buf);
				ptc = new TitanInteger_template();
				ptc.decode_text(text_buf);
				return__type = new TitanCharString_template();
				return__type.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingDoneType_template>(size);
				for(int i = 0; i < size; i++) {
					final MatchingDoneType_template temp = new MatchingDoneType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingDoneType.");
			}
		}
}
public static void MatchingDoneType_encoder(final MatchingDoneType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingDoneType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingDoneType_decoder( final TitanOctetString input_stream, final MatchingDoneType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingDoneType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingDoneType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanLog_sequence__list_0_event__list_0_encoder(final TitanLogEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLog_sequence__list_0_event__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLog_sequence__list_0_event__list_0_decoder( final TitanOctetString input_stream, final TitanLogEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLogEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLog_sequence__list_0_event__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingFailureType_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingFailureType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingFailureType_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingFailureType_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TestcaseType_reason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseType_reason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseType_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Port__Queue extends Base_Type {
		private final Port__Queue_operation operation; //TTCN3_Enumerated_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanInteger msgid; //Integer_Type
		private final TitanCharString address__; //CharString_Type
		private final TitanCharString param__; //CharString_Type

		public Port__Queue() {
			operation = new Port__Queue_operation();
			port__name = new TitanCharString();
			compref = new TitanInteger();
			msgid = new TitanInteger();
			address__ = new TitanCharString();
			param__ = new TitanCharString();
		}

		public Port__Queue( final Port__Queue_operation aOperation, final TitanCharString aPort__name, final TitanInteger aCompref, final TitanInteger aMsgid, final TitanCharString aAddress__, final TitanCharString aParam__ ) {
			operation = new Port__Queue_operation( aOperation );
			port__name = new TitanCharString( aPort__name );
			compref = new TitanInteger( aCompref );
			msgid = new TitanInteger( aMsgid );
			address__ = new TitanCharString( aAddress__ );
			param__ = new TitanCharString( aParam__ );
		}

		public Port__Queue( final Port__Queue aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Port_Queue.");
			}
			operation = new Port__Queue_operation();
			port__name = new TitanCharString();
			compref = new TitanInteger();
			msgid = new TitanInteger();
			address__ = new TitanCharString();
			param__ = new TitanCharString();
			assign( aOtherValue );
		}
		public Port__Queue assign(final Port__Queue aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Port_Queue");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getMsgid().isBound() ) {
					this.msgid.assign( aOtherValue.getMsgid() );
				} else {
					this.msgid.cleanUp();
				}
				if ( aOtherValue.getAddress__().isBound() ) {
					this.address__.assign( aOtherValue.getAddress__() );
				} else {
					this.address__.cleanUp();
				}
				if ( aOtherValue.getParam__().isBound() ) {
					this.param__.assign( aOtherValue.getParam__() );
				} else {
					this.param__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Port__Queue assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Queue ) {
				return assign((Port__Queue) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Queue", otherValue));
		}

		public void cleanUp() {
			operation.cleanUp();
			port__name.cleanUp();
			compref.cleanUp();
			msgid.cleanUp();
			address__.cleanUp();
			param__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( operation.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			if ( address__.isBound() ) { return true; }
			if ( param__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !operation.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			if ( !address__.isValue() ) { return false; }
			if ( !param__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Port__Queue aOtherValue ) {
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.msgid.operatorEquals( aOtherValue.msgid ) ) { return false; }
			if ( !this.address__.operatorEquals( aOtherValue.address__ ) ) { return false; }
			if ( !this.param__.operatorEquals( aOtherValue.param__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Port__Queue ) {
				return operatorEquals((Port__Queue) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Port_Queue", otherValue));
		}

		public Port__Queue_operation getOperation() {
			return operation;
		}

		public Port__Queue_operation constGetOperation() {
			return operation;
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanInteger getMsgid() {
			return msgid;
		}

		public TitanInteger constGetMsgid() {
			return msgid;
		}

		public TitanCharString getAddress__() {
			return address__;
		}

		public TitanCharString constGetAddress__() {
			return address__;
		}

		public TitanCharString getParam__() {
			return param__;
		}

		public TitanCharString constGetParam__() {
			return param__;
		}

		public TitanInteger sizeOf() {
			int sizeof = 6;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" address_ := ");
			address__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" param_ := ");
			param__.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
			if (address__.isBound()) {
				address__.set_implicit_omit();
			}
			if (param__.isBound()) {
				param__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			operation.encode_text(text_buf);
			port__name.encode_text(text_buf);
			compref.encode_text(text_buf);
			msgid.encode_text(text_buf);
			address__.encode_text(text_buf);
			param__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			operation.decode_text(text_buf);
			port__name.decode_text(text_buf);
			compref.decode_text(text_buf);
			msgid.decode_text(text_buf);
			address__.decode_text(text_buf);
			param__.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Port__Queue_template extends Base_Template {

	private Port__Queue_operation_template operation; //TTCN3_Enumerated_Type
	private TitanCharString_template port__name; //CharString_Type
	private TitanInteger_template compref; //Integer_Type
	private TitanInteger_template msgid; //Integer_Type
	private TitanCharString_template address__; //CharString_Type
	private TitanCharString_template param__; //CharString_Type
	//originally value_list/list_value
	List<Port__Queue_template> list_value;

	public Port__Queue_operation_template getOperation() {
		setSpecific();
		return operation;
	}

	public Port__Queue_operation_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Port_Queue.");
		}
		return operation;
	}

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Port_Queue.");
		}
		return port__name;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Port_Queue.");
		}
		return compref;
	}

	public TitanInteger_template getMsgid() {
		setSpecific();
		return msgid;
	}

	public TitanInteger_template constGetMsgid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Port_Queue.");
		}
		return msgid;
	}

	public TitanCharString_template getAddress__() {
		setSpecific();
		return address__;
	}

	public TitanCharString_template constGetAddress__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field address_ of a non-specific template of type @TitanLoggerApi.Port_Queue.");
		}
		return address__;
	}

	public TitanCharString_template getParam__() {
		setSpecific();
		return param__;
	}

	public TitanCharString_template constGetParam__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field param_ of a non-specific template of type @TitanLoggerApi.Port_Queue.");
		}
		return param__;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			operation = new Port__Queue_operation_template();
			port__name = new TitanCharString_template();
			compref = new TitanInteger_template();
			msgid = new TitanInteger_template();
			address__ = new TitanCharString_template();
			param__ = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				operation.assign(template_sel.ANY_VALUE);
				port__name.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				msgid.assign(template_sel.ANY_VALUE);
				address__.assign(template_sel.ANY_VALUE);
				param__.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Port__Queue_template() {
	}

	public Port__Queue_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Port__Queue_template( final Port__Queue otherValue ) {
		copyValue(otherValue);
	}

	public Port__Queue_template( final Port__Queue_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Port__Queue_template( final Optional<Port__Queue> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Port_Queue from an unbound optional field.");
		}
	}

	//originally operator=
	public Port__Queue_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Port__Queue_template assign( final Port__Queue other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Port__Queue_template assign( final Port__Queue_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Port__Queue_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Port__Queue) {
				return assign((Port__Queue) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue' can not be cast to {1}", otherValue));
		}

		@Override
		public Port__Queue_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Port__Queue_template) {
				return assign((Port__Queue_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue' can not be cast to {1}_template", otherValue));
		}

	public Port__Queue_template assign( final Optional<Port__Queue> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Port_Queue.");
		}
		return this;
	}

	private void copyValue(final Port__Queue other_value) {
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getMsgid().isBound()) {
			getMsgid().assign(other_value.getMsgid());
		} else {
			getMsgid().cleanUp();
		}
		if (other_value.getAddress__().isBound()) {
			getAddress__().assign(other_value.getAddress__());
		} else {
			getAddress__().cleanUp();
		}
		if (other_value.getParam__().isBound()) {
			getParam__().assign(other_value.getParam__());
		} else {
			getParam__().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Port__Queue_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getMsgid().get_selection()) {
				getMsgid().cleanUp();
			} else {
				getMsgid().assign(other_value.getMsgid());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getAddress__().get_selection()) {
				getAddress__().cleanUp();
			} else {
				getAddress__().assign(other_value.getAddress__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParam__().get_selection()) {
				getParam__().cleanUp();
			} else {
				getParam__().assign(other_value.getParam__());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Port__Queue_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Port__Queue_template temp = new Port__Queue_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Port_Queue.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Port__Queue valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Port_Queue.");
			}
			final Port__Queue ret_val = new Port__Queue();
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (msgid.isBound()) {
				ret_val.msgid.assign(msgid.valueOf());
			}
			 if (address__.isBound()) {
				ret_val.address__.assign(address__.valueOf());
			}
			 if (param__.isBound()) {
				ret_val.param__.assign(param__.valueOf());
			}
			return ret_val;
		}

		public Port__Queue_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Port_Queue.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Port_Queue.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Port_Queue.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Port__Queue_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Port__Queue_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			if (address__.isBound()) {
				return true;
			}
			if (param__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			if (!address__.isValue()) {
				return false;
			}
			if (!param__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Port__Queue other_value) {
			return match(other_value, false);
		}

		public boolean match(final Port__Queue other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getMsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getMsgid(), legacy)) {
					return false;
				}
				if(!other_value.getAddress__().isBound()) {
					return false;
				}
				if(!address__.match(other_value.getAddress__(), legacy)) {
					return false;
				}
				if(!other_value.getParam__().isBound()) {
					return false;
				}
				if(!param__.match(other_value.getParam__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Port_Queue.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Port__Queue) {
		return match((Port__Queue)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Port__Queue.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 6;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Port_Queue containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Port_Queue.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" address_ := ");
				address__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" param_ := ");
				param__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Port__Queue match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Port__Queue) {
				log_match((Port__Queue)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Queue.");
		}

		public void log_match(final Port__Queue match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetMsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetMsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !address__.match(match_value.constGetAddress__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".address_");
							address__.log_match(match_value.constGetAddress__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !param__.match(match_value.constGetParam__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".param_");
							param__.log_match(match_value.constGetParam__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetMsgid(), legacy);
				TTCN_Logger.log_event_str("{ address_ := ");
				address__.log_match(match_value.constGetAddress__(), legacy);
				TTCN_Logger.log_event_str("{ param_ := ");
				param__.log_match(match_value.constGetParam__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation.encode_text(text_buf);
				port__name.encode_text(text_buf);
				compref.encode_text(text_buf);
				msgid.encode_text(text_buf);
				address__.encode_text(text_buf);
				param__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Port_Queue.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				operation = new Port__Queue_operation_template();
				operation.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				address__ = new TitanCharString_template();
				address__.decode_text(text_buf);
				param__ = new TitanCharString_template();
				param__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Port__Queue_template>(size);
				for(int i = 0; i < size; i++) {
					final Port__Queue_template temp = new Port__Queue_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Port_Queue.");
			}
		}
}
public static void Port__Queue_encoder(final Port__Queue input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_decoder( final TitanOctetString input_stream, final Port__Queue output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ParallelEvent extends Base_Type {
		private final ParallelEvent_choice choice; //TTCN3_Choice_Type

		public ParallelEvent() {
			choice = new ParallelEvent_choice();
		}

		public ParallelEvent( final ParallelEvent_choice aChoice ) {
			choice = new ParallelEvent_choice( aChoice );
		}

		public ParallelEvent( final ParallelEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ParallelEvent.");
			}
			choice = new ParallelEvent_choice();
			assign( aOtherValue );
		}
		public ParallelEvent assign(final ParallelEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ParallelEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ParallelEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelEvent ) {
				return assign((ParallelEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ParallelEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ParallelEvent ) {
				return operatorEquals((ParallelEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ParallelEvent", otherValue));
		}

		public ParallelEvent_choice getChoice() {
			return choice;
		}

		public ParallelEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ParallelEvent_template extends Base_Template {

	private ParallelEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<ParallelEvent_template> list_value;

	public ParallelEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public ParallelEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.ParallelEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new ParallelEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ParallelEvent_template() {
	}

	public ParallelEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ParallelEvent_template( final ParallelEvent otherValue ) {
		copyValue(otherValue);
	}

	public ParallelEvent_template( final ParallelEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ParallelEvent_template( final Optional<ParallelEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ParallelEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public ParallelEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ParallelEvent_template assign( final ParallelEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ParallelEvent_template assign( final ParallelEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ParallelEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ParallelEvent) {
				return assign((ParallelEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public ParallelEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ParallelEvent_template) {
				return assign((ParallelEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelEvent' can not be cast to {1}_template", otherValue));
		}

	public ParallelEvent_template assign( final Optional<ParallelEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ParallelEvent.");
		}
		return this;
	}

	private void copyValue(final ParallelEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ParallelEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ParallelEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ParallelEvent_template temp = new ParallelEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ParallelEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ParallelEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ParallelEvent.");
			}
			final ParallelEvent ret_val = new ParallelEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public ParallelEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ParallelEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ParallelEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ParallelEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ParallelEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ParallelEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ParallelEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ParallelEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ParallelEvent) {
		return match((ParallelEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ParallelEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ParallelEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ParallelEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ParallelEvent) {
				log_match((ParallelEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelEvent.");
		}

		public void log_match(final ParallelEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ParallelEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new ParallelEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ParallelEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final ParallelEvent_template temp = new ParallelEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ParallelEvent.");
			}
		}
}
public static void ParallelEvent_encoder(final ParallelEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelEvent_decoder( final TitanOctetString input_stream, final ParallelEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class FinalVerdictType_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_Info,  ALT_Notification };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public FinalVerdictType_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public FinalVerdictType_choice(final FinalVerdictType_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final FinalVerdictType_choice otherValue) {
switch (otherValue.union_selection){
case ALT_Info:
field = new FinalVerdictInfo((FinalVerdictInfo)otherValue.field);
break;
case ALT_Notification:
field = new FinalVerdictType_choice_notification((FinalVerdictType_choice_notification)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.FinalVerdictType.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public FinalVerdictType_choice assign( final FinalVerdictType_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public FinalVerdictType_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof FinalVerdictType_choice) {
return assign((FinalVerdictType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_Info:
return field.isValue();
case ALT_Notification:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final FinalVerdictType_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.FinalVerdictType.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.FinalVerdictType.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_Info:
return ((FinalVerdictInfo)field).operatorEquals((FinalVerdictInfo)otherValue.field);
case ALT_Notification:
return ((FinalVerdictType_choice_notification)field).operatorEquals((FinalVerdictType_choice_notification)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof FinalVerdictType_choice) {
return operatorEquals((FinalVerdictType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final FinalVerdictType_choice otherValue ) {
return !operatorEquals(otherValue);
}

public FinalVerdictInfo getInfo() {
if (union_selection != union_selection_type.ALT_Info) {
cleanUp();
field = new FinalVerdictInfo();
union_selection = union_selection_type.ALT_Info;
}
return (FinalVerdictInfo)field;
}

public FinalVerdictInfo constGetInfo() {
if (union_selection != union_selection_type.ALT_Info) {
throw new TtcnError("Using non-selected field info in a value of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return (FinalVerdictInfo)field;
}

public FinalVerdictType_choice_notification getNotification() {
if (union_selection != union_selection_type.ALT_Notification) {
cleanUp();
field = new FinalVerdictType_choice_notification();
union_selection = union_selection_type.ALT_Notification;
}
return (FinalVerdictType_choice_notification)field;
}

public FinalVerdictType_choice_notification constGetNotification() {
if (union_selection != union_selection_type.ALT_Notification) {
throw new TtcnError("Using non-selected field notification in a value of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return (FinalVerdictType_choice_notification)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_Info:
TTCN_Logger.log_event_str("{ info := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_Notification:
TTCN_Logger.log_event_str("{ notification := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_Info:
case ALT_Notification:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_Info:
text_buf.push_int(0);
break;
case ALT_Notification:
text_buf.push_int(1);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getInfo().decode_text(text_buf);
break;
case 1:
getNotification().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.FinalVerdictType.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class FinalVerdictType_choice_template extends Base_Template {
//if single value which value?
private FinalVerdictType_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<FinalVerdictType_choice_template> value_list;

private void copy_value(final FinalVerdictType_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_Info:
single_value = new FinalVerdictInfo_template(other_value.constGetInfo());
break;
case ALT_Notification:
single_value = new FinalVerdictType_choice_notification_template(other_value.constGetNotification());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.FinalVerdictType.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final FinalVerdictType_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_Info:
single_value = new FinalVerdictInfo_template(other_value.constGetInfo());
break;
case ALT_Notification:
single_value = new FinalVerdictType_choice_notification_template(other_value.constGetNotification());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.FinalVerdictType.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<FinalVerdictType_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final FinalVerdictType_choice_template temp = new FinalVerdictType_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
set_selection(other_value);
}

public FinalVerdictType_choice_template() {
}
public FinalVerdictType_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public FinalVerdictType_choice_template(final FinalVerdictType_choice other_value) {
copy_value(other_value);
}
public FinalVerdictType_choice_template(final FinalVerdictType_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_Info:
((FinalVerdictInfo_template)single_value).cleanUp();
break;
case ALT_Notification:
((FinalVerdictType_choice_notification_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public FinalVerdictType_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public FinalVerdictType_choice_template assign( final FinalVerdictType_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public FinalVerdictType_choice_template assign( final FinalVerdictType_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public FinalVerdictType_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof FinalVerdictType_choice) {
return assign((FinalVerdictType_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to FinalVerdictType_choice.");
}

@Override
public FinalVerdictType_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof FinalVerdictType_choice_template) {
return assign((FinalVerdictType_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to FinalVerdictType_choice_template.");
}

// originally match
public boolean match(final FinalVerdictType_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final FinalVerdictType_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final FinalVerdictType_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == FinalVerdictType_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_Info:
return ((FinalVerdictInfo_template)single_value).match(other_value.getInfo(), legacy);
case ALT_Notification:
return ((FinalVerdictType_choice_notification_template)single_value).match(other_value.getNotification(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof FinalVerdictType_choice) {
		return match((FinalVerdictType_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type FinalVerdictType_choice.");
	}
public boolean isChosen(final FinalVerdictType_choice.union_selection_type checked_selection) {
if(checked_selection == FinalVerdictType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == FinalVerdictType_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_Info:
return ((FinalVerdictInfo_template)single_value).isValue();
case ALT_Notification:
return ((FinalVerdictType_choice_notification_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
}

public FinalVerdictType_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
final FinalVerdictType_choice ret_val = new FinalVerdictType_choice();
switch (single_value_union_selection) {
case ALT_Info:
ret_val.getInfo().assign(((FinalVerdictInfo_template)single_value).valueOf());
break;
case ALT_Notification:
ret_val.getNotification().assign(((FinalVerdictType_choice_notification_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<FinalVerdictType_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new FinalVerdictType_choice_template());
}
}

public FinalVerdictType_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public FinalVerdictInfo_template getInfo() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_Info) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new FinalVerdictInfo_template(template_sel.ANY_VALUE);
} else {
single_value = new FinalVerdictInfo_template();
}
single_value_union_selection = FinalVerdictType_choice.union_selection_type.ALT_Info;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (FinalVerdictInfo_template)single_value;
}

public FinalVerdictInfo_template constGetInfo() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field info in a non-specific template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
if (single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_Info) {
throw new TtcnError("Accessing non-selected field info in a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return (FinalVerdictInfo_template)single_value;
}

public FinalVerdictType_choice_notification_template getNotification() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_Notification) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new FinalVerdictType_choice_notification_template(template_sel.ANY_VALUE);
} else {
single_value = new FinalVerdictType_choice_notification_template();
}
single_value_union_selection = FinalVerdictType_choice.union_selection_type.ALT_Notification;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (FinalVerdictType_choice_notification_template)single_value;
}

public FinalVerdictType_choice_notification_template constGetNotification() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field notification in a non-specific template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
if (single_value_union_selection != FinalVerdictType_choice.union_selection_type.ALT_Notification) {
throw new TtcnError("Accessing non-selected field notification in a template of union type @TitanLoggerApi.FinalVerdictType.choice.");
}
return (FinalVerdictType_choice_notification_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof FinalVerdictType_choice) {
log_match((FinalVerdictType_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.");
}

public void log_match(final FinalVerdictType_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_Info:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".info");
single_value.log_match(match_value.getInfo(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ info := ");
single_value.log_match(match_value.getInfo(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_Notification:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".notification");
single_value.log_match(match_value.getNotification(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ notification := ");
single_value.log_match(match_value.getNotification(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.FinalVerdictType.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new FinalVerdictInfo_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new FinalVerdictType_choice_notification_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<FinalVerdictType_choice_template>(size);
for (int i = 0; i < size; i++) {
final FinalVerdictType_choice_template temp2 = new FinalVerdictType_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.FinalVerdictType.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void FinalVerdictType_choice_encoder(final FinalVerdictType_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictType_choice_decoder( final TitanOctetString input_stream, final FinalVerdictType_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictType_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_logOptions_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_logOptions_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_logOptions_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_logOptions_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class StartFunction_parameter__list extends Base_Type {

	private List<TitanCharString> valueElements;

	public StartFunction_parameter__list() {
	}

	public StartFunction_parameter__list( final StartFunction_parameter__list otherValue ) {
		otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		valueElements = copyList( otherValue.valueElements );
	}

	public StartFunction_parameter__list(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanCharString>();
	}

	private static final List<TitanCharString> copyList( final List<TitanCharString> srcList ) {
		if ( srcList == null ) {
			return null;
		}

		final List<TitanCharString> newList = new ArrayList<TitanCharString>( srcList.size() );
		for (final TitanCharString srcElem : srcList) {
			final TitanCharString newElem = getUnboundElem();
			if (srcElem.isBound()) {
				newElem.assign( srcElem );
			}
			newList.add( ( newElem ) );
		}
		return newList;
	}

	@Override
	public boolean isPresent() {
		return isBound();
	}

	@Override
	public boolean isBound() {
		return valueElements != null;
	}

	public void mustBound( final String aErrorMessage ) {
		if ( !isBound() ) {
			throw new TtcnError( aErrorMessage );
		}
	}

	@Override
	public boolean isValue() {
		if (valueElements == null) {
			return false;
		}
		for (int i=0; i < valueElements.size(); i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem == null || !elem.isValue()) {
				return false;
			}
		}
		return true;
	}


	@Override
	public boolean operatorEquals(final Base_Type otherValue) {
		if (otherValue instanceof StartFunction_parameter__list) {
			return operatorEquals((StartFunction_parameter__list)otherValue);
		}
		throw new TtcnError("Internal Error: The left operand of comparison is not of type StartFunction_parameter__list.");
	}

	//originally operator==
	public boolean operatorEquals( final StartFunction_parameter__list otherValue ) {
		mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");

		final int size = valueElements.size();
		if ( size != otherValue.valueElements.size() ) {
			return false;
		}

		for ( int i = 0; i < size; i++ ) {
			final TitanCharString leftElem = valueElements.get( i );
			final TitanCharString rightElem = otherValue.valueElements.get( i );
			if (leftElem.isBound()) {
				if (rightElem.isBound()) {
					if ( !leftElem.operatorEquals( rightElem ) ) {
						return false;
					}
				} else {
					return false;
				}
			} else if (rightElem.isBound()) {
				return false;
			}
		}

		return true;
	}

	@Override
	public StartFunction_parameter__list assign(final Base_Type otherValue) {
	if (otherValue instanceof StartFunction_parameter__list) {
		return assign((StartFunction_parameter__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list.");
	}

	//originally operator=
	public StartFunction_parameter__list assign( final StartFunction_parameter__list aOtherValue ) {
		aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.StartFunction.parameter_list." );

		valueElements = copyList( aOtherValue.valueElements );
		return this;
	}

	public StartFunction_parameter__list assign(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanCharString>();
		return this;
	}

	//originally operator+
	public StartFunction_parameter__list concatenate(final StartFunction_parameter__list other_value) {
		if (valueElements == null || other_value.valueElements == null) {
			throw new TtcnError("Unbound operand of @TitanLoggerApi.StartFunction.parameter_list concatenation.");
		}
		final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i < valueElements.size(); i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < other_value.valueElements.size(); i++) {
			final TitanCharString elem = other_value.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}

	public StartFunction_parameter__list concatenate(final TitanNull_Type nullValue) {
		return new StartFunction_parameter__list(this);
	}

	//originally operator<<=
	public StartFunction_parameter__list rotateLeft(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate left operator.");
		return rotateLeft(rotate_count.getInt());
	}

	//originally operator<<=
	public StartFunction_parameter__list rotateLeft(final int rotate_count) {
		return rotateRight(-rotate_count);
	}

	//originally operator>>=
	public StartFunction_parameter__list rotateRight(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate right operator.");
		return rotateRight(rotate_count.getInt());
	}

	//originally operator>>=
	public StartFunction_parameter__list rotateRight(final int rotate_count) {
		if (valueElements == null) {
			throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		final int size = valueElements.size();
		if (size == 0) {
			return new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
		}
		int rc;
		if (rotate_count >= 0) {
			rc = rotate_count % size;
		} else {
			rc = size - ((-rotate_count) % size);
		}
		if (rc == 0) {
			return new StartFunction_parameter__list(this);
		}
		final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
		for (int i = size - rc; i < size; i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < size - rc; i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}

	//originally clean_up
	public void cleanUp() {
		valueElements = null;
	}

	//originally get_at(int)
	public TitanCharString getAt( final int index_value ) {
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.StartFunction.parameter_list using a negative index: "+index_value+".");
		}

		if (valueElements == null || index_value >= valueElements.size() ) {
			//increase list size
			setSize(index_value + 1);
		}

		if ( valueElements.get( index_value ) == null ) {
			final TitanCharString newElem = getUnboundElem();
			valueElements.set( index_value, newElem );
		}
		return valueElements.get( index_value );
	}

	//originally get_at(const INTEGER&)
	public TitanCharString getAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.StartFunction.parameter_list." );
		return getAt( index_value.getInt() );
	}

	//originally get_at(int) const
	public TitanCharString constGetAt( final int index_value ) {
		if ( !isBound() ) {
			throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.StartFunction.parameter_list." );
		}
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.StartFunction.parameter_list using a negative index: "+index_value+".");
		}
		final int nofElements = n_elem().getInt();
		if ( index_value >= nofElements ) {
			throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.StartFunction.parameter_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
		}

		final TitanCharString elem = valueElements.get( index_value );
		return ( elem != null ) ? elem : getUnboundElem();
	}

	//originally get_at(const INTEGER&) const
	public TitanCharString constGetAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.StartFunction.parameter_list." );
		return constGetAt( index_value.getInt() );
	}

	public TitanInteger sizeOf() {
		mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		return new TitanInteger(valueElements.size());
	}

	public TitanInteger n_elem() {
		return sizeOf();
	}

	public TitanInteger lengthOf() {
		mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
			final TitanCharString elem = valueElements.get( i );
			if ( elem != null && elem.isBound() ) {
				return new TitanInteger(i + 1);
			}
		}
		return new TitanInteger(0);
	}

	public void setSize(final int newSize) {
		if (newSize < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		if ( valueElements == null ) {
			valueElements = new ArrayList<TitanCharString>();
		}
		if (newSize > valueElements.size()) {
			for ( int i = valueElements.size(); i < newSize; i++ ) {
				valueElements.add( new TitanCharString() );
			}
		} else if (newSize < valueElements.size()) {
			while(valueElements.size() > newSize) {
				valueElements.remove(valueElements.size()-1);
			}
		}
	}

	private static TitanCharString getUnboundElem() {
		return new TitanCharString();
	}
/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */

	@Override
	public String toString() {
		if (!isBound()) {
			return "<unbound>";
		}
		final StringBuilder sb = new StringBuilder();
		sb.append('{');
		final int size = ( valueElements == null ) ? 0 : valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				sb.append(',');
			}
			sb.append(valueElements.get(i).toString());
		}
		sb.append('}');
		return sb.toString();
	}

	public StartFunction_parameter__list substr(final int index, final int returncount) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.StartFunction.parameter_list","element");
		final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i<returncount; i++) {
			if (valueElements.get(i+index) != null) {
				ret_val.valueElements.add(new TitanCharString(valueElements.get(i+index)));
			}
		}
		return ret_val;
	}

	public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list repl) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		if (repl.valueElements == null) {
			throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.StartFunction.parameter_list","element");
		final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
		for (int i = 0; i < index; i++) {
			final TitanCharString elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < repl.valueElements.size(); i++) {
			final TitanCharString elem = repl.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		for (int i = 0; i < valueElements.size() - index - len; i++) {
			final TitanCharString elem = valueElements.get(index + i + len);
			if (elem != null) {
				ret_val.valueElements.add(new TitanCharString(elem));
			}
		}
		return ret_val;
	}

	public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len, repl.valueOf());
	}

	public StartFunction_parameter__list replace(final int index, final TitanInteger len, final StartFunction_parameter__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len.getInt(), repl.valueOf());
	}

	public StartFunction_parameter__list replace(final TitanInteger index, final int len, final StartFunction_parameter__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len, repl.valueOf());
	}

	public StartFunction_parameter__list replace(final TitanInteger index, final TitanInteger len, final StartFunction_parameter__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len.getInt(), repl.valueOf());
	}
	public void log() {
		if (valueElements == null) {
			TTCN_Logger.log_event_unbound();
			return;
		}
		TTCN_Logger.log_event_str("{ ");
		final int size = valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				TTCN_Logger.log_event_str(", ");
			}
		valueElements.get(i).log();
		}
		TTCN_Logger.log_event_str(" }");
	}
		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.StartFunction.parameter_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanCharString>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanCharString temp2 = new TitanCharString();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

}
public static class StartFunction_parameter__list_template extends Record_Of_Template {

	//originally single_value/value_elements
	List<TitanCharString_template> value_elements;

	//originally value_list/list_value
	List<StartFunction_parameter__list_template> list_value;

	private final match_function_t match_function_specific = new match_function_t() {
		@Override
		public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
			return match_index((StartFunction_parameter__list)value_ptr, value_index, (StartFunction_parameter__list_template)template_ptr, template_index, legacy);
		}
	};

	public StartFunction_parameter__list_template() {
	}

	public StartFunction_parameter__list_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public StartFunction_parameter__list_template( final StartFunction_parameter__list otherValue ) {
		copy_value( otherValue );
	}

	public StartFunction_parameter__list_template( final StartFunction_parameter__list_template otherValue ) {
		copyTemplate( otherValue );
	}

	public StartFunction_parameter__list_template( final Optional<StartFunction_parameter__list> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.StartFunction.parameter_list from an unbound optional field.");
		}
	}

	public StartFunction_parameter__list_template( final TitanNull_Type nullValue ) {
		super( template_sel.SPECIFIC_VALUE );
		value_elements = new ArrayList<TitanCharString_template>();
	}

	private void copy_value(final StartFunction_parameter__list other_value) {
		if (!other_value.isBound()) {
			throw new TtcnError("Initialization of a template of type @TitanLoggerApi.StartFunction.parameter_list with an unbound value.");
		}
		value_elements = new ArrayList<TitanCharString_template>();
		final int otherSize = other_value.valueElements.size();
		for (int elem_count = 0; elem_count < otherSize; elem_count++) {
			if (other_value.constGetAt(elem_count).isBound()) {
				value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
			} else {
				value_elements.add( new TitanCharString_template() );
			}
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final StartFunction_parameter__list_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			value_elements = new ArrayList<TitanCharString_template>();
			final int otherSize = other_value.value_elements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanCharString_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanCharString_template() );
				}
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<StartFunction_parameter__list_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final StartFunction_parameter__list_template temp = new StartFunction_parameter__list_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		set_selection(other_value);
	}

	public boolean isPresent() {
		return isPresent(false);
	}

	public boolean isPresent(final boolean legacy) {
		if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
			return false;
		}
		return !match_omit(legacy);
	}

	// originally match
	public boolean match(final StartFunction_parameter__list other_value) {
		return match(other_value, false);
	}

	// originally match
	public boolean match(final StartFunction_parameter__list other_value, final boolean legacy) {
		if(!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case OMIT_VALUE:
			return false;
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for(int i = 0 ; i < list_value.size(); i++) {
				if(list_value.get(i).match(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
				}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
	}

	private boolean match_index(final StartFunction_parameter__list value_ptr, final int value_index, final StartFunction_parameter__list_template template_ptr, final int template_index, final boolean legacy) {
		if (value_index >= 0) {
			return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
		} else {
			return template_ptr.value_elements.get(template_index).is_any_or_omit();
		}
	}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
		if (otherValue instanceof StartFunction_parameter__list) {
			return match((StartFunction_parameter__list)otherValue, legacy);
		}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list.");
	}

	public boolean match_omit(final boolean legacy) {
		if (is_ifPresent) {
			return true;
		}
		switch (templateSelection) {
		case OMIT_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			if (legacy) {
				for (int i = 0 ; i < list_value.size(); i++) {
					if (list_value.get(i).match_omit(legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			}
			return false;
		default:
			return false;
		}
	}

	//originally operator=
	public StartFunction_parameter__list_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public StartFunction_parameter__list_template assign( final StartFunction_parameter__list other_value ) {
		cleanUp();
		copy_value(other_value);
		return this;
	}

	//originally operator=
	public StartFunction_parameter__list_template assign( final StartFunction_parameter__list_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

	@Override
	public StartFunction_parameter__list_template assign(final Base_Type otherValue) {
	if (otherValue instanceof StartFunction_parameter__list) {
		return assign((StartFunction_parameter__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list.");
	}

	@Override
	public StartFunction_parameter__list_template assign(final Base_Template otherValue) {
	if (otherValue instanceof StartFunction_parameter__list_template) {
		return assign((StartFunction_parameter__list_template)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction_parameter__list_template.");
	}

	public StartFunction_parameter__list_template assign( final Optional<StartFunction_parameter__list> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		return this;
	}

	@Override
	public void cleanUp() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			value_elements.clear();
			value_elements = null;
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value.clear();
			list_value = null;
			break;
		default:
			break;
		}
		templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
	}

	public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl.valueOf());
	}

	public StartFunction_parameter__list replace(final TitanInteger index, final TitanInteger len, final StartFunction_parameter__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
	}

	public StartFunction_parameter__list replace(final int index, final int len, final StartFunction_parameter__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl);
	}

	public StartFunction_parameter__list replace(final TitanInteger index, final TitanInteger len, final StartFunction_parameter__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl);
	}

	public TitanCharString_template getAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.StartFunction.parameter_list using a negative index: {0}.", index_value ) );
		}

		switch (templateSelection) {
		case SPECIFIC_VALUE:
			if(index_value < value_elements.size()) {

				break;
			}
			// no break
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case UNINITIALIZED_TEMPLATE:
			setSize(index_value + 1);
			break;
		default:
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		return value_elements.get(index_value);
	}

	public TitanCharString_template getAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}

		return getAt(index_value.getInt());
	}

	public TitanCharString_template constGetAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.StartFunction.parameter_list using a negative index: {0}.", index_value ) );
		}

		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.StartFunction.parameter_list.");
		}

		if (index_value >= value_elements.size()) {
			throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.StartFunction.parameter_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
		}

		return value_elements.get(index_value);
	}

	public TitanCharString_template constGetAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}

		return constGetAt(index_value.getInt());
	}

	private int get_length_for_concat(final AtomicBoolean is_any_value) {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return value_elements.size();
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				if (templateSelection == template_sel.ANY_VALUE) {
					// ? => { * }
					is_any_value.set( true );
					return 1;
				}
				throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
			case RANGE_LENGTH_RESTRICTION:
				if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
					throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
				}
				// else fall through (range length restriction is allowed if the minimum
				// and maximum value are the same)
			case SINGLE_LENGTH_RESTRICTION:
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
			}
		default:
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}
	}

	private int get_length_for_concat(final StartFunction_parameter__list operand) {
		operand.mustBound("Operand of record of template concatenation is an unbound value.");
		return operand.valueElements.size();
	}


	private int get_length_for_concat(final template_sel operand) {
		if (operand == template_sel.ANY_VALUE) {
			// ? => { * }
			return 1;
		}
		throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
	}

			//TODO: simplify, just use value_elements.add()
	private void concat(final AtomicInteger pos, final StartFunction_parameter__list_template operand) {
		// all errors should have already been caught by the operand's
		// get_length_for_concat() call;
		// the result template (this) should already be set to SPECIFIC_VALUE and
		// single_value.value_elements should already be allocated
		switch (operand.templateSelection) {
		case SPECIFIC_VALUE:
			for (int i = 0; i < operand.value_elements.size(); ++i) {
				value_elements.set( pos.get() + i, new TitanCharString_template(operand.value_elements.get(i)) );
			}
			pos.addAndGet( operand.value_elements.size() );
			break;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (operand.length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				// ? => { * }
				value_elements.set( pos.get(), new TitanCharString_template( template_sel.ANY_OR_OMIT ) );
				pos.incrementAndGet();
				break;
			case RANGE_LENGTH_RESTRICTION:
			case SINGLE_LENGTH_RESTRICTION: {
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
				for (int i = 0; i < N; ++i) {
					value_elements.set( pos.get() + i, new TitanCharString_template( template_sel.ANY_VALUE ) );
				}
				pos.addAndGet( N );
				break; }
			}
		default:
			break;
		}
	}

	public void setSize(final int new_size) {
		if (new_size < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		final template_sel old_selection = templateSelection;
		if (old_selection != template_sel.SPECIFIC_VALUE) {
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = null;
		}
		if (value_elements == null) {
			value_elements = new ArrayList<TitanCharString_template>();
		}
		if (new_size > value_elements.size()) {
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanCharString_template(template_sel.ANY_VALUE) );
				}
			} else {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanCharString_template() );
				}
			}
		} else if (new_size < value_elements.size()) {
			final int oldSize = value_elements.size();
			for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
				value_elements.remove( new_size );
			}
		}
	}

	public TitanInteger sizeOf() {
		return sizeOf(true);
	}

	public TitanInteger lengthOf() {
		return sizeOf(false);
	}

	public TitanInteger sizeOf(final boolean is_size) {
		final String op_name = is_size ? "size" : "length";
		if (is_ifPresent) {
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list which has an ifpresent attribute.", op_name ) );
		}
		int min_size;
		boolean has_any_or_none;
		switch (templateSelection)
		{
		case SPECIFIC_VALUE: {
			min_size = 0;
			has_any_or_none = false;
			int elem_count = value_elements.size();
			if (!is_size) {
				while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
					elem_count--;
				}
			}
			for (int i=0; i<elem_count; i++)
			{
			switch (value_elements.get(i).get_selection())
				{
				case OMIT_VALUE:
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing omit element.", op_name ) );
				case ANY_OR_OMIT:
					has_any_or_none = true;
					break;
				default:
					min_size++;
					break;
				}
			}
		} break;
		case OMIT_VALUE:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing omit value.", op_name ) );
		case ANY_VALUE:
		case ANY_OR_OMIT:
			min_size = 0;
			has_any_or_none = true;
			break;
		case VALUE_LIST:
		{
			if (list_value.size()<1) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing an empty list.", op_name ) );
			}
			final int item_size = list_value.get(0).sizeOf(is_size).getInt();
			for (int i = 1; i < list_value.size(); i++) {
				if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing a value list with different sizes.", op_name ) );
				}
			}
			min_size = item_size;
			has_any_or_none = false;
			break;
		}
		case COMPLEMENTED_LIST:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.StartFunction.parameter_list containing complemented list.", op_name ) );
		default:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type StartFunction_parameter__list.", op_name ) );
		}
		return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanCharString_template"));
	}

	public TitanInteger n_elem() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return new TitanInteger(value_elements.size());
		case COMPLEMENTED_LIST:
			throw new TtcnError("Performing n_elem() operation on a template of type StartFunction_parameter__list containing complemented list.");
		case UNINITIALIZED_TEMPLATE:
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case VALUE_LIST:
		case VALUE_RANGE:
		case STRING_PATTERN:
		case SUPERSET_MATCH:
		case SUBSET_MATCH:
		case DECODE_MATCH:
			break;
		}
		throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type StartFunction_parameter__list.");
	}

	private boolean matchv(final StartFunction_parameter__list other_value, final boolean legacy) {
		if (!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case OMIT_VALUE:
			return false;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for (int list_count = 0; list_count < list_value.size(); list_count++) {
				if (list_value.get(list_count).matchv(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
		}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type StartFunction_parameter__list.");
		}
	}

	@Override
	public boolean isValue() {
		if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
			return false;
		}
		for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
			if (!value_elements.get(elem_count).isValue()) {
				return false;
			}
		}
		return true;
	}

	public void setType(final template_sel template_type, final int list_length) {
		cleanUp();
		switch (template_type) {
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<StartFunction_parameter__list_template>( list_length );
			for (int list_count = 0; list_count < list_length; list_count++) {
				list_value.add( new StartFunction_parameter__list_template() );
			}
			break;
		default:
			throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		set_selection(template_type);
	}

		public StartFunction_parameter__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			return list_value.get(list_index);
		}

	public StartFunction_parameter__list_template get_list_item(final int list_index) {
		if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
			throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		if (list_index < 0) {
			throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.StartFunction.parameter_list using a negative index ({0}).", list_index ) );
		}
		if (list_index >= list_value.size()) {
			throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.StartFunction.parameter_list.");
		}
		return list_value.get( list_index );
	}

		public StartFunction_parameter__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
			final StartFunction_parameter__list ret_val = new StartFunction_parameter__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public StartFunction_parameter__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

	public void log_match(final StartFunction_parameter__list match_value) {
		log_match(match_value, false);
	}

	@Override
	public void log_match(final Base_Type match_value, final boolean legacy) {
		if (match_value instanceof StartFunction_parameter__list) {
			log_match((StartFunction_parameter__list)match_value, legacy);
			return;
		}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StartFunction.parameter_list.");
	}

	public void log_match(final StartFunction_parameter__list match_value, final boolean legacy) {
		if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
			if(match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
			} else {
				if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
						TTCN_Logger.log_logmatch_info("[%d]", elem_count);
							value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					}
					log_match_length(value_elements.size());
				} else {
					TTCN_Logger.print_logmatch_buffer();
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
			return;
		}
		if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
			TTCN_Logger.log_event_str("{ ");
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (elem_count > 0) {
					TTCN_Logger.log_event_str(", ");
				}
				value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
			}
			TTCN_Logger.log_event_str(" }");
			log_match_length(value_elements.size());
		} else {
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if ( match(match_value, legacy) ) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}
	}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
				}
				value_elements = new ArrayList<TitanCharString_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanCharString_template temp2 = new TitanCharString_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StartFunction_parameter__list_template>(size);
				for (int i = 0; i < size; i++) {
					final StartFunction_parameter__list_template temp2 = new StartFunction_parameter__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.StartFunction.parameter_list.");
			}
		}

	@Override
	public boolean get_istemplate_kind(final String type) {
		if ("AnyElement".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
			return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
					return true;
				}
			}
			return false;
		} else if ("AnyElementsOrNone".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
					return true;
				}
			}
			return false;
		} else if ("permutation".equals(type)) {
			return get_number_of_permutations() != 0;
		} else if ("length".equals(type)) {
			return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
		} else {
			return super.get_istemplate_kind(type);
		}
	}
}
public static void StartFunction_parameter__list_encoder(final StartFunction_parameter__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction.parameter_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StartFunction_parameter__list_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StartFunction_parameter__list_decoder( final TitanOctetString input_stream, final StartFunction_parameter__list output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction.parameter_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StartFunction_parameter__list_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Msg__port__recv extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final Msg__port__recv_operation operation; //TTCN3_Enumerated_Type
		private final TitanInteger compref; //Integer_Type
		private final TitanCharString sys__name; //CharString_Type
		private final TitanCharString parameter; //CharString_Type
		private final TitanInteger msgid; //Integer_Type

		public Msg__port__recv() {
			port__name = new TitanCharString();
			operation = new Msg__port__recv_operation();
			compref = new TitanInteger();
			sys__name = new TitanCharString();
			parameter = new TitanCharString();
			msgid = new TitanInteger();
		}

		public Msg__port__recv( final TitanCharString aPort__name, final Msg__port__recv_operation aOperation, final TitanInteger aCompref, final TitanCharString aSys__name, final TitanCharString aParameter, final TitanInteger aMsgid ) {
			port__name = new TitanCharString( aPort__name );
			operation = new Msg__port__recv_operation( aOperation );
			compref = new TitanInteger( aCompref );
			sys__name = new TitanCharString( aSys__name );
			parameter = new TitanCharString( aParameter );
			msgid = new TitanInteger( aMsgid );
		}

		public Msg__port__recv( final Msg__port__recv aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Msg_port_recv.");
			}
			port__name = new TitanCharString();
			operation = new Msg__port__recv_operation();
			compref = new TitanInteger();
			sys__name = new TitanCharString();
			parameter = new TitanCharString();
			msgid = new TitanInteger();
			assign( aOtherValue );
		}
		public Msg__port__recv assign(final Msg__port__recv aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Msg_port_recv");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getSys__name().isBound() ) {
					this.sys__name.assign( aOtherValue.getSys__name() );
				} else {
					this.sys__name.cleanUp();
				}
				if ( aOtherValue.getParameter().isBound() ) {
					this.parameter.assign( aOtherValue.getParameter() );
				} else {
					this.parameter.cleanUp();
				}
				if ( aOtherValue.getMsgid().isBound() ) {
					this.msgid.assign( aOtherValue.getMsgid() );
				} else {
					this.msgid.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Msg__port__recv assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__recv ) {
				return assign((Msg__port__recv) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_recv", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			operation.cleanUp();
			compref.cleanUp();
			sys__name.cleanUp();
			parameter.cleanUp();
			msgid.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( sys__name.isBound() ) { return true; }
			if ( parameter.isBound() ) { return true; }
			if ( msgid.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !sys__name.isValue() ) { return false; }
			if ( !parameter.isValue() ) { return false; }
			if ( !msgid.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Msg__port__recv aOtherValue ) {
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.sys__name.operatorEquals( aOtherValue.sys__name ) ) { return false; }
			if ( !this.parameter.operatorEquals( aOtherValue.parameter ) ) { return false; }
			if ( !this.msgid.operatorEquals( aOtherValue.msgid ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__recv ) {
				return operatorEquals((Msg__port__recv) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Msg_port_recv", otherValue));
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public Msg__port__recv_operation getOperation() {
			return operation;
		}

		public Msg__port__recv_operation constGetOperation() {
			return operation;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanCharString getSys__name() {
			return sys__name;
		}

		public TitanCharString constGetSys__name() {
			return sys__name;
		}

		public TitanCharString getParameter() {
			return parameter;
		}

		public TitanCharString constGetParameter() {
			return parameter;
		}

		public TitanInteger getMsgid() {
			return msgid;
		}

		public TitanInteger constGetMsgid() {
			return msgid;
		}

		public TitanInteger sizeOf() {
			int sizeof = 6;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" sys_name := ");
			sys__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter := ");
			parameter.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" msgid := ");
			msgid.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (sys__name.isBound()) {
				sys__name.set_implicit_omit();
			}
			if (parameter.isBound()) {
				parameter.set_implicit_omit();
			}
			if (msgid.isBound()) {
				msgid.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			operation.encode_text(text_buf);
			compref.encode_text(text_buf);
			sys__name.encode_text(text_buf);
			parameter.encode_text(text_buf);
			msgid.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			operation.decode_text(text_buf);
			compref.decode_text(text_buf);
			sys__name.decode_text(text_buf);
			parameter.decode_text(text_buf);
			msgid.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Msg__port__recv_template extends Base_Template {

	private TitanCharString_template port__name; //CharString_Type
	private Msg__port__recv_operation_template operation; //TTCN3_Enumerated_Type
	private TitanInteger_template compref; //Integer_Type
	private TitanCharString_template sys__name; //CharString_Type
	private TitanCharString_template parameter; //CharString_Type
	private TitanInteger_template msgid; //Integer_Type
	//originally value_list/list_value
	List<Msg__port__recv_template> list_value;

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return port__name;
	}

	public Msg__port__recv_operation_template getOperation() {
		setSpecific();
		return operation;
	}

	public Msg__port__recv_operation_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return operation;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return compref;
	}

	public TitanCharString_template getSys__name() {
		setSpecific();
		return sys__name;
	}

	public TitanCharString_template constGetSys__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field sys_name of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return sys__name;
	}

	public TitanCharString_template getParameter() {
		setSpecific();
		return parameter;
	}

	public TitanCharString_template constGetParameter() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field parameter of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return parameter;
	}

	public TitanInteger_template getMsgid() {
		setSpecific();
		return msgid;
	}

	public TitanInteger_template constGetMsgid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field msgid of a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return msgid;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__name = new TitanCharString_template();
			operation = new Msg__port__recv_operation_template();
			compref = new TitanInteger_template();
			sys__name = new TitanCharString_template();
			parameter = new TitanCharString_template();
			msgid = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__name.assign(template_sel.ANY_VALUE);
				operation.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				sys__name.assign(template_sel.ANY_VALUE);
				parameter.assign(template_sel.ANY_VALUE);
				msgid.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Msg__port__recv_template() {
	}

	public Msg__port__recv_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Msg__port__recv_template( final Msg__port__recv otherValue ) {
		copyValue(otherValue);
	}

	public Msg__port__recv_template( final Msg__port__recv_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Msg__port__recv_template( final Optional<Msg__port__recv> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Msg_port_recv from an unbound optional field.");
		}
	}

	//originally operator=
	public Msg__port__recv_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Msg__port__recv_template assign( final Msg__port__recv other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Msg__port__recv_template assign( final Msg__port__recv_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Msg__port__recv_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Msg__port__recv) {
				return assign((Msg__port__recv) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv' can not be cast to {1}", otherValue));
		}

		@Override
		public Msg__port__recv_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Msg__port__recv_template) {
				return assign((Msg__port__recv_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv' can not be cast to {1}_template", otherValue));
		}

	public Msg__port__recv_template assign( final Optional<Msg__port__recv> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Msg_port_recv.");
		}
		return this;
	}

	private void copyValue(final Msg__port__recv other_value) {
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getSys__name().isBound()) {
			getSys__name().assign(other_value.getSys__name());
		} else {
			getSys__name().cleanUp();
		}
		if (other_value.getParameter().isBound()) {
			getParameter().assign(other_value.getParameter());
		} else {
			getParameter().cleanUp();
		}
		if (other_value.getMsgid().isBound()) {
			getMsgid().assign(other_value.getMsgid());
		} else {
			getMsgid().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Msg__port__recv_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSys__name().get_selection()) {
				getSys__name().cleanUp();
			} else {
				getSys__name().assign(other_value.getSys__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParameter().get_selection()) {
				getParameter().cleanUp();
			} else {
				getParameter().assign(other_value.getParameter());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getMsgid().get_selection()) {
				getMsgid().cleanUp();
			} else {
				getMsgid().assign(other_value.getMsgid());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Msg__port__recv_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Msg__port__recv_template temp = new Msg__port__recv_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Msg_port_recv.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Msg__port__recv valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Msg_port_recv.");
			}
			final Msg__port__recv ret_val = new Msg__port__recv();
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (sys__name.isBound()) {
				ret_val.sys__name.assign(sys__name.valueOf());
			}
			 if (parameter.isBound()) {
				ret_val.parameter.assign(parameter.valueOf());
			}
			 if (msgid.isBound()) {
				ret_val.msgid.assign(msgid.valueOf());
			}
			return ret_val;
		}

		public Msg__port__recv_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Msg_port_recv.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Msg_port_recv.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Msg_port_recv.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Msg__port__recv_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Msg__port__recv_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (sys__name.isBound()) {
				return true;
			}
			if (parameter.isBound()) {
				return true;
			}
			if (msgid.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!sys__name.isValue()) {
				return false;
			}
			if (!parameter.isValue()) {
				return false;
			}
			if (!msgid.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Msg__port__recv other_value) {
			return match(other_value, false);
		}

		public boolean match(final Msg__port__recv other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getSys__name().isBound()) {
					return false;
				}
				if(!sys__name.match(other_value.getSys__name(), legacy)) {
					return false;
				}
				if(!other_value.getParameter().isBound()) {
					return false;
				}
				if(!parameter.match(other_value.getParameter(), legacy)) {
					return false;
				}
				if(!other_value.getMsgid().isBound()) {
					return false;
				}
				if(!msgid.match(other_value.getMsgid(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Msg__port__recv) {
		return match((Msg__port__recv)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Msg__port__recv.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 6;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Msg_port_recv containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" sys_name := ");
				sys__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter := ");
				parameter.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" msgid := ");
				msgid.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Msg__port__recv match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Msg__port__recv) {
				log_match((Msg__port__recv)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_recv.");
		}

		public void log_match(final Msg__port__recv match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !sys__name.match(match_value.constGetSys__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sys_name");
							sys__name.log_match(match_value.constGetSys__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter.match(match_value.constGetParameter(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter");
							parameter.log_match(match_value.constGetParameter(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !msgid.match(match_value.constGetMsgid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".msgid");
							msgid.log_match(match_value.constGetMsgid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ sys_name := ");
				sys__name.log_match(match_value.constGetSys__name(), legacy);
				TTCN_Logger.log_event_str("{ parameter := ");
				parameter.log_match(match_value.constGetParameter(), legacy);
				TTCN_Logger.log_event_str("{ msgid := ");
				msgid.log_match(match_value.constGetMsgid(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				operation.encode_text(text_buf);
				compref.encode_text(text_buf);
				sys__name.encode_text(text_buf);
				parameter.encode_text(text_buf);
				msgid.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				operation = new Msg__port__recv_operation_template();
				operation.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				sys__name = new TitanCharString_template();
				sys__name.decode_text(text_buf);
				parameter = new TitanCharString_template();
				parameter.decode_text(text_buf);
				msgid = new TitanInteger_template();
				msgid.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Msg__port__recv_template>(size);
				for(int i = 0; i < size; i++) {
					final Msg__port__recv_template temp = new Msg__port__recv_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Msg_port_recv.");
			}
		}
}
public static void Msg__port__recv_encoder(final Msg__port__recv input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_decoder( final TitanOctetString input_stream, final Msg__port__recv output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanLogEvent_logEvent_encoder(final LogEventType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLogEvent_logEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLogEvent_logEvent_decoder( final TitanOctetString input_stream, final LogEventType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LogEventType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLogEvent_logEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TimerType extends Base_Type {
		private final TitanCharString name; //CharString_Type
		private final TitanFloat value__; //Float_Type

		public TimerType() {
			name = new TitanCharString();
			value__ = new TitanFloat();
		}

		public TimerType( final TitanCharString aName, final TitanFloat aValue__ ) {
			name = new TitanCharString( aName );
			value__ = new TitanFloat( aValue__ );
		}

		public TimerType( final TimerType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerType.");
			}
			name = new TitanCharString();
			value__ = new TitanFloat();
			assign( aOtherValue );
		}
		public TimerType assign(final TimerType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimerType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getName().isBound() ) {
					this.name.assign( aOtherValue.getName() );
				} else {
					this.name.cleanUp();
				}
				if ( aOtherValue.getValue__().isBound() ) {
					this.value__.assign( aOtherValue.getValue__() );
				} else {
					this.value__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimerType assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerType ) {
				return assign((TimerType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerType", otherValue));
		}

		public void cleanUp() {
			name.cleanUp();
			value__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( name.isBound() ) { return true; }
			if ( value__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !name.isValue() ) { return false; }
			if ( !value__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimerType aOtherValue ) {
			if ( !this.name.operatorEquals( aOtherValue.name ) ) { return false; }
			if ( !this.value__.operatorEquals( aOtherValue.value__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimerType ) {
				return operatorEquals((TimerType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerType", otherValue));
		}

		public TitanCharString getName() {
			return name;
		}

		public TitanCharString constGetName() {
			return name;
		}

		public TitanFloat getValue__() {
			return value__;
		}

		public TitanFloat constGetValue__() {
			return value__;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" value_ := ");
			value__.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (value__.isBound()) {
				value__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			name.encode_text(text_buf);
			value__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			name.decode_text(text_buf);
			value__.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TimerType_template extends Base_Template {

	private TitanCharString_template name; //CharString_Type
	private TitanFloat_template value__; //Float_Type
	//originally value_list/list_value
	List<TimerType_template> list_value;

	public TitanCharString_template getName() {
		setSpecific();
		return name;
	}

	public TitanCharString_template constGetName() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.TimerType.");
		}
		return name;
	}

	public TitanFloat_template getValue__() {
		setSpecific();
		return value__;
	}

	public TitanFloat_template constGetValue__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field value_ of a non-specific template of type @TitanLoggerApi.TimerType.");
		}
		return value__;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			name = new TitanCharString_template();
			value__ = new TitanFloat_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				name.assign(template_sel.ANY_VALUE);
				value__.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TimerType_template() {
	}

	public TimerType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TimerType_template( final TimerType otherValue ) {
		copyValue(otherValue);
	}

	public TimerType_template( final TimerType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TimerType_template( final Optional<TimerType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerType from an unbound optional field.");
		}
	}

	//originally operator=
	public TimerType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TimerType_template assign( final TimerType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TimerType_template assign( final TimerType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TimerType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerType) {
				return assign((TimerType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerType' can not be cast to {1}", otherValue));
		}

		@Override
		public TimerType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimerType_template) {
				return assign((TimerType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerType' can not be cast to {1}_template", otherValue));
		}

	public TimerType_template assign( final Optional<TimerType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerType.");
		}
		return this;
	}

	private void copyValue(final TimerType other_value) {
		if (other_value.getName().isBound()) {
			getName().assign(other_value.getName());
		} else {
			getName().cleanUp();
		}
		if (other_value.getValue__().isBound()) {
			getValue__().assign(other_value.getValue__());
		} else {
			getValue__().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TimerType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getName().get_selection()) {
				getName().cleanUp();
			} else {
				getName().assign(other_value.getName());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getValue__().get_selection()) {
				getValue__().cleanUp();
			} else {
				getValue__().assign(other_value.getValue__());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TimerType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TimerType_template temp = new TimerType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerType.");
			}
			final TimerType ret_val = new TimerType();
			 if (name.isBound()) {
				ret_val.name.assign(name.valueOf());
			}
			 if (value__.isBound()) {
				ret_val.value__.assign(value__.valueOf());
			}
			return ret_val;
		}

		public TimerType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (value__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!value__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimerType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getName().isBound()) {
					return false;
				}
				if(!name.match(other_value.getName(), legacy)) {
					return false;
				}
				if(!other_value.getValue__().isBound()) {
					return false;
				}
				if(!value__.match(other_value.getValue__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TimerType) {
		return match((TimerType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimerType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" value_ := ");
				value__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerType) {
				log_match((TimerType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerType.");
		}

		public void log_match(final TimerType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !name.match(match_value.constGetName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !value__.match(match_value.constGetValue__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".value_");
							value__.log_match(match_value.constGetValue__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetName(), legacy);
				TTCN_Logger.log_event_str("{ value_ := ");
				value__.log_match(match_value.constGetValue__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name.encode_text(text_buf);
				value__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				value__ = new TitanFloat_template();
				value__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerType_template>(size);
				for(int i = 0; i < size; i++) {
					final TimerType_template temp = new TimerType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerType.");
			}
		}
}
public static void TimerType_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerType_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class DefaultEvent extends Base_Type {
		private final DefaultEvent_choice choice; //TTCN3_Choice_Type

		public DefaultEvent() {
			choice = new DefaultEvent_choice();
		}

		public DefaultEvent( final DefaultEvent_choice aChoice ) {
			choice = new DefaultEvent_choice( aChoice );
		}

		public DefaultEvent( final DefaultEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.DefaultEvent.");
			}
			choice = new DefaultEvent_choice();
			assign( aOtherValue );
		}
		public DefaultEvent assign(final DefaultEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.DefaultEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public DefaultEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultEvent ) {
				return assign((DefaultEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final DefaultEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof DefaultEvent ) {
				return operatorEquals((DefaultEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.DefaultEvent", otherValue));
		}

		public DefaultEvent_choice getChoice() {
			return choice;
		}

		public DefaultEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class DefaultEvent_template extends Base_Template {

	private DefaultEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<DefaultEvent_template> list_value;

	public DefaultEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public DefaultEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.DefaultEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new DefaultEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public DefaultEvent_template() {
	}

	public DefaultEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public DefaultEvent_template( final DefaultEvent otherValue ) {
		copyValue(otherValue);
	}

	public DefaultEvent_template( final DefaultEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public DefaultEvent_template( final Optional<DefaultEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.DefaultEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public DefaultEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public DefaultEvent_template assign( final DefaultEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public DefaultEvent_template assign( final DefaultEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public DefaultEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof DefaultEvent) {
				return assign((DefaultEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public DefaultEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof DefaultEvent_template) {
				return assign((DefaultEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEvent' can not be cast to {1}_template", otherValue));
		}

	public DefaultEvent_template assign( final Optional<DefaultEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.DefaultEvent.");
		}
		return this;
	}

	private void copyValue(final DefaultEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final DefaultEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<DefaultEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final DefaultEvent_template temp = new DefaultEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.DefaultEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public DefaultEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.DefaultEvent.");
			}
			final DefaultEvent ret_val = new DefaultEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public DefaultEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.DefaultEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.DefaultEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.DefaultEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<DefaultEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new DefaultEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final DefaultEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final DefaultEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof DefaultEvent) {
		return match((DefaultEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type DefaultEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.DefaultEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final DefaultEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof DefaultEvent) {
				log_match((DefaultEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEvent.");
		}

		public void log_match(final DefaultEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.DefaultEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new DefaultEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<DefaultEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final DefaultEvent_template temp = new DefaultEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.DefaultEvent.");
			}
		}
}
public static void DefaultEvent_encoder(final DefaultEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultEvent_decoder( final TitanOctetString input_stream, final DefaultEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TestcaseType_verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TestcaseType_verdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TestcaseType_verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TestcaseType_verdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Parallel_src__port_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_src__port_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_src__port_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_src__port_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__discard_unhandled_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__discard_unhandled_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__discard_unhandled_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__discard_unhandled_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Port__Queue_operation extends Base_Type {
public enum enum_type {
enqueue__msg (0),
enqueue__call (1),
enqueue__reply (2),
enqueue__exception (3),
extract__msg (4),
extract__op (5),
UNKNOWN_VALUE(6),
UNBOUND_VALUE(7);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return enqueue__msg;
case 1:  return enqueue__call;
case 2:  return enqueue__reply;
case 3:  return enqueue__exception;
case 4:  return extract__msg;
case 5:  return extract__op;
case 6:  return UNKNOWN_VALUE;
case 7:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Port__Queue_operation() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Port__Queue_operation(final Port__Queue_operation otherValue) {
enum_value = otherValue.enum_value;
}

public Port__Queue_operation(final Port__Queue_operation.enum_type otherValue ) {
enum_value = otherValue;
}

public Port__Queue_operation(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__Queue_operation' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Port__Queue_operation assign(final Port__Queue_operation otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Port__Queue_operation assign(final Base_Type otherValue){
if( otherValue instanceof Port__Queue_operation ) {
return assign((Port__Queue_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation' can not be cast to {1}", otherValue));
}

//originally operator=
public Port__Queue_operation assign(final Port__Queue_operation.enum_type otherValue){
return assign( new Port__Queue_operation(otherValue) );
}

//originally operator=
public Port__Queue_operation assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__Queue_operation'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Port__Queue_operation otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Port__Queue_operation) {
return operatorEquals( (Port__Queue_operation) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Queue.operation.");
}
}

//originally operator==
public boolean operatorEquals(final Port__Queue_operation.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Port__Queue_operation otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Port__Queue_operation.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Port__Queue_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Port__Queue_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__Queue_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__Queue_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Port__Queue_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Port__Queue_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__Queue_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__Queue_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Queue_operation. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Port__Queue_operation.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Port__Queue_operation enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("enqueue__msg".equals(strPar) || "enqueue_msg".equals(strPar)) {
return enum_type.enqueue__msg;
}
if ("enqueue__call".equals(strPar) || "enqueue_call".equals(strPar)) {
return enum_type.enqueue__call;
}
if ("enqueue__reply".equals(strPar) || "enqueue_reply".equals(strPar)) {
return enum_type.enqueue__reply;
}
if ("enqueue__exception".equals(strPar) || "enqueue_exception".equals(strPar)) {
return enum_type.enqueue__exception;
}
if ("extract__msg".equals(strPar) || "extract_msg".equals(strPar)) {
return enum_type.extract__msg;
}
if ("extract__op".equals(strPar) || "extract_op".equals(strPar)) {
return enum_type.extract__op;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_Queue.operation.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Queue.operation.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Port__Queue_operation_template extends Base_Template {
// single_value
private Port__Queue_operation.enum_type single_value;
// value_list part
private ArrayList<Port__Queue_operation_template> value_list;

private void copy_template(final Port__Queue_operation_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Port__Queue_operation_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Port__Queue_operation_template temp = new Port__Queue_operation_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__Queue_operation.");
}
}

public Port__Queue_operation_template() {
}

public Port__Queue_operation_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Port__Queue_operation_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Port__Queue_operation.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Port__Queue_operation with unknown numeric value "+ otherValue +".");
}
single_value = Port__Queue_operation.enum_type.getValue(otherValue);
}

public Port__Queue_operation_template(final Port__Queue_operation otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Port__Queue_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Port__Queue_operation. ");
}
single_value = otherValue.enum_value;
}

public Port__Queue_operation_template(final Port__Queue_operation_template otherValue) {
copy_template(otherValue);
}

public Port__Queue_operation_template(final Port__Queue_operation.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Port__Queue_operation.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Port__Queue_operation_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Port__Queue_operation_template assign(final int otherValue) {
if (!Port__Queue_operation.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__Queue_operation.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Port__Queue_operation_template assign(final Port__Queue_operation.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Port__Queue_operation_template assign(final Port__Queue_operation_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Port__Queue_operation_template assign(final Port__Queue_operation otherValue){
if (otherValue.enum_value == Port__Queue_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Port__Queue_operation to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Port__Queue_operation_template assign(final Base_Type otherValue){
if( otherValue instanceof Port__Queue_operation ) {
return assign((Port__Queue_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation' can not be cast to {1}", otherValue));
}

@Override
public Port__Queue_operation_template assign(final Base_Template otherValue){
if( otherValue instanceof Port__Queue_operation_template ) {
return assign((Port__Queue_operation_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Port__Queue_operation.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Port__Queue_operation.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__Queue_operation.");
}
}

// originally match
public boolean match(final Port__Queue_operation otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Port__Queue_operation otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Port__Queue_operation ) {
return match((Port__Queue_operation) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Queue_operation' can not be cast to {1}", otherValue));
}

public Port__Queue_operation valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__Queue_operation.");
}
return new Port__Queue_operation(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__Queue_operation.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Port__Queue_operation_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Port__Queue_operation_template());
}
}

public Port__Queue_operation_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__Queue_operation.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Port__Queue_operation.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Port__Queue_operation.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Port__Queue_operation.enum2str(single_value), Port__Queue_operation.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Port__Queue_operation) {
log_match((Port__Queue_operation)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Queue.operation.");
}
public void log_match(final Port__Queue_operation match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_Queue.operation.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Port__Queue_operation.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Queue.operation.", temp));
}
single_value = Port__Queue_operation.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Port__Queue_operation_template>(size);
for(int i = 0; i < size; i++) {
final Port__Queue_operation_template temp = new Port__Queue_operation_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_Queue.operation.");
}
}
}
public static void Port__Queue_operation_encoder(final Port__Queue_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_operation_decoder( final TitanOctetString input_stream, final Port__Queue_operation output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Queue.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanLogEvent_sourceInfo__list_0_encoder(final LocationInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLogEvent_sourceInfo__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLogEvent_sourceInfo__list_0_decoder( final TitanOctetString input_stream, final LocationInfo output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.LocationInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLogEvent_sourceInfo__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerType_value___encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerType_value___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerType_value___decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerType_value___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class MatchingProblemType extends Base_Type {
		private final TitanCharString port__name; //CharString_Type
		private final MatchingProblemType_reason reason; //TTCN3_Enumerated_Type
		private final MatchingProblemType_operation operation; //TTCN3_Enumerated_Type
		private final TitanBoolean check__; //Boolean_Type
		private final TitanBoolean any__port; //Boolean_Type

		public MatchingProblemType() {
			port__name = new TitanCharString();
			reason = new MatchingProblemType_reason();
			operation = new MatchingProblemType_operation();
			check__ = new TitanBoolean();
			any__port = new TitanBoolean();
		}

		public MatchingProblemType( final TitanCharString aPort__name, final MatchingProblemType_reason aReason, final MatchingProblemType_operation aOperation, final TitanBoolean aCheck__, final TitanBoolean aAny__port ) {
			port__name = new TitanCharString( aPort__name );
			reason = new MatchingProblemType_reason( aReason );
			operation = new MatchingProblemType_operation( aOperation );
			check__ = new TitanBoolean( aCheck__ );
			any__port = new TitanBoolean( aAny__port );
		}

		public MatchingProblemType( final MatchingProblemType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingProblemType.");
			}
			port__name = new TitanCharString();
			reason = new MatchingProblemType_reason();
			operation = new MatchingProblemType_operation();
			check__ = new TitanBoolean();
			any__port = new TitanBoolean();
			assign( aOtherValue );
		}
		public MatchingProblemType assign(final MatchingProblemType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingProblemType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getOperation().isBound() ) {
					this.operation.assign( aOtherValue.getOperation() );
				} else {
					this.operation.cleanUp();
				}
				if ( aOtherValue.getCheck__().isBound() ) {
					this.check__.assign( aOtherValue.getCheck__() );
				} else {
					this.check__.cleanUp();
				}
				if ( aOtherValue.getAny__port().isBound() ) {
					this.any__port.assign( aOtherValue.getAny__port() );
				} else {
					this.any__port.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingProblemType assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingProblemType ) {
				return assign((MatchingProblemType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingProblemType", otherValue));
		}

		public void cleanUp() {
			port__name.cleanUp();
			reason.cleanUp();
			operation.cleanUp();
			check__.cleanUp();
			any__port.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( port__name.isBound() ) { return true; }
			if ( reason.isBound() ) { return true; }
			if ( operation.isBound() ) { return true; }
			if ( check__.isBound() ) { return true; }
			if ( any__port.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !port__name.isValue() ) { return false; }
			if ( !reason.isValue() ) { return false; }
			if ( !operation.isValue() ) { return false; }
			if ( !check__.isValue() ) { return false; }
			if ( !any__port.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingProblemType aOtherValue ) {
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.operation.operatorEquals( aOtherValue.operation ) ) { return false; }
			if ( !this.check__.operatorEquals( aOtherValue.check__ ) ) { return false; }
			if ( !this.any__port.operatorEquals( aOtherValue.any__port ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingProblemType ) {
				return operatorEquals((MatchingProblemType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingProblemType", otherValue));
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public MatchingProblemType_reason getReason() {
			return reason;
		}

		public MatchingProblemType_reason constGetReason() {
			return reason;
		}

		public MatchingProblemType_operation getOperation() {
			return operation;
		}

		public MatchingProblemType_operation constGetOperation() {
			return operation;
		}

		public TitanBoolean getCheck__() {
			return check__;
		}

		public TitanBoolean constGetCheck__() {
			return check__;
		}

		public TitanBoolean getAny__port() {
			return any__port;
		}

		public TitanBoolean constGetAny__port() {
			return any__port;
		}

		public TitanInteger sizeOf() {
			int sizeof = 5;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" operation := ");
			operation.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" check_ := ");
			check__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" any_port := ");
			any__port.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (operation.isBound()) {
				operation.set_implicit_omit();
			}
			if (check__.isBound()) {
				check__.set_implicit_omit();
			}
			if (any__port.isBound()) {
				any__port.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			port__name.encode_text(text_buf);
			reason.encode_text(text_buf);
			operation.encode_text(text_buf);
			check__.encode_text(text_buf);
			any__port.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			port__name.decode_text(text_buf);
			reason.decode_text(text_buf);
			operation.decode_text(text_buf);
			check__.decode_text(text_buf);
			any__port.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class MatchingProblemType_template extends Base_Template {

	private TitanCharString_template port__name; //CharString_Type
	private MatchingProblemType_reason_template reason; //TTCN3_Enumerated_Type
	private MatchingProblemType_operation_template operation; //TTCN3_Enumerated_Type
	private TitanBoolean_template check__; //Boolean_Type
	private TitanBoolean_template any__port; //Boolean_Type
	//originally value_list/list_value
	List<MatchingProblemType_template> list_value;

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
		}
		return port__name;
	}

	public MatchingProblemType_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public MatchingProblemType_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
		}
		return reason;
	}

	public MatchingProblemType_operation_template getOperation() {
		setSpecific();
		return operation;
	}

	public MatchingProblemType_operation_template constGetOperation() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field operation of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
		}
		return operation;
	}

	public TitanBoolean_template getCheck__() {
		setSpecific();
		return check__;
	}

	public TitanBoolean_template constGetCheck__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field check_ of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
		}
		return check__;
	}

	public TitanBoolean_template getAny__port() {
		setSpecific();
		return any__port;
	}

	public TitanBoolean_template constGetAny__port() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field any_port of a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
		}
		return any__port;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			port__name = new TitanCharString_template();
			reason = new MatchingProblemType_reason_template();
			operation = new MatchingProblemType_operation_template();
			check__ = new TitanBoolean_template();
			any__port = new TitanBoolean_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				port__name.assign(template_sel.ANY_VALUE);
				reason.assign(template_sel.ANY_VALUE);
				operation.assign(template_sel.ANY_VALUE);
				check__.assign(template_sel.ANY_VALUE);
				any__port.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public MatchingProblemType_template() {
	}

	public MatchingProblemType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public MatchingProblemType_template( final MatchingProblemType otherValue ) {
		copyValue(otherValue);
	}

	public MatchingProblemType_template( final MatchingProblemType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public MatchingProblemType_template( final Optional<MatchingProblemType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingProblemType from an unbound optional field.");
		}
	}

	//originally operator=
	public MatchingProblemType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public MatchingProblemType_template assign( final MatchingProblemType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public MatchingProblemType_template assign( final MatchingProblemType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public MatchingProblemType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingProblemType) {
				return assign((MatchingProblemType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingProblemType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingProblemType_template) {
				return assign((MatchingProblemType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingProblemType' can not be cast to {1}_template", otherValue));
		}

	public MatchingProblemType_template assign( final Optional<MatchingProblemType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingProblemType.");
		}
		return this;
	}

	private void copyValue(final MatchingProblemType other_value) {
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getOperation().isBound()) {
			getOperation().assign(other_value.getOperation());
		} else {
			getOperation().cleanUp();
		}
		if (other_value.getCheck__().isBound()) {
			getCheck__().assign(other_value.getCheck__());
		} else {
			getCheck__().cleanUp();
		}
		if (other_value.getAny__port().isBound()) {
			getAny__port().assign(other_value.getAny__port());
		} else {
			getAny__port().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final MatchingProblemType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOperation().get_selection()) {
				getOperation().cleanUp();
			} else {
				getOperation().assign(other_value.getOperation());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCheck__().get_selection()) {
				getCheck__().cleanUp();
			} else {
				getCheck__().assign(other_value.getCheck__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getAny__port().get_selection()) {
				getAny__port().cleanUp();
			} else {
				getAny__port().assign(other_value.getAny__port());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<MatchingProblemType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final MatchingProblemType_template temp = new MatchingProblemType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingProblemType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingProblemType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingProblemType.");
			}
			final MatchingProblemType ret_val = new MatchingProblemType();
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (operation.isBound()) {
				ret_val.operation.assign(operation.valueOf());
			}
			 if (check__.isBound()) {
				ret_val.check__.assign(check__.valueOf());
			}
			 if (any__port.isBound()) {
				ret_val.any__port.assign(any__port.valueOf());
			}
			return ret_val;
		}

		public MatchingProblemType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingProblemType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingProblemType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingProblemType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingProblemType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingProblemType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (operation.isBound()) {
				return true;
			}
			if (check__.isBound()) {
				return true;
			}
			if (any__port.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!operation.isValue()) {
				return false;
			}
			if (!check__.isValue()) {
				return false;
			}
			if (!any__port.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingProblemType other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingProblemType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getOperation().isBound()) {
					return false;
				}
				if(!operation.match(other_value.getOperation(), legacy)) {
					return false;
				}
				if(!other_value.getCheck__().isBound()) {
					return false;
				}
				if(!check__.match(other_value.getCheck__(), legacy)) {
					return false;
				}
				if(!other_value.getAny__port().isBound()) {
					return false;
				}
				if(!any__port.match(other_value.getAny__port(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingProblemType) {
		return match((MatchingProblemType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingProblemType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 5;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingProblemType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" operation := ");
				operation.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" check_ := ");
				check__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" any_port := ");
				any__port.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingProblemType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingProblemType) {
				log_match((MatchingProblemType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingProblemType.");
		}

		public void log_match(final MatchingProblemType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !operation.match(match_value.constGetOperation(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".operation");
							operation.log_match(match_value.constGetOperation(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !check__.match(match_value.constGetCheck__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".check_");
							check__.log_match(match_value.constGetCheck__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !any__port.match(match_value.constGetAny__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".any_port");
							any__port.log_match(match_value.constGetAny__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ operation := ");
				operation.log_match(match_value.constGetOperation(), legacy);
				TTCN_Logger.log_event_str("{ check_ := ");
				check__.log_match(match_value.constGetCheck__(), legacy);
				TTCN_Logger.log_event_str("{ any_port := ");
				any__port.log_match(match_value.constGetAny__port(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name.encode_text(text_buf);
				reason.encode_text(text_buf);
				operation.encode_text(text_buf);
				check__.encode_text(text_buf);
				any__port.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				reason = new MatchingProblemType_reason_template();
				reason.decode_text(text_buf);
				operation = new MatchingProblemType_operation_template();
				operation.decode_text(text_buf);
				check__ = new TitanBoolean_template();
				check__.decode_text(text_buf);
				any__port = new TitanBoolean_template();
				any__port.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingProblemType_template>(size);
				for(int i = 0; i < size; i++) {
					final MatchingProblemType_template temp = new MatchingProblemType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingProblemType.");
			}
		}
}
public static void MatchingProblemType_encoder(final MatchingProblemType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingProblemType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingProblemType_decoder( final TitanOctetString input_stream, final MatchingProblemType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingProblemType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Strings extends Base_Type {
		private final Strings_str__list str__list; //SequenceOf_Type

		public Strings() {
			str__list = new Strings_str__list();
		}

		public Strings( final Strings_str__list aStr__list ) {
			str__list = new Strings_str__list( aStr__list );
		}

		public Strings( final Strings aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Strings.");
			}
			str__list = new Strings_str__list();
			assign( aOtherValue );
		}
		public Strings assign(final Strings aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Strings");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getStr__list().isBound() ) {
					this.str__list.assign( aOtherValue.getStr__list() );
				} else {
					this.str__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Strings assign(final Base_Type otherValue) {
			if (otherValue instanceof Strings ) {
				return assign((Strings) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Strings", otherValue));
		}

		public void cleanUp() {
			str__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( str__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !str__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Strings aOtherValue ) {
			if ( !this.str__list.operatorEquals( aOtherValue.str__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Strings ) {
				return operatorEquals((Strings) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Strings", otherValue));
		}

		public Strings_str__list getStr__list() {
			return str__list;
		}

		public Strings_str__list constGetStr__list() {
			return str__list;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" str_list := ");
			str__list.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (str__list.isBound()) {
				str__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			str__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			str__list.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Strings_template extends Base_Template {

	private Strings_str__list_template str__list; //SequenceOf_Type
	//originally value_list/list_value
	List<Strings_template> list_value;

	public Strings_str__list_template getStr__list() {
		setSpecific();
		return str__list;
	}

	public Strings_str__list_template constGetStr__list() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field str_list of a non-specific template of type @TitanLoggerApi.Strings.");
		}
		return str__list;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			str__list = new Strings_str__list_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				str__list.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Strings_template() {
	}

	public Strings_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Strings_template( final Strings otherValue ) {
		copyValue(otherValue);
	}

	public Strings_template( final Strings_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Strings_template( final Optional<Strings> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Strings from an unbound optional field.");
		}
	}

	//originally operator=
	public Strings_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Strings_template assign( final Strings other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Strings_template assign( final Strings_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Strings_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Strings) {
				return assign((Strings) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Strings' can not be cast to {1}", otherValue));
		}

		@Override
		public Strings_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Strings_template) {
				return assign((Strings_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Strings' can not be cast to {1}_template", otherValue));
		}

	public Strings_template assign( final Optional<Strings> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Strings.");
		}
		return this;
	}

	private void copyValue(final Strings other_value) {
		if (other_value.getStr__list().isBound()) {
			getStr__list().assign(other_value.getStr__list());
		} else {
			getStr__list().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Strings_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getStr__list().get_selection()) {
				getStr__list().cleanUp();
			} else {
				getStr__list().assign(other_value.getStr__list());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Strings_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Strings_template temp = new Strings_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Strings.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Strings valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Strings.");
			}
			final Strings ret_val = new Strings();
			 if (str__list.isBound()) {
				ret_val.str__list.assign(str__list.valueOf());
			}
			return ret_val;
		}

		public Strings_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Strings.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Strings.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Strings.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Strings_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Strings_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (str__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!str__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Strings other_value) {
			return match(other_value, false);
		}

		public boolean match(final Strings other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getStr__list().isBound()) {
					return false;
				}
				if(!str__list.match(other_value.getStr__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Strings.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Strings) {
		return match((Strings)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Strings.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Strings containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Strings.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" str_list := ");
				str__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Strings match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Strings) {
				log_match((Strings)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Strings.");
		}

		public void log_match(final Strings match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !str__list.match(match_value.constGetStr__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".str_list");
							str__list.log_match(match_value.constGetStr__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ str_list := ");
				str__list.log_match(match_value.constGetStr__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				str__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Strings.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				str__list = new Strings_str__list_template();
				str__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Strings_template>(size);
				for(int i = 0; i < size; i++) {
					final Strings_template temp = new Strings_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Strings.");
			}
		}
}
public static void Strings_encoder(final Strings input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Strings_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Strings_decoder( final TitanOctetString input_stream, final Strings output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Strings' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Strings_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Setstate_state_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Setstate_state_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Setstate_state_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Setstate_state_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class PTC__exit extends Base_Type {
		private final TitanInteger compref; //Integer_Type
		private final TitanInteger pid; //Integer_Type
		private final TitanInteger statuscode; //Integer_Type

		public PTC__exit() {
			compref = new TitanInteger();
			pid = new TitanInteger();
			statuscode = new TitanInteger();
		}

		public PTC__exit( final TitanInteger aCompref, final TitanInteger aPid, final TitanInteger aStatuscode ) {
			compref = new TitanInteger( aCompref );
			pid = new TitanInteger( aPid );
			statuscode = new TitanInteger( aStatuscode );
		}

		public PTC__exit( final PTC__exit aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.PTC_exit.");
			}
			compref = new TitanInteger();
			pid = new TitanInteger();
			statuscode = new TitanInteger();
			assign( aOtherValue );
		}
		public PTC__exit assign(final PTC__exit aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.PTC_exit");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getPid().isBound() ) {
					this.pid.assign( aOtherValue.getPid() );
				} else {
					this.pid.cleanUp();
				}
				if ( aOtherValue.getStatuscode().isBound() ) {
					this.statuscode.assign( aOtherValue.getStatuscode() );
				} else {
					this.statuscode.cleanUp();
				}
			}

			return this;
		}

		@Override
		public PTC__exit assign(final Base_Type otherValue) {
			if (otherValue instanceof PTC__exit ) {
				return assign((PTC__exit) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PTC_exit", otherValue));
		}

		public void cleanUp() {
			compref.cleanUp();
			pid.cleanUp();
			statuscode.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( compref.isBound() ) { return true; }
			if ( pid.isBound() ) { return true; }
			if ( statuscode.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !compref.isValue() ) { return false; }
			if ( !pid.isValue() ) { return false; }
			if ( !statuscode.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final PTC__exit aOtherValue ) {
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.pid.operatorEquals( aOtherValue.pid ) ) { return false; }
			if ( !this.statuscode.operatorEquals( aOtherValue.statuscode ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof PTC__exit ) {
				return operatorEquals((PTC__exit) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.PTC_exit", otherValue));
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public TitanInteger getPid() {
			return pid;
		}

		public TitanInteger constGetPid() {
			return pid;
		}

		public TitanInteger getStatuscode() {
			return statuscode;
		}

		public TitanInteger constGetStatuscode() {
			return statuscode;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" pid := ");
			pid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" statuscode := ");
			statuscode.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (pid.isBound()) {
				pid.set_implicit_omit();
			}
			if (statuscode.isBound()) {
				statuscode.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			compref.encode_text(text_buf);
			pid.encode_text(text_buf);
			statuscode.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			compref.decode_text(text_buf);
			pid.decode_text(text_buf);
			statuscode.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class PTC__exit_template extends Base_Template {

	private TitanInteger_template compref; //Integer_Type
	private TitanInteger_template pid; //Integer_Type
	private TitanInteger_template statuscode; //Integer_Type
	//originally value_list/list_value
	List<PTC__exit_template> list_value;

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.PTC_exit.");
		}
		return compref;
	}

	public TitanInteger_template getPid() {
		setSpecific();
		return pid;
	}

	public TitanInteger_template constGetPid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field pid of a non-specific template of type @TitanLoggerApi.PTC_exit.");
		}
		return pid;
	}

	public TitanInteger_template getStatuscode() {
		setSpecific();
		return statuscode;
	}

	public TitanInteger_template constGetStatuscode() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field statuscode of a non-specific template of type @TitanLoggerApi.PTC_exit.");
		}
		return statuscode;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			compref = new TitanInteger_template();
			pid = new TitanInteger_template();
			statuscode = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				compref.assign(template_sel.ANY_VALUE);
				pid.assign(template_sel.ANY_VALUE);
				statuscode.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public PTC__exit_template() {
	}

	public PTC__exit_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public PTC__exit_template( final PTC__exit otherValue ) {
		copyValue(otherValue);
	}

	public PTC__exit_template( final PTC__exit_template otherValue ) {
		copyTemplate( otherValue );
	}

	public PTC__exit_template( final Optional<PTC__exit> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.PTC_exit from an unbound optional field.");
		}
	}

	//originally operator=
	public PTC__exit_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public PTC__exit_template assign( final PTC__exit other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public PTC__exit_template assign( final PTC__exit_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public PTC__exit_template assign(final Base_Type otherValue) {
			if (otherValue instanceof PTC__exit) {
				return assign((PTC__exit) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PTC__exit' can not be cast to {1}", otherValue));
		}

		@Override
		public PTC__exit_template assign(final Base_Template otherValue) {
			if (otherValue instanceof PTC__exit_template) {
				return assign((PTC__exit_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `PTC__exit' can not be cast to {1}_template", otherValue));
		}

	public PTC__exit_template assign( final Optional<PTC__exit> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.PTC_exit.");
		}
		return this;
	}

	private void copyValue(final PTC__exit other_value) {
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getPid().isBound()) {
			getPid().assign(other_value.getPid());
		} else {
			getPid().cleanUp();
		}
		if (other_value.getStatuscode().isBound()) {
			getStatuscode().assign(other_value.getStatuscode());
		} else {
			getStatuscode().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final PTC__exit_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPid().get_selection()) {
				getPid().cleanUp();
			} else {
				getPid().assign(other_value.getPid());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getStatuscode().get_selection()) {
				getStatuscode().cleanUp();
			} else {
				getStatuscode().assign(other_value.getStatuscode());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<PTC__exit_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final PTC__exit_template temp = new PTC__exit_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.PTC_exit.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public PTC__exit valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.PTC_exit.");
			}
			final PTC__exit ret_val = new PTC__exit();
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (pid.isBound()) {
				ret_val.pid.assign(pid.valueOf());
			}
			 if (statuscode.isBound()) {
				ret_val.statuscode.assign(statuscode.valueOf());
			}
			return ret_val;
		}

		public PTC__exit_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.PTC_exit.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.PTC_exit.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.PTC_exit.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<PTC__exit_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new PTC__exit_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (pid.isBound()) {
				return true;
			}
			if (statuscode.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!pid.isValue()) {
				return false;
			}
			if (!statuscode.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final PTC__exit other_value) {
			return match(other_value, false);
		}

		public boolean match(final PTC__exit other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getPid().isBound()) {
					return false;
				}
				if(!pid.match(other_value.getPid(), legacy)) {
					return false;
				}
				if(!other_value.getStatuscode().isBound()) {
					return false;
				}
				if(!statuscode.match(other_value.getStatuscode(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.PTC_exit.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof PTC__exit) {
		return match((PTC__exit)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type PTC__exit.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.PTC_exit containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.PTC_exit.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" pid := ");
				pid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" statuscode := ");
				statuscode.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final PTC__exit match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof PTC__exit) {
				log_match((PTC__exit)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.PTC_exit.");
		}

		public void log_match(final PTC__exit match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !pid.match(match_value.constGetPid(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".pid");
							pid.log_match(match_value.constGetPid(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !statuscode.match(match_value.constGetStatuscode(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".statuscode");
							statuscode.log_match(match_value.constGetStatuscode(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ pid := ");
				pid.log_match(match_value.constGetPid(), legacy);
				TTCN_Logger.log_event_str("{ statuscode := ");
				statuscode.log_match(match_value.constGetStatuscode(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				compref.encode_text(text_buf);
				pid.encode_text(text_buf);
				statuscode.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.PTC_exit.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				pid = new TitanInteger_template();
				pid.decode_text(text_buf);
				statuscode = new TitanInteger_template();
				statuscode.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<PTC__exit_template>(size);
				for(int i = 0; i < size; i++) {
					final PTC__exit_template temp = new PTC__exit_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.PTC_exit.");
			}
		}
}
public static void PTC__exit_encoder(final PTC__exit input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PTC__exit_decoder( final TitanOctetString input_stream, final PTC__exit output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_executorMisc_encoder(final ExecutorUnqualified input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_executorMisc_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_executorMisc_decoder( final TitanOctetString input_stream, final ExecutorUnqualified output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_executorMisc_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Port__Misc_reason extends Base_Type {
public enum enum_type {
removing__unterminated__connection (0),
removing__unterminated__mapping (1),
port__was__cleared (2),
local__connection__established (3),
local__connection__terminated (4),
port__is__waiting__for__connection__tcp (5),
port__is__waiting__for__connection__unix (6),
connection__established (7),
destroying__unestablished__connection (8),
terminating__connection (9),
sending__termination__request__failed (10),
termination__request__received (11),
acknowledging__termination__request__failed (12),
sending__would__block (13),
connection__accepted (14),
connection__reset__by__peer (15),
connection__closed__by__peer (16),
port__disconnected (17),
port__was__mapped__to__system (18),
port__was__unmapped__from__system (19),
UNKNOWN_VALUE(20),
UNBOUND_VALUE(21);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return removing__unterminated__connection;
case 1:  return removing__unterminated__mapping;
case 2:  return port__was__cleared;
case 3:  return local__connection__established;
case 4:  return local__connection__terminated;
case 5:  return port__is__waiting__for__connection__tcp;
case 6:  return port__is__waiting__for__connection__unix;
case 7:  return connection__established;
case 8:  return destroying__unestablished__connection;
case 9:  return terminating__connection;
case 10:  return sending__termination__request__failed;
case 11:  return termination__request__received;
case 12:  return acknowledging__termination__request__failed;
case 13:  return sending__would__block;
case 14:  return connection__accepted;
case 15:  return connection__reset__by__peer;
case 16:  return connection__closed__by__peer;
case 17:  return port__disconnected;
case 18:  return port__was__mapped__to__system;
case 19:  return port__was__unmapped__from__system;
case 20:  return UNKNOWN_VALUE;
case 21:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Port__Misc_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Port__Misc_reason(final Port__Misc_reason otherValue) {
enum_value = otherValue.enum_value;
}

public Port__Misc_reason(final Port__Misc_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public Port__Misc_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Port__Misc_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Port__Misc_reason assign(final Port__Misc_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Port__Misc_reason assign(final Base_Type otherValue){
if( otherValue instanceof Port__Misc_reason ) {
return assign((Port__Misc_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public Port__Misc_reason assign(final Port__Misc_reason.enum_type otherValue){
return assign( new Port__Misc_reason(otherValue) );
}

//originally operator=
public Port__Misc_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Port__Misc_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Port__Misc_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Port__Misc_reason) {
return operatorEquals( (Port__Misc_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Misc.reason.");
}
}

//originally operator==
public boolean operatorEquals(final Port__Misc_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Port__Misc_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Port__Misc_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Port__Misc_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Port__Misc_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__Misc_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Port__Misc_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Port__Misc_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Port__Misc_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__Misc_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Port__Misc_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Port__Misc_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Port__Misc_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Port__Misc_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("removing__unterminated__connection".equals(strPar) || "removing_unterminated_connection".equals(strPar)) {
return enum_type.removing__unterminated__connection;
}
if ("removing__unterminated__mapping".equals(strPar) || "removing_unterminated_mapping".equals(strPar)) {
return enum_type.removing__unterminated__mapping;
}
if ("port__was__cleared".equals(strPar) || "port_was_cleared".equals(strPar)) {
return enum_type.port__was__cleared;
}
if ("local__connection__established".equals(strPar) || "local_connection_established".equals(strPar)) {
return enum_type.local__connection__established;
}
if ("local__connection__terminated".equals(strPar) || "local_connection_terminated".equals(strPar)) {
return enum_type.local__connection__terminated;
}
if ("port__is__waiting__for__connection__tcp".equals(strPar) || "port_is_waiting_for_connection_tcp".equals(strPar)) {
return enum_type.port__is__waiting__for__connection__tcp;
}
if ("port__is__waiting__for__connection__unix".equals(strPar) || "port_is_waiting_for_connection_unix".equals(strPar)) {
return enum_type.port__is__waiting__for__connection__unix;
}
if ("connection__established".equals(strPar) || "connection_established".equals(strPar)) {
return enum_type.connection__established;
}
if ("destroying__unestablished__connection".equals(strPar) || "destroying_unestablished_connection".equals(strPar)) {
return enum_type.destroying__unestablished__connection;
}
if ("terminating__connection".equals(strPar) || "terminating_connection".equals(strPar)) {
return enum_type.terminating__connection;
}
if ("sending__termination__request__failed".equals(strPar) || "sending_termination_request_failed".equals(strPar)) {
return enum_type.sending__termination__request__failed;
}
if ("termination__request__received".equals(strPar) || "termination_request_received".equals(strPar)) {
return enum_type.termination__request__received;
}
if ("acknowledging__termination__request__failed".equals(strPar) || "acknowledging_termination_request_failed".equals(strPar)) {
return enum_type.acknowledging__termination__request__failed;
}
if ("sending__would__block".equals(strPar) || "sending_would_block".equals(strPar)) {
return enum_type.sending__would__block;
}
if ("connection__accepted".equals(strPar) || "connection_accepted".equals(strPar)) {
return enum_type.connection__accepted;
}
if ("connection__reset__by__peer".equals(strPar) || "connection_reset_by_peer".equals(strPar)) {
return enum_type.connection__reset__by__peer;
}
if ("connection__closed__by__peer".equals(strPar) || "connection_closed_by_peer".equals(strPar)) {
return enum_type.connection__closed__by__peer;
}
if ("port__disconnected".equals(strPar) || "port_disconnected".equals(strPar)) {
return enum_type.port__disconnected;
}
if ("port__was__mapped__to__system".equals(strPar) || "port_was_mapped_to_system".equals(strPar)) {
return enum_type.port__was__mapped__to__system;
}
if ("port__was__unmapped__from__system".equals(strPar) || "port_was_unmapped_from_system".equals(strPar)) {
return enum_type.port__was__unmapped__from__system;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Port_Misc.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Misc.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Port__Misc_reason_template extends Base_Template {
// single_value
private Port__Misc_reason.enum_type single_value;
// value_list part
private ArrayList<Port__Misc_reason_template> value_list;

private void copy_template(final Port__Misc_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Port__Misc_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Port__Misc_reason_template temp = new Port__Misc_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Port__Misc_reason.");
}
}

public Port__Misc_reason_template() {
}

public Port__Misc_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Port__Misc_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Port__Misc_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Port__Misc_reason with unknown numeric value "+ otherValue +".");
}
single_value = Port__Misc_reason.enum_type.getValue(otherValue);
}

public Port__Misc_reason_template(final Port__Misc_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Port__Misc_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Port__Misc_reason. ");
}
single_value = otherValue.enum_value;
}

public Port__Misc_reason_template(final Port__Misc_reason_template otherValue) {
copy_template(otherValue);
}

public Port__Misc_reason_template(final Port__Misc_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Port__Misc_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Port__Misc_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Port__Misc_reason_template assign(final int otherValue) {
if (!Port__Misc_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Port__Misc_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Port__Misc_reason_template assign(final Port__Misc_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Port__Misc_reason_template assign(final Port__Misc_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Port__Misc_reason_template assign(final Port__Misc_reason otherValue){
if (otherValue.enum_value == Port__Misc_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Port__Misc_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Port__Misc_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof Port__Misc_reason ) {
return assign((Port__Misc_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason' can not be cast to {1}", otherValue));
}

@Override
public Port__Misc_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof Port__Misc_reason_template ) {
return assign((Port__Misc_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Port__Misc_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Port__Misc_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Port__Misc_reason.");
}
}

// originally match
public boolean match(final Port__Misc_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Port__Misc_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Port__Misc_reason ) {
return match((Port__Misc_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Port__Misc_reason' can not be cast to {1}", otherValue));
}

public Port__Misc_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Port__Misc_reason.");
}
return new Port__Misc_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Port__Misc_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Port__Misc_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Port__Misc_reason_template());
}
}

public Port__Misc_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Port__Misc_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Port__Misc_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Port__Misc_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Port__Misc_reason.enum2str(single_value), Port__Misc_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Port__Misc_reason) {
log_match((Port__Misc_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Port_Misc.reason.");
}
public void log_match(final Port__Misc_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Port_Misc.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Port__Misc_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Port_Misc.reason.", temp));
}
single_value = Port__Misc_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Port__Misc_reason_template>(size);
for(int i = 0; i < size; i++) {
final Port__Misc_reason_template temp = new Port__Misc_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Port_Misc.reason.");
}
}
}
public static void Port__Misc_reason_encoder(final Port__Misc_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_reason_decoder( final TitanOctetString input_stream, final Port__Misc_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Port_Misc.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void QualifiedName_testcase__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(QualifiedName_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger QualifiedName_testcase__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(QualifiedName_testcase__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TitanLog extends Base_Type {
		private final TitanLog_sequence__list sequence__list; //SequenceOf_Type

		public TitanLog() {
			sequence__list = new TitanLog_sequence__list();
		}

		public TitanLog( final TitanLog_sequence__list aSequence__list ) {
			sequence__list = new TitanLog_sequence__list( aSequence__list );
		}

		public TitanLog( final TitanLog aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanLog.");
			}
			sequence__list = new TitanLog_sequence__list();
			assign( aOtherValue );
		}
		public TitanLog assign(final TitanLog aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanLog");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getSequence__list().isBound() ) {
					this.sequence__list.assign( aOtherValue.getSequence__list() );
				} else {
					this.sequence__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanLog assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog ) {
				return assign((TitanLog) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog", otherValue));
		}

		public void cleanUp() {
			sequence__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( sequence__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !sequence__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanLog aOtherValue ) {
			if ( !this.sequence__list.operatorEquals( aOtherValue.sequence__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog ) {
				return operatorEquals((TitanLog) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog", otherValue));
		}

		public TitanLog_sequence__list getSequence__list() {
			return sequence__list;
		}

		public TitanLog_sequence__list constGetSequence__list() {
			return sequence__list;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" sequence_list := ");
			sequence__list.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (sequence__list.isBound()) {
				sequence__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			sequence__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			sequence__list.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TitanLog_template extends Base_Template {

	private TitanLog_sequence__list_template sequence__list; //SequenceOf_Type
	//originally value_list/list_value
	List<TitanLog_template> list_value;

	public TitanLog_sequence__list_template getSequence__list() {
		setSpecific();
		return sequence__list;
	}

	public TitanLog_sequence__list_template constGetSequence__list() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field sequence_list of a non-specific template of type @TitanLoggerApi.TitanLog.");
		}
		return sequence__list;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			sequence__list = new TitanLog_sequence__list_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				sequence__list.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TitanLog_template() {
	}

	public TitanLog_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanLog_template( final TitanLog otherValue ) {
		copyValue(otherValue);
	}

	public TitanLog_template( final TitanLog_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanLog_template( final Optional<TitanLog> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog from an unbound optional field.");
		}
	}

	//originally operator=
	public TitanLog_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_template assign( final TitanLog other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_template assign( final TitanLog_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TitanLog_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog) {
				return assign((TitanLog) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanLog_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLog_template) {
				return assign((TitanLog_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog' can not be cast to {1}_template", otherValue));
		}

	public TitanLog_template assign( final Optional<TitanLog> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.");
		}
		return this;
	}

	private void copyValue(final TitanLog other_value) {
		if (other_value.getSequence__list().isBound()) {
			getSequence__list().assign(other_value.getSequence__list());
		} else {
			getSequence__list().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanLog_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSequence__list().get_selection()) {
				getSequence__list().cleanUp();
			} else {
				getSequence__list().assign(other_value.getSequence__list());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLog_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanLog_template temp = new TitanLog_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanLog valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.");
			}
			final TitanLog ret_val = new TitanLog();
			 if (sequence__list.isBound()) {
				ret_val.sequence__list.assign(sequence__list.valueOf());
			}
			return ret_val;
		}

		public TitanLog_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanLog.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanLog_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanLog_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (sequence__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!sequence__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanLog other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanLog other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getSequence__list().isBound()) {
					return false;
				}
				if(!sequence__list.match(other_value.getSequence__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TitanLog) {
		return match((TitanLog)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" sequence_list := ");
				sequence__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanLog match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLog) {
				log_match((TitanLog)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.");
		}

		public void log_match(final TitanLog match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !sequence__list.match(match_value.constGetSequence__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".sequence_list");
							sequence__list.log_match(match_value.constGetSequence__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ sequence_list := ");
				sequence__list.log_match(match_value.constGetSequence__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				sequence__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				sequence__list = new TitanLog_sequence__list_template();
				sequence__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_template>(size);
				for(int i = 0; i < size; i++) {
					final TitanLog_template temp = new TitanLog_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanLog.");
			}
		}
}
public static void TitanLog_encoder(final TitanLog input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLog_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLog_decoder( final TitanOctetString input_stream, final TitanLog output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLog_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ErrorEvent extends Base_Type {
		private final TitanCharString text; //CharString_Type

		public ErrorEvent() {
			text = new TitanCharString();
		}

		public ErrorEvent( final TitanCharString aText ) {
			text = new TitanCharString( aText );
		}

		public ErrorEvent( final ErrorEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ErrorEvent.");
			}
			text = new TitanCharString();
			assign( aOtherValue );
		}
		public ErrorEvent assign(final ErrorEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ErrorEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getText().isBound() ) {
					this.text.assign( aOtherValue.getText() );
				} else {
					this.text.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ErrorEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof ErrorEvent ) {
				return assign((ErrorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ErrorEvent", otherValue));
		}

		public void cleanUp() {
			text.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( text.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !text.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ErrorEvent aOtherValue ) {
			if ( !this.text.operatorEquals( aOtherValue.text ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ErrorEvent ) {
				return operatorEquals((ErrorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ErrorEvent", otherValue));
		}

		public TitanCharString getText() {
			return text;
		}

		public TitanCharString constGetText() {
			return text;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" text := ");
			text.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (text.isBound()) {
				text.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			text.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			text.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ErrorEvent_template extends Base_Template {

	private TitanCharString_template text; //CharString_Type
	//originally value_list/list_value
	List<ErrorEvent_template> list_value;

	public TitanCharString_template getText() {
		setSpecific();
		return text;
	}

	public TitanCharString_template constGetText() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field text of a non-specific template of type @TitanLoggerApi.ErrorEvent.");
		}
		return text;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			text = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				text.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ErrorEvent_template() {
	}

	public ErrorEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ErrorEvent_template( final ErrorEvent otherValue ) {
		copyValue(otherValue);
	}

	public ErrorEvent_template( final ErrorEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ErrorEvent_template( final Optional<ErrorEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ErrorEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public ErrorEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ErrorEvent_template assign( final ErrorEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ErrorEvent_template assign( final ErrorEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ErrorEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ErrorEvent) {
				return assign((ErrorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ErrorEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public ErrorEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ErrorEvent_template) {
				return assign((ErrorEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ErrorEvent' can not be cast to {1}_template", otherValue));
		}

	public ErrorEvent_template assign( final Optional<ErrorEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ErrorEvent.");
		}
		return this;
	}

	private void copyValue(final ErrorEvent other_value) {
		if (other_value.getText().isBound()) {
			getText().assign(other_value.getText());
		} else {
			getText().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ErrorEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getText().get_selection()) {
				getText().cleanUp();
			} else {
				getText().assign(other_value.getText());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ErrorEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ErrorEvent_template temp = new ErrorEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ErrorEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ErrorEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ErrorEvent.");
			}
			final ErrorEvent ret_val = new ErrorEvent();
			 if (text.isBound()) {
				ret_val.text.assign(text.valueOf());
			}
			return ret_val;
		}

		public ErrorEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ErrorEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ErrorEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ErrorEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ErrorEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ErrorEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (text.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!text.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ErrorEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ErrorEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getText().isBound()) {
					return false;
				}
				if(!text.match(other_value.getText(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ErrorEvent) {
		return match((ErrorEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ErrorEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ErrorEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" text := ");
				text.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ErrorEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ErrorEvent) {
				log_match((ErrorEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ErrorEvent.");
		}

		public void log_match(final ErrorEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !text.match(match_value.constGetText(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".text");
							text.log_match(match_value.constGetText(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ text := ");
				text.log_match(match_value.constGetText(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ErrorEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text = new TitanCharString_template();
				text.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ErrorEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final ErrorEvent_template temp = new ErrorEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ErrorEvent.");
			}
		}
}
public static void ErrorEvent_encoder(final ErrorEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ErrorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ErrorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ErrorEvent_decoder( final TitanOctetString input_stream, final ErrorEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ErrorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ErrorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingProblemType_any__port_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingProblemType_any__port_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingProblemType_any__port_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingProblemType_any__port_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_portEvent_encoder(final PortEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_portEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_portEvent_decoder( final TitanOctetString input_stream, final PortEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PortEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_portEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingDoneType_ptc_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingDoneType_ptc_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingDoneType_ptc_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingDoneType_ptc_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__recv_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void VerdictType_toVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictType_toVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictType_toVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictType_toVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void VerdictType_verdictReason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(VerdictType_verdictReason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger VerdictType_verdictReason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(VerdictType_verdictReason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ExecutorEvent extends Base_Type {
		private final ExecutorEvent_choice choice; //TTCN3_Choice_Type

		public ExecutorEvent() {
			choice = new ExecutorEvent_choice();
		}

		public ExecutorEvent( final ExecutorEvent_choice aChoice ) {
			choice = new ExecutorEvent_choice( aChoice );
		}

		public ExecutorEvent( final ExecutorEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorEvent.");
			}
			choice = new ExecutorEvent_choice();
			assign( aOtherValue );
		}
		public ExecutorEvent assign(final ExecutorEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorEvent ) {
				return assign((ExecutorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorEvent ) {
				return operatorEquals((ExecutorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorEvent", otherValue));
		}

		public ExecutorEvent_choice getChoice() {
			return choice;
		}

		public ExecutorEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ExecutorEvent_template extends Base_Template {

	private ExecutorEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<ExecutorEvent_template> list_value;

	public ExecutorEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public ExecutorEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.ExecutorEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new ExecutorEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ExecutorEvent_template() {
	}

	public ExecutorEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ExecutorEvent_template( final ExecutorEvent otherValue ) {
		copyValue(otherValue);
	}

	public ExecutorEvent_template( final ExecutorEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ExecutorEvent_template( final Optional<ExecutorEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public ExecutorEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ExecutorEvent_template assign( final ExecutorEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ExecutorEvent_template assign( final ExecutorEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ExecutorEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorEvent) {
				return assign((ExecutorEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorEvent_template) {
				return assign((ExecutorEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorEvent' can not be cast to {1}_template", otherValue));
		}

	public ExecutorEvent_template assign( final Optional<ExecutorEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorEvent.");
		}
		return this;
	}

	private void copyValue(final ExecutorEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ExecutorEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ExecutorEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ExecutorEvent_template temp = new ExecutorEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorEvent.");
			}
			final ExecutorEvent ret_val = new ExecutorEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public ExecutorEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutorEvent) {
		return match((ExecutorEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorEvent) {
				log_match((ExecutorEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorEvent.");
		}

		public void log_match(final ExecutorEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new ExecutorEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final ExecutorEvent_template temp = new ExecutorEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorEvent.");
			}
		}
}
public static void ExecutorEvent_encoder(final ExecutorEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_decoder( final TitanOctetString input_stream, final ExecutorEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_passPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_passPercent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_passPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_passPercent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_extcommandStart_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_extcommandStart_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_extcommandStart_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_extcommandStart_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_compname_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_compname_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_compname_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_compname_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Parallel extends Base_Type {
		private final Parallel_reason reason; //TTCN3_Enumerated_Type
		private final TitanBoolean alive__; //Boolean_Type
		private final TitanCharString function__name; //CharString_Type
		private final TitanInteger src__compref; //Integer_Type
		private final TitanCharString src__port; //CharString_Type
		private final TitanInteger dst__compref; //Integer_Type
		private final TitanCharString dst__port; //CharString_Type

		public Parallel() {
			reason = new Parallel_reason();
			alive__ = new TitanBoolean();
			function__name = new TitanCharString();
			src__compref = new TitanInteger();
			src__port = new TitanCharString();
			dst__compref = new TitanInteger();
			dst__port = new TitanCharString();
		}

		public Parallel( final Parallel_reason aReason, final TitanBoolean aAlive__, final TitanCharString aFunction__name, final TitanInteger aSrc__compref, final TitanCharString aSrc__port, final TitanInteger aDst__compref, final TitanCharString aDst__port ) {
			reason = new Parallel_reason( aReason );
			alive__ = new TitanBoolean( aAlive__ );
			function__name = new TitanCharString( aFunction__name );
			src__compref = new TitanInteger( aSrc__compref );
			src__port = new TitanCharString( aSrc__port );
			dst__compref = new TitanInteger( aDst__compref );
			dst__port = new TitanCharString( aDst__port );
		}

		public Parallel( final Parallel aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Parallel.");
			}
			reason = new Parallel_reason();
			alive__ = new TitanBoolean();
			function__name = new TitanCharString();
			src__compref = new TitanInteger();
			src__port = new TitanCharString();
			dst__compref = new TitanInteger();
			dst__port = new TitanCharString();
			assign( aOtherValue );
		}
		public Parallel assign(final Parallel aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Parallel");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getAlive__().isBound() ) {
					this.alive__.assign( aOtherValue.getAlive__() );
				} else {
					this.alive__.cleanUp();
				}
				if ( aOtherValue.getFunction__name().isBound() ) {
					this.function__name.assign( aOtherValue.getFunction__name() );
				} else {
					this.function__name.cleanUp();
				}
				if ( aOtherValue.getSrc__compref().isBound() ) {
					this.src__compref.assign( aOtherValue.getSrc__compref() );
				} else {
					this.src__compref.cleanUp();
				}
				if ( aOtherValue.getSrc__port().isBound() ) {
					this.src__port.assign( aOtherValue.getSrc__port() );
				} else {
					this.src__port.cleanUp();
				}
				if ( aOtherValue.getDst__compref().isBound() ) {
					this.dst__compref.assign( aOtherValue.getDst__compref() );
				} else {
					this.dst__compref.cleanUp();
				}
				if ( aOtherValue.getDst__port().isBound() ) {
					this.dst__port.assign( aOtherValue.getDst__port() );
				} else {
					this.dst__port.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Parallel assign(final Base_Type otherValue) {
			if (otherValue instanceof Parallel ) {
				return assign((Parallel) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Parallel", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			alive__.cleanUp();
			function__name.cleanUp();
			src__compref.cleanUp();
			src__port.cleanUp();
			dst__compref.cleanUp();
			dst__port.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( alive__.isBound() ) { return true; }
			if ( function__name.isBound() ) { return true; }
			if ( src__compref.isBound() ) { return true; }
			if ( src__port.isBound() ) { return true; }
			if ( dst__compref.isBound() ) { return true; }
			if ( dst__port.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !alive__.isValue() ) { return false; }
			if ( !function__name.isValue() ) { return false; }
			if ( !src__compref.isValue() ) { return false; }
			if ( !src__port.isValue() ) { return false; }
			if ( !dst__compref.isValue() ) { return false; }
			if ( !dst__port.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Parallel aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.alive__.operatorEquals( aOtherValue.alive__ ) ) { return false; }
			if ( !this.function__name.operatorEquals( aOtherValue.function__name ) ) { return false; }
			if ( !this.src__compref.operatorEquals( aOtherValue.src__compref ) ) { return false; }
			if ( !this.src__port.operatorEquals( aOtherValue.src__port ) ) { return false; }
			if ( !this.dst__compref.operatorEquals( aOtherValue.dst__compref ) ) { return false; }
			if ( !this.dst__port.operatorEquals( aOtherValue.dst__port ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Parallel ) {
				return operatorEquals((Parallel) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Parallel", otherValue));
		}

		public Parallel_reason getReason() {
			return reason;
		}

		public Parallel_reason constGetReason() {
			return reason;
		}

		public TitanBoolean getAlive__() {
			return alive__;
		}

		public TitanBoolean constGetAlive__() {
			return alive__;
		}

		public TitanCharString getFunction__name() {
			return function__name;
		}

		public TitanCharString constGetFunction__name() {
			return function__name;
		}

		public TitanInteger getSrc__compref() {
			return src__compref;
		}

		public TitanInteger constGetSrc__compref() {
			return src__compref;
		}

		public TitanCharString getSrc__port() {
			return src__port;
		}

		public TitanCharString constGetSrc__port() {
			return src__port;
		}

		public TitanInteger getDst__compref() {
			return dst__compref;
		}

		public TitanInteger constGetDst__compref() {
			return dst__compref;
		}

		public TitanCharString getDst__port() {
			return dst__port;
		}

		public TitanCharString constGetDst__port() {
			return dst__port;
		}

		public TitanInteger sizeOf() {
			int sizeof = 7;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" alive_ := ");
			alive__.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" function_name := ");
			function__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" src_compref := ");
			src__compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" src_port := ");
			src__port.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dst_compref := ");
			dst__compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" dst_port := ");
			dst__port.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (alive__.isBound()) {
				alive__.set_implicit_omit();
			}
			if (function__name.isBound()) {
				function__name.set_implicit_omit();
			}
			if (src__compref.isBound()) {
				src__compref.set_implicit_omit();
			}
			if (src__port.isBound()) {
				src__port.set_implicit_omit();
			}
			if (dst__compref.isBound()) {
				dst__compref.set_implicit_omit();
			}
			if (dst__port.isBound()) {
				dst__port.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			alive__.encode_text(text_buf);
			function__name.encode_text(text_buf);
			src__compref.encode_text(text_buf);
			src__port.encode_text(text_buf);
			dst__compref.encode_text(text_buf);
			dst__port.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			alive__.decode_text(text_buf);
			function__name.decode_text(text_buf);
			src__compref.decode_text(text_buf);
			src__port.decode_text(text_buf);
			dst__compref.decode_text(text_buf);
			dst__port.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Parallel_template extends Base_Template {

	private Parallel_reason_template reason; //TTCN3_Enumerated_Type
	private TitanBoolean_template alive__; //Boolean_Type
	private TitanCharString_template function__name; //CharString_Type
	private TitanInteger_template src__compref; //Integer_Type
	private TitanCharString_template src__port; //CharString_Type
	private TitanInteger_template dst__compref; //Integer_Type
	private TitanCharString_template dst__port; //CharString_Type
	//originally value_list/list_value
	List<Parallel_template> list_value;

	public Parallel_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public Parallel_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return reason;
	}

	public TitanBoolean_template getAlive__() {
		setSpecific();
		return alive__;
	}

	public TitanBoolean_template constGetAlive__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field alive_ of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return alive__;
	}

	public TitanCharString_template getFunction__name() {
		setSpecific();
		return function__name;
	}

	public TitanCharString_template constGetFunction__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field function_name of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return function__name;
	}

	public TitanInteger_template getSrc__compref() {
		setSpecific();
		return src__compref;
	}

	public TitanInteger_template constGetSrc__compref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field src_compref of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return src__compref;
	}

	public TitanCharString_template getSrc__port() {
		setSpecific();
		return src__port;
	}

	public TitanCharString_template constGetSrc__port() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field src_port of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return src__port;
	}

	public TitanInteger_template getDst__compref() {
		setSpecific();
		return dst__compref;
	}

	public TitanInteger_template constGetDst__compref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field dst_compref of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return dst__compref;
	}

	public TitanCharString_template getDst__port() {
		setSpecific();
		return dst__port;
	}

	public TitanCharString_template constGetDst__port() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field dst_port of a non-specific template of type @TitanLoggerApi.Parallel.");
		}
		return dst__port;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new Parallel_reason_template();
			alive__ = new TitanBoolean_template();
			function__name = new TitanCharString_template();
			src__compref = new TitanInteger_template();
			src__port = new TitanCharString_template();
			dst__compref = new TitanInteger_template();
			dst__port = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				alive__.assign(template_sel.ANY_VALUE);
				function__name.assign(template_sel.ANY_VALUE);
				src__compref.assign(template_sel.ANY_VALUE);
				src__port.assign(template_sel.ANY_VALUE);
				dst__compref.assign(template_sel.ANY_VALUE);
				dst__port.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Parallel_template() {
	}

	public Parallel_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Parallel_template( final Parallel otherValue ) {
		copyValue(otherValue);
	}

	public Parallel_template( final Parallel_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Parallel_template( final Optional<Parallel> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Parallel from an unbound optional field.");
		}
	}

	//originally operator=
	public Parallel_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Parallel_template assign( final Parallel other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Parallel_template assign( final Parallel_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Parallel_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Parallel) {
				return assign((Parallel) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel' can not be cast to {1}", otherValue));
		}

		@Override
		public Parallel_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Parallel_template) {
				return assign((Parallel_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Parallel' can not be cast to {1}_template", otherValue));
		}

	public Parallel_template assign( final Optional<Parallel> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Parallel.");
		}
		return this;
	}

	private void copyValue(final Parallel other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getAlive__().isBound()) {
			getAlive__().assign(other_value.getAlive__());
		} else {
			getAlive__().cleanUp();
		}
		if (other_value.getFunction__name().isBound()) {
			getFunction__name().assign(other_value.getFunction__name());
		} else {
			getFunction__name().cleanUp();
		}
		if (other_value.getSrc__compref().isBound()) {
			getSrc__compref().assign(other_value.getSrc__compref());
		} else {
			getSrc__compref().cleanUp();
		}
		if (other_value.getSrc__port().isBound()) {
			getSrc__port().assign(other_value.getSrc__port());
		} else {
			getSrc__port().cleanUp();
		}
		if (other_value.getDst__compref().isBound()) {
			getDst__compref().assign(other_value.getDst__compref());
		} else {
			getDst__compref().cleanUp();
		}
		if (other_value.getDst__port().isBound()) {
			getDst__port().assign(other_value.getDst__port());
		} else {
			getDst__port().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Parallel_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getAlive__().get_selection()) {
				getAlive__().cleanUp();
			} else {
				getAlive__().assign(other_value.getAlive__());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFunction__name().get_selection()) {
				getFunction__name().cleanUp();
			} else {
				getFunction__name().assign(other_value.getFunction__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSrc__compref().get_selection()) {
				getSrc__compref().cleanUp();
			} else {
				getSrc__compref().assign(other_value.getSrc__compref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getSrc__port().get_selection()) {
				getSrc__port().cleanUp();
			} else {
				getSrc__port().assign(other_value.getSrc__port());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getDst__compref().get_selection()) {
				getDst__compref().cleanUp();
			} else {
				getDst__compref().assign(other_value.getDst__compref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getDst__port().get_selection()) {
				getDst__port().cleanUp();
			} else {
				getDst__port().assign(other_value.getDst__port());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Parallel_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Parallel_template temp = new Parallel_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Parallel.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Parallel valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Parallel.");
			}
			final Parallel ret_val = new Parallel();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (alive__.isBound()) {
				ret_val.alive__.assign(alive__.valueOf());
			}
			 if (function__name.isBound()) {
				ret_val.function__name.assign(function__name.valueOf());
			}
			 if (src__compref.isBound()) {
				ret_val.src__compref.assign(src__compref.valueOf());
			}
			 if (src__port.isBound()) {
				ret_val.src__port.assign(src__port.valueOf());
			}
			 if (dst__compref.isBound()) {
				ret_val.dst__compref.assign(dst__compref.valueOf());
			}
			 if (dst__port.isBound()) {
				ret_val.dst__port.assign(dst__port.valueOf());
			}
			return ret_val;
		}

		public Parallel_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Parallel.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Parallel.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Parallel.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Parallel_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Parallel_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (alive__.isBound()) {
				return true;
			}
			if (function__name.isBound()) {
				return true;
			}
			if (src__compref.isBound()) {
				return true;
			}
			if (src__port.isBound()) {
				return true;
			}
			if (dst__compref.isBound()) {
				return true;
			}
			if (dst__port.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!alive__.isValue()) {
				return false;
			}
			if (!function__name.isValue()) {
				return false;
			}
			if (!src__compref.isValue()) {
				return false;
			}
			if (!src__port.isValue()) {
				return false;
			}
			if (!dst__compref.isValue()) {
				return false;
			}
			if (!dst__port.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Parallel other_value) {
			return match(other_value, false);
		}

		public boolean match(final Parallel other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getAlive__().isBound()) {
					return false;
				}
				if(!alive__.match(other_value.getAlive__(), legacy)) {
					return false;
				}
				if(!other_value.getFunction__name().isBound()) {
					return false;
				}
				if(!function__name.match(other_value.getFunction__name(), legacy)) {
					return false;
				}
				if(!other_value.getSrc__compref().isBound()) {
					return false;
				}
				if(!src__compref.match(other_value.getSrc__compref(), legacy)) {
					return false;
				}
				if(!other_value.getSrc__port().isBound()) {
					return false;
				}
				if(!src__port.match(other_value.getSrc__port(), legacy)) {
					return false;
				}
				if(!other_value.getDst__compref().isBound()) {
					return false;
				}
				if(!dst__compref.match(other_value.getDst__compref(), legacy)) {
					return false;
				}
				if(!other_value.getDst__port().isBound()) {
					return false;
				}
				if(!dst__port.match(other_value.getDst__port(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Parallel.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Parallel) {
		return match((Parallel)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Parallel.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 7;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Parallel containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Parallel.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" alive_ := ");
				alive__.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" function_name := ");
				function__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" src_compref := ");
				src__compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" src_port := ");
				src__port.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dst_compref := ");
				dst__compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" dst_port := ");
				dst__port.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Parallel match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Parallel) {
				log_match((Parallel)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Parallel.");
		}

		public void log_match(final Parallel match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !alive__.match(match_value.constGetAlive__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".alive_");
							alive__.log_match(match_value.constGetAlive__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !function__name.match(match_value.constGetFunction__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".function_name");
							function__name.log_match(match_value.constGetFunction__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !src__compref.match(match_value.constGetSrc__compref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".src_compref");
							src__compref.log_match(match_value.constGetSrc__compref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !src__port.match(match_value.constGetSrc__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".src_port");
							src__port.log_match(match_value.constGetSrc__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dst__compref.match(match_value.constGetDst__compref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dst_compref");
							dst__compref.log_match(match_value.constGetDst__compref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !dst__port.match(match_value.constGetDst__port(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".dst_port");
							dst__port.log_match(match_value.constGetDst__port(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ alive_ := ");
				alive__.log_match(match_value.constGetAlive__(), legacy);
				TTCN_Logger.log_event_str("{ function_name := ");
				function__name.log_match(match_value.constGetFunction__name(), legacy);
				TTCN_Logger.log_event_str("{ src_compref := ");
				src__compref.log_match(match_value.constGetSrc__compref(), legacy);
				TTCN_Logger.log_event_str("{ src_port := ");
				src__port.log_match(match_value.constGetSrc__port(), legacy);
				TTCN_Logger.log_event_str("{ dst_compref := ");
				dst__compref.log_match(match_value.constGetDst__compref(), legacy);
				TTCN_Logger.log_event_str("{ dst_port := ");
				dst__port.log_match(match_value.constGetDst__port(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				alive__.encode_text(text_buf);
				function__name.encode_text(text_buf);
				src__compref.encode_text(text_buf);
				src__port.encode_text(text_buf);
				dst__compref.encode_text(text_buf);
				dst__port.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Parallel.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new Parallel_reason_template();
				reason.decode_text(text_buf);
				alive__ = new TitanBoolean_template();
				alive__.decode_text(text_buf);
				function__name = new TitanCharString_template();
				function__name.decode_text(text_buf);
				src__compref = new TitanInteger_template();
				src__compref.decode_text(text_buf);
				src__port = new TitanCharString_template();
				src__port.decode_text(text_buf);
				dst__compref = new TitanInteger_template();
				dst__compref.decode_text(text_buf);
				dst__port = new TitanCharString_template();
				dst__port.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Parallel_template>(size);
				for(int i = 0; i < size; i++) {
					final Parallel_template temp = new Parallel_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Parallel.");
			}
		}
}
public static void Parallel_encoder(final Parallel input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Parallel_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Parallel_decoder( final TitanOctetString input_stream, final Parallel output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Parallel' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Parallel_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ExecutorRuntime extends Base_Type {
		private final ExecutorRuntime_reason reason; //TTCN3_Enumerated_Type
		private final Optional<TitanCharString> module__name; //CharString_Type
		private final Optional<TitanCharString> testcase__name; //CharString_Type
		private final Optional<TitanInteger> pid; //Integer_Type
		private final Optional<TitanInteger> fd__setsize; //Integer_Type

		public ExecutorRuntime() {
			reason = new ExecutorRuntime_reason();
			module__name = new Optional<TitanCharString>(TitanCharString.class);
			testcase__name = new Optional<TitanCharString>(TitanCharString.class);
			pid = new Optional<TitanInteger>(TitanInteger.class);
			fd__setsize = new Optional<TitanInteger>(TitanInteger.class);
		}

		public ExecutorRuntime( final ExecutorRuntime_reason aReason, final Optional<TitanCharString> aModule__name, final Optional<TitanCharString> aTestcase__name, final Optional<TitanInteger> aPid, final Optional<TitanInteger> aFd__setsize ) {
			reason = new ExecutorRuntime_reason( aReason );
			module__name = new Optional<TitanCharString>(TitanCharString.class);
			this.module__name.assign( aModule__name );
			testcase__name = new Optional<TitanCharString>(TitanCharString.class);
			this.testcase__name.assign( aTestcase__name );
			pid = new Optional<TitanInteger>(TitanInteger.class);
			this.pid.assign( aPid );
			fd__setsize = new Optional<TitanInteger>(TitanInteger.class);
			this.fd__setsize.assign( aFd__setsize );
		}

		public ExecutorRuntime( final ExecutorRuntime aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorRuntime.");
			}
			reason = new ExecutorRuntime_reason();
			module__name = new Optional<TitanCharString>(TitanCharString.class);
			testcase__name = new Optional<TitanCharString>(TitanCharString.class);
			pid = new Optional<TitanInteger>(TitanInteger.class);
			fd__setsize = new Optional<TitanInteger>(TitanInteger.class);
			assign( aOtherValue );
		}
		public ExecutorRuntime assign(final ExecutorRuntime aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorRuntime");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getModule__name().isBound() ) {
					this.module__name.assign( aOtherValue.getModule__name() );
				} else {
					this.module__name.cleanUp();
				}
				if ( aOtherValue.getTestcase__name().isBound() ) {
					this.testcase__name.assign( aOtherValue.getTestcase__name() );
				} else {
					this.testcase__name.cleanUp();
				}
				if ( aOtherValue.getPid().isBound() ) {
					this.pid.assign( aOtherValue.getPid() );
				} else {
					this.pid.cleanUp();
				}
				if ( aOtherValue.getFd__setsize().isBound() ) {
					this.fd__setsize.assign( aOtherValue.getFd__setsize() );
				} else {
					this.fd__setsize.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorRuntime assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorRuntime ) {
				return assign((ExecutorRuntime) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorRuntime", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			module__name.cleanUp();
			testcase__name.cleanUp();
			pid.cleanUp();
			fd__setsize.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(module__name.get_selection()) || module__name.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(testcase__name.get_selection()) || testcase__name.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(pid.get_selection()) || pid.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(fd__setsize.get_selection()) || fd__setsize.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(module__name.get_selection()) && !module__name.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(testcase__name.get_selection()) && !testcase__name.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(pid.get_selection()) && !pid.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(fd__setsize.get_selection()) && !fd__setsize.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorRuntime aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.module__name.operatorEquals( aOtherValue.module__name ) ) { return false; }
			if ( !this.testcase__name.operatorEquals( aOtherValue.testcase__name ) ) { return false; }
			if ( !this.pid.operatorEquals( aOtherValue.pid ) ) { return false; }
			if ( !this.fd__setsize.operatorEquals( aOtherValue.fd__setsize ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorRuntime ) {
				return operatorEquals((ExecutorRuntime) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorRuntime", otherValue));
		}

		public ExecutorRuntime_reason getReason() {
			return reason;
		}

		public ExecutorRuntime_reason constGetReason() {
			return reason;
		}

		public Optional<TitanCharString> getModule__name() {
			return module__name;
		}

		public Optional<TitanCharString> constGetModule__name() {
			return module__name;
		}

		public Optional<TitanCharString> getTestcase__name() {
			return testcase__name;
		}

		public Optional<TitanCharString> constGetTestcase__name() {
			return testcase__name;
		}

		public Optional<TitanInteger> getPid() {
			return pid;
		}

		public Optional<TitanInteger> constGetPid() {
			return pid;
		}

		public Optional<TitanInteger> getFd__setsize() {
			return fd__setsize;
		}

		public Optional<TitanInteger> constGetFd__setsize() {
			return fd__setsize;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			if (module__name.isPresent()) {
				sizeof++;
			}
			if (testcase__name.isPresent()) {
				sizeof++;
			}
			if (pid.isPresent()) {
				sizeof++;
			}
			if (fd__setsize.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" module_name := ");
			module__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" testcase_name := ");
			testcase__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" pid := ");
			pid.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" fd_setsize := ");
			fd__setsize.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (module__name.isBound()) {
				module__name.set_implicit_omit();
			} else {
				module__name.assign(template_sel.OMIT_VALUE);
			}
			if (testcase__name.isBound()) {
				testcase__name.set_implicit_omit();
			} else {
				testcase__name.assign(template_sel.OMIT_VALUE);
			}
			if (pid.isBound()) {
				pid.set_implicit_omit();
			} else {
				pid.assign(template_sel.OMIT_VALUE);
			}
			if (fd__setsize.isBound()) {
				fd__setsize.set_implicit_omit();
			} else {
				fd__setsize.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			module__name.encode_text(text_buf);
			testcase__name.encode_text(text_buf);
			pid.encode_text(text_buf);
			fd__setsize.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			module__name.decode_text(text_buf);
			testcase__name.decode_text(text_buf);
			pid.decode_text(text_buf);
			fd__setsize.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ExecutorRuntime_template extends Base_Template {

	private ExecutorRuntime_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template module__name; //CharString_Type
	private TitanCharString_template testcase__name; //CharString_Type
	private TitanInteger_template pid; //Integer_Type
	private TitanInteger_template fd__setsize; //Integer_Type
	//originally value_list/list_value
	List<ExecutorRuntime_template> list_value;

	public ExecutorRuntime_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public ExecutorRuntime_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		return reason;
	}

	public TitanCharString_template getModule__name() {
		setSpecific();
		return module__name;
	}

	public TitanCharString_template constGetModule__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field module_name of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		return module__name;
	}

	public TitanCharString_template getTestcase__name() {
		setSpecific();
		return testcase__name;
	}

	public TitanCharString_template constGetTestcase__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field testcase_name of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		return testcase__name;
	}

	public TitanInteger_template getPid() {
		setSpecific();
		return pid;
	}

	public TitanInteger_template constGetPid() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field pid of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		return pid;
	}

	public TitanInteger_template getFd__setsize() {
		setSpecific();
		return fd__setsize;
	}

	public TitanInteger_template constGetFd__setsize() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field fd_setsize of a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		return fd__setsize;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new ExecutorRuntime_reason_template();
			module__name = new TitanCharString_template();
			testcase__name = new TitanCharString_template();
			pid = new TitanInteger_template();
			fd__setsize = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				module__name.assign(template_sel.ANY_OR_OMIT);
				testcase__name.assign(template_sel.ANY_OR_OMIT);
				pid.assign(template_sel.ANY_OR_OMIT);
				fd__setsize.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public ExecutorRuntime_template() {
	}

	public ExecutorRuntime_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ExecutorRuntime_template( final ExecutorRuntime otherValue ) {
		copyValue(otherValue);
	}

	public ExecutorRuntime_template( final ExecutorRuntime_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ExecutorRuntime_template( final Optional<ExecutorRuntime> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorRuntime from an unbound optional field.");
		}
	}

	//originally operator=
	public ExecutorRuntime_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ExecutorRuntime_template assign( final ExecutorRuntime other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ExecutorRuntime_template assign( final ExecutorRuntime_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ExecutorRuntime_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorRuntime) {
				return assign((ExecutorRuntime) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorRuntime_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorRuntime_template) {
				return assign((ExecutorRuntime_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorRuntime' can not be cast to {1}_template", otherValue));
		}

	public ExecutorRuntime_template assign( final Optional<ExecutorRuntime> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		return this;
	}

	private void copyValue(final ExecutorRuntime other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getModule__name().isBound()) {
			if (other_value.getModule__name().isPresent()) {
				getModule__name().assign(other_value.getModule__name().get());
			} else {
				getModule__name().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getModule__name().cleanUp();
		}
		if (other_value.getTestcase__name().isBound()) {
			if (other_value.getTestcase__name().isPresent()) {
				getTestcase__name().assign(other_value.getTestcase__name().get());
			} else {
				getTestcase__name().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getTestcase__name().cleanUp();
		}
		if (other_value.getPid().isBound()) {
			if (other_value.getPid().isPresent()) {
				getPid().assign(other_value.getPid().get());
			} else {
				getPid().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getPid().cleanUp();
		}
		if (other_value.getFd__setsize().isBound()) {
			if (other_value.getFd__setsize().isPresent()) {
				getFd__setsize().assign(other_value.getFd__setsize().get());
			} else {
				getFd__setsize().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getFd__setsize().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ExecutorRuntime_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getModule__name().get_selection()) {
				getModule__name().cleanUp();
			} else {
				getModule__name().assign(other_value.getModule__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTestcase__name().get_selection()) {
				getTestcase__name().cleanUp();
			} else {
				getTestcase__name().assign(other_value.getTestcase__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPid().get_selection()) {
				getPid().cleanUp();
			} else {
				getPid().assign(other_value.getPid());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFd__setsize().get_selection()) {
				getFd__setsize().cleanUp();
			} else {
				getFd__setsize().assign(other_value.getFd__setsize());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ExecutorRuntime_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ExecutorRuntime_template temp = new ExecutorRuntime_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorRuntime.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorRuntime valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			final ExecutorRuntime ret_val = new ExecutorRuntime();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			if (module__name.isOmit()) {
				ret_val.module__name.assign(template_sel.OMIT_VALUE);
			} else if (module__name.isBound()) {
				ret_val.module__name.assign(module__name.valueOf());
			}
			if (testcase__name.isOmit()) {
				ret_val.testcase__name.assign(template_sel.OMIT_VALUE);
			} else if (testcase__name.isBound()) {
				ret_val.testcase__name.assign(testcase__name.valueOf());
			}
			if (pid.isOmit()) {
				ret_val.pid.assign(template_sel.OMIT_VALUE);
			} else if (pid.isBound()) {
				ret_val.pid.assign(pid.valueOf());
			}
			if (fd__setsize.isOmit()) {
				ret_val.fd__setsize.assign(template_sel.OMIT_VALUE);
			} else if (fd__setsize.isBound()) {
				ret_val.fd__setsize.assign(fd__setsize.valueOf());
			}
			return ret_val;
		}

		public ExecutorRuntime_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorRuntime.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorRuntime_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorRuntime_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (module__name.isOmit() || module__name.isBound()) {
				return true;
			}
			if (testcase__name.isOmit() || testcase__name.isBound()) {
				return true;
			}
			if (pid.isOmit() || pid.isBound()) {
				return true;
			}
			if (fd__setsize.isOmit() || fd__setsize.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!module__name.isOmit() && !module__name.isValue()) {
				return false;
			}
			if (!testcase__name.isOmit() && !testcase__name.isValue()) {
				return false;
			}
			if (!pid.isOmit() && !pid.isValue()) {
				return false;
			}
			if (!fd__setsize.isOmit() && !fd__setsize.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorRuntime other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorRuntime other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getModule__name().isBound()) {
					return false;
				}
				if((other_value.getModule__name().isPresent() ? !module__name.match(other_value.getModule__name().get(), legacy) : !module__name.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getTestcase__name().isBound()) {
					return false;
				}
				if((other_value.getTestcase__name().isPresent() ? !testcase__name.match(other_value.getTestcase__name().get(), legacy) : !testcase__name.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getPid().isBound()) {
					return false;
				}
				if((other_value.getPid().isPresent() ? !pid.match(other_value.getPid().get(), legacy) : !pid.match_omit(legacy))) {
					return false;
				}
				if(!other_value.getFd__setsize().isBound()) {
					return false;
				}
				if((other_value.getFd__setsize().isPresent() ? !fd__setsize.match(other_value.getFd__setsize().get(), legacy) : !fd__setsize.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutorRuntime) {
		return match((ExecutorRuntime)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorRuntime.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				if (module__name.isPresent()) {
					sizeof++;
				}
				if (testcase__name.isPresent()) {
					sizeof++;
				}
				if (pid.isPresent()) {
					sizeof++;
				}
				if (fd__setsize.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorRuntime containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" module_name := ");
				module__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" testcase_name := ");
				testcase__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" pid := ");
				pid.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" fd_setsize := ");
				fd__setsize.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorRuntime match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorRuntime) {
				log_match((ExecutorRuntime)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorRuntime.");
		}

		public void log_match(final ExecutorRuntime match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetModule__name().isPresent()) {
							if( !module__name.match(match_value.constGetModule__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".module_name");
								module__name.log_match(match_value.constGetModule__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!module__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".module_name := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								module__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetTestcase__name().isPresent()) {
							if( !testcase__name.match(match_value.constGetTestcase__name().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".testcase_name");
								testcase__name.log_match(match_value.constGetTestcase__name().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!testcase__name.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".testcase_name := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								testcase__name.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetPid().isPresent()) {
							if( !pid.match(match_value.constGetPid().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".pid");
								pid.log_match(match_value.constGetPid().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!pid.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".pid := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								pid.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
						if (match_value.constGetFd__setsize().isPresent()) {
							if( !fd__setsize.match(match_value.constGetFd__setsize().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".fd_setsize");
								fd__setsize.log_match(match_value.constGetFd__setsize().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!fd__setsize.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".fd_setsize := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								fd__setsize.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ module_name := ");
				module__name.log_match(match_value.constGetModule__name(), legacy);
				TTCN_Logger.log_event_str("{ testcase_name := ");
				testcase__name.log_match(match_value.constGetTestcase__name(), legacy);
				TTCN_Logger.log_event_str("{ pid := ");
				pid.log_match(match_value.constGetPid(), legacy);
				TTCN_Logger.log_event_str("{ fd_setsize := ");
				fd__setsize.log_match(match_value.constGetFd__setsize(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				module__name.encode_text(text_buf);
				testcase__name.encode_text(text_buf);
				pid.encode_text(text_buf);
				fd__setsize.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorRuntime_reason_template();
				reason.decode_text(text_buf);
				module__name = new TitanCharString_template();
				module__name.decode_text(text_buf);
				testcase__name = new TitanCharString_template();
				testcase__name.decode_text(text_buf);
				pid = new TitanInteger_template();
				pid.decode_text(text_buf);
				fd__setsize = new TitanInteger_template();
				fd__setsize.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorRuntime_template>(size);
				for(int i = 0; i < size; i++) {
					final ExecutorRuntime_template temp = new ExecutorRuntime_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorRuntime.");
			}
		}
}
public static void ExecutorRuntime_encoder(final ExecutorRuntime input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorRuntime_decoder( final TitanOctetString input_stream, final ExecutorRuntime output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorRuntime' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorRuntime_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FunctionEvent_choice_random_operation_encoder(final RandomAction input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_choice_random_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_choice_random_operation_decoder( final TitanOctetString input_stream, final RandomAction output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_choice_random_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void SetVerdictType_oldVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(SetVerdictType_oldVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger SetVerdictType_oldVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(SetVerdictType_oldVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__in_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class FinalVerdictType extends Base_Type {
		private final FinalVerdictType_choice choice; //TTCN3_Choice_Type

		public FinalVerdictType() {
			choice = new FinalVerdictType_choice();
		}

		public FinalVerdictType( final FinalVerdictType_choice aChoice ) {
			choice = new FinalVerdictType_choice( aChoice );
		}

		public FinalVerdictType( final FinalVerdictType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.FinalVerdictType.");
			}
			choice = new FinalVerdictType_choice();
			assign( aOtherValue );
		}
		public FinalVerdictType assign(final FinalVerdictType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.FinalVerdictType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public FinalVerdictType assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictType ) {
				return assign((FinalVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictType", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final FinalVerdictType aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictType ) {
				return operatorEquals((FinalVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.FinalVerdictType", otherValue));
		}

		public FinalVerdictType_choice getChoice() {
			return choice;
		}

		public FinalVerdictType_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class FinalVerdictType_template extends Base_Template {

	private FinalVerdictType_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<FinalVerdictType_template> list_value;

	public FinalVerdictType_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public FinalVerdictType_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.FinalVerdictType.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new FinalVerdictType_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public FinalVerdictType_template() {
	}

	public FinalVerdictType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public FinalVerdictType_template( final FinalVerdictType otherValue ) {
		copyValue(otherValue);
	}

	public FinalVerdictType_template( final FinalVerdictType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public FinalVerdictType_template( final Optional<FinalVerdictType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.FinalVerdictType from an unbound optional field.");
		}
	}

	//originally operator=
	public FinalVerdictType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public FinalVerdictType_template assign( final FinalVerdictType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public FinalVerdictType_template assign( final FinalVerdictType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public FinalVerdictType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof FinalVerdictType) {
				return assign((FinalVerdictType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType' can not be cast to {1}", otherValue));
		}

		@Override
		public FinalVerdictType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof FinalVerdictType_template) {
				return assign((FinalVerdictType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType' can not be cast to {1}_template", otherValue));
		}

	public FinalVerdictType_template assign( final Optional<FinalVerdictType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.FinalVerdictType.");
		}
		return this;
	}

	private void copyValue(final FinalVerdictType other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final FinalVerdictType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<FinalVerdictType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final FinalVerdictType_template temp = new FinalVerdictType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.FinalVerdictType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public FinalVerdictType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.FinalVerdictType.");
			}
			final FinalVerdictType ret_val = new FinalVerdictType();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public FinalVerdictType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.FinalVerdictType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.FinalVerdictType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.FinalVerdictType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<FinalVerdictType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new FinalVerdictType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final FinalVerdictType other_value) {
			return match(other_value, false);
		}

		public boolean match(final FinalVerdictType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof FinalVerdictType) {
		return match((FinalVerdictType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type FinalVerdictType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.FinalVerdictType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final FinalVerdictType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof FinalVerdictType) {
				log_match((FinalVerdictType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.");
		}

		public void log_match(final FinalVerdictType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new FinalVerdictType_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<FinalVerdictType_template>(size);
				for(int i = 0; i < size; i++) {
					final FinalVerdictType_template temp = new FinalVerdictType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.FinalVerdictType.");
			}
		}
}
public static void FinalVerdictType_encoder(final FinalVerdictType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictType_decoder( final TitanOctetString input_stream, final FinalVerdictType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class FinalVerdictType_choice_notification extends Base_Type {
public enum enum_type {
setting__final__verdict__of__the__test__case (0),
no__ptcs__were__created (1),
UNKNOWN_VALUE(2),
UNBOUND_VALUE(3);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return setting__final__verdict__of__the__test__case;
case 1:  return no__ptcs__were__created;
case 2:  return UNKNOWN_VALUE;
case 3:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public FinalVerdictType_choice_notification() {
enum_value = enum_type.UNBOUND_VALUE;
}

public FinalVerdictType_choice_notification(final FinalVerdictType_choice_notification otherValue) {
enum_value = otherValue.enum_value;
}

public FinalVerdictType_choice_notification(final FinalVerdictType_choice_notification.enum_type otherValue ) {
enum_value = otherValue;
}

public FinalVerdictType_choice_notification(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `FinalVerdictType_choice_notification' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public FinalVerdictType_choice_notification assign(final FinalVerdictType_choice_notification otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public FinalVerdictType_choice_notification assign(final Base_Type otherValue){
if( otherValue instanceof FinalVerdictType_choice_notification ) {
return assign((FinalVerdictType_choice_notification) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification' can not be cast to {1}", otherValue));
}

//originally operator=
public FinalVerdictType_choice_notification assign(final FinalVerdictType_choice_notification.enum_type otherValue){
return assign( new FinalVerdictType_choice_notification(otherValue) );
}

//originally operator=
public FinalVerdictType_choice_notification assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `FinalVerdictType_choice_notification'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final FinalVerdictType_choice_notification otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof FinalVerdictType_choice_notification) {
return operatorEquals( (FinalVerdictType_choice_notification) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.notification.");
}
}

//originally operator==
public boolean operatorEquals(final FinalVerdictType_choice_notification.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final FinalVerdictType_choice_notification otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final FinalVerdictType_choice_notification.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final FinalVerdictType_choice_notification.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final FinalVerdictType_choice_notification otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final FinalVerdictType_choice_notification.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final FinalVerdictType_choice_notification otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final FinalVerdictType_choice_notification.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final FinalVerdictType_choice_notification otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final FinalVerdictType_choice_notification.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final FinalVerdictType_choice_notification otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final FinalVerdictType_choice_notification.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final FinalVerdictType_choice_notification enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("setting__final__verdict__of__the__test__case".equals(strPar) || "setting_final_verdict_of_the_test_case".equals(strPar)) {
return enum_type.setting__final__verdict__of__the__test__case;
}
if ("no__ptcs__were__created".equals(strPar) || "no_ptcs_were_created".equals(strPar)) {
return enum_type.no__ptcs__were__created;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class FinalVerdictType_choice_notification_template extends Base_Template {
// single_value
private FinalVerdictType_choice_notification.enum_type single_value;
// value_list part
private ArrayList<FinalVerdictType_choice_notification_template> value_list;

private void copy_template(final FinalVerdictType_choice_notification_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<FinalVerdictType_choice_notification_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final FinalVerdictType_choice_notification_template temp = new FinalVerdictType_choice_notification_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type FinalVerdictType_choice_notification.");
}
}

public FinalVerdictType_choice_notification_template() {
}

public FinalVerdictType_choice_notification_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public FinalVerdictType_choice_notification_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!FinalVerdictType_choice_notification.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type FinalVerdictType_choice_notification with unknown numeric value "+ otherValue +".");
}
single_value = FinalVerdictType_choice_notification.enum_type.getValue(otherValue);
}

public FinalVerdictType_choice_notification_template(final FinalVerdictType_choice_notification otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == FinalVerdictType_choice_notification.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type FinalVerdictType_choice_notification. ");
}
single_value = otherValue.enum_value;
}

public FinalVerdictType_choice_notification_template(final FinalVerdictType_choice_notification_template otherValue) {
copy_template(otherValue);
}

public FinalVerdictType_choice_notification_template(final FinalVerdictType_choice_notification.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != FinalVerdictType_choice_notification.enum_type.UNBOUND_VALUE;
}

//originally operator=
public FinalVerdictType_choice_notification_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public FinalVerdictType_choice_notification_template assign(final int otherValue) {
if (!FinalVerdictType_choice_notification.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type FinalVerdictType_choice_notification.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public FinalVerdictType_choice_notification_template assign(final FinalVerdictType_choice_notification.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public FinalVerdictType_choice_notification_template assign(final FinalVerdictType_choice_notification_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public FinalVerdictType_choice_notification_template assign(final FinalVerdictType_choice_notification otherValue){
if (otherValue.enum_value == FinalVerdictType_choice_notification.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type FinalVerdictType_choice_notification to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public FinalVerdictType_choice_notification_template assign(final Base_Type otherValue){
if( otherValue instanceof FinalVerdictType_choice_notification ) {
return assign((FinalVerdictType_choice_notification) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification' can not be cast to {1}", otherValue));
}

@Override
public FinalVerdictType_choice_notification_template assign(final Base_Template otherValue){
if( otherValue instanceof FinalVerdictType_choice_notification_template ) {
return assign((FinalVerdictType_choice_notification_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final FinalVerdictType_choice_notification.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final FinalVerdictType_choice_notification.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type FinalVerdictType_choice_notification.");
}
}

// originally match
public boolean match(final FinalVerdictType_choice_notification otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final FinalVerdictType_choice_notification otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof FinalVerdictType_choice_notification ) {
return match((FinalVerdictType_choice_notification) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `FinalVerdictType_choice_notification' can not be cast to {1}", otherValue));
}

public FinalVerdictType_choice_notification valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type FinalVerdictType_choice_notification.");
}
return new FinalVerdictType_choice_notification(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type FinalVerdictType_choice_notification.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<FinalVerdictType_choice_notification_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new FinalVerdictType_choice_notification_template());
}
}

public FinalVerdictType_choice_notification_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type FinalVerdictType_choice_notification.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type FinalVerdictType_choice_notification.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type FinalVerdictType_choice_notification.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(FinalVerdictType_choice_notification.enum2str(single_value), FinalVerdictType_choice_notification.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof FinalVerdictType_choice_notification) {
log_match((FinalVerdictType_choice_notification)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FinalVerdictType.choice.notification.");
}
public void log_match(final FinalVerdictType_choice_notification match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!FinalVerdictType_choice_notification.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.", temp));
}
single_value = FinalVerdictType_choice_notification.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<FinalVerdictType_choice_notification_template>(size);
for(int i = 0; i < size; i++) {
final FinalVerdictType_choice_notification_template temp = new FinalVerdictType_choice_notification_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.FinalVerdictType.choice.notification.");
}
}
}
public static void FinalVerdictType_choice_notification_encoder(final FinalVerdictType_choice_notification input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice.notification' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictType_choice_notification_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictType_choice_notification_decoder( final TitanOctetString input_stream, final FinalVerdictType_choice_notification output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictType.choice.notification' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictType_choice_notification_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ExecutorUnqualified_reason extends Base_Type {
public enum enum_type {
local__address__was__set (0),
address__of__mc__was__set (1),
address__of__control__connection (2),
host__support__unix__domain__sockets (3),
UNKNOWN_VALUE(4),
UNBOUND_VALUE(5);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return local__address__was__set;
case 1:  return address__of__mc__was__set;
case 2:  return address__of__control__connection;
case 3:  return host__support__unix__domain__sockets;
case 4:  return UNKNOWN_VALUE;
case 5:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public ExecutorUnqualified_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public ExecutorUnqualified_reason(final ExecutorUnqualified_reason otherValue) {
enum_value = otherValue.enum_value;
}

public ExecutorUnqualified_reason(final ExecutorUnqualified_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public ExecutorUnqualified_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorUnqualified_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public ExecutorUnqualified_reason assign(final ExecutorUnqualified_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public ExecutorUnqualified_reason assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorUnqualified_reason ) {
return assign((ExecutorUnqualified_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public ExecutorUnqualified_reason assign(final ExecutorUnqualified_reason.enum_type otherValue){
return assign( new ExecutorUnqualified_reason(otherValue) );
}

//originally operator=
public ExecutorUnqualified_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorUnqualified_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final ExecutorUnqualified_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof ExecutorUnqualified_reason) {
return operatorEquals( (ExecutorUnqualified_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorUnqualified.reason.");
}
}

//originally operator==
public boolean operatorEquals(final ExecutorUnqualified_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorUnqualified_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorUnqualified_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final ExecutorUnqualified_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final ExecutorUnqualified_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorUnqualified_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorUnqualified_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final ExecutorUnqualified_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final ExecutorUnqualified_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorUnqualified_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorUnqualified_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final ExecutorUnqualified_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final ExecutorUnqualified_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("local__address__was__set".equals(strPar) || "local_address_was_set".equals(strPar)) {
return enum_type.local__address__was__set;
}
if ("address__of__mc__was__set".equals(strPar) || "address_of_mc_was_set".equals(strPar)) {
return enum_type.address__of__mc__was__set;
}
if ("address__of__control__connection".equals(strPar) || "address_of_control_connection".equals(strPar)) {
return enum_type.address__of__control__connection;
}
if ("host__support__unix__domain__sockets".equals(strPar) || "host_support_unix_domain_sockets".equals(strPar)) {
return enum_type.host__support__unix__domain__sockets;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class ExecutorUnqualified_reason_template extends Base_Template {
// single_value
private ExecutorUnqualified_reason.enum_type single_value;
// value_list part
private ArrayList<ExecutorUnqualified_reason_template> value_list;

private void copy_template(final ExecutorUnqualified_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ExecutorUnqualified_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final ExecutorUnqualified_reason_template temp = new ExecutorUnqualified_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorUnqualified_reason.");
}
}

public ExecutorUnqualified_reason_template() {
}

public ExecutorUnqualified_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public ExecutorUnqualified_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!ExecutorUnqualified_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type ExecutorUnqualified_reason with unknown numeric value "+ otherValue +".");
}
single_value = ExecutorUnqualified_reason.enum_type.getValue(otherValue);
}

public ExecutorUnqualified_reason_template(final ExecutorUnqualified_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == ExecutorUnqualified_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorUnqualified_reason. ");
}
single_value = otherValue.enum_value;
}

public ExecutorUnqualified_reason_template(final ExecutorUnqualified_reason_template otherValue) {
copy_template(otherValue);
}

public ExecutorUnqualified_reason_template(final ExecutorUnqualified_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != ExecutorUnqualified_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public ExecutorUnqualified_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public ExecutorUnqualified_reason_template assign(final int otherValue) {
if (!ExecutorUnqualified_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorUnqualified_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public ExecutorUnqualified_reason_template assign(final ExecutorUnqualified_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public ExecutorUnqualified_reason_template assign(final ExecutorUnqualified_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public ExecutorUnqualified_reason_template assign(final ExecutorUnqualified_reason otherValue){
if (otherValue.enum_value == ExecutorUnqualified_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorUnqualified_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public ExecutorUnqualified_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorUnqualified_reason ) {
return assign((ExecutorUnqualified_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason' can not be cast to {1}", otherValue));
}

@Override
public ExecutorUnqualified_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof ExecutorUnqualified_reason_template ) {
return assign((ExecutorUnqualified_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final ExecutorUnqualified_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final ExecutorUnqualified_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorUnqualified_reason.");
}
}

// originally match
public boolean match(final ExecutorUnqualified_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final ExecutorUnqualified_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof ExecutorUnqualified_reason ) {
return match((ExecutorUnqualified_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified_reason' can not be cast to {1}", otherValue));
}

public ExecutorUnqualified_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorUnqualified_reason.");
}
return new ExecutorUnqualified_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorUnqualified_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<ExecutorUnqualified_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ExecutorUnqualified_reason_template());
}
}

public ExecutorUnqualified_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorUnqualified_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorUnqualified_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorUnqualified_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(ExecutorUnqualified_reason.enum2str(single_value), ExecutorUnqualified_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ExecutorUnqualified_reason) {
log_match((ExecutorUnqualified_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorUnqualified.reason.");
}
public void log_match(final ExecutorUnqualified_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!ExecutorUnqualified_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.", temp));
}
single_value = ExecutorUnqualified_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ExecutorUnqualified_reason_template>(size);
for(int i = 0; i < size; i++) {
final ExecutorUnqualified_reason_template temp = new ExecutorUnqualified_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorUnqualified.reason.");
}
}
}
public static void ExecutorUnqualified_reason_encoder(final ExecutorUnqualified_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorUnqualified_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorUnqualified_reason_decoder( final TitanOctetString input_stream, final ExecutorUnqualified_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorUnqualified_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__out_parameter_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__out_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__out_parameter_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__out_parameter_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParPort_srcCompref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParPort_srcCompref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParPort_srcCompref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParPort_srcCompref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Msg__port__recv_operation extends Base_Type {
public enum enum_type {
receive__op (0),
check__receive__op (1),
trigger__op (2),
UNKNOWN_VALUE(3),
UNBOUND_VALUE(4);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return receive__op;
case 1:  return check__receive__op;
case 2:  return trigger__op;
case 3:  return UNKNOWN_VALUE;
case 4:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Msg__port__recv_operation() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Msg__port__recv_operation(final Msg__port__recv_operation otherValue) {
enum_value = otherValue.enum_value;
}

public Msg__port__recv_operation(final Msg__port__recv_operation.enum_type otherValue ) {
enum_value = otherValue;
}

public Msg__port__recv_operation(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Msg__port__recv_operation' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Msg__port__recv_operation assign(final Msg__port__recv_operation otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Msg__port__recv_operation assign(final Base_Type otherValue){
if( otherValue instanceof Msg__port__recv_operation ) {
return assign((Msg__port__recv_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation' can not be cast to {1}", otherValue));
}

//originally operator=
public Msg__port__recv_operation assign(final Msg__port__recv_operation.enum_type otherValue){
return assign( new Msg__port__recv_operation(otherValue) );
}

//originally operator=
public Msg__port__recv_operation assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Msg__port__recv_operation'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Msg__port__recv_operation otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Msg__port__recv_operation) {
return operatorEquals( (Msg__port__recv_operation) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_recv.operation.");
}
}

//originally operator==
public boolean operatorEquals(final Msg__port__recv_operation.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Msg__port__recv_operation otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Msg__port__recv_operation.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Msg__port__recv_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Msg__port__recv_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Msg__port__recv_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Msg__port__recv_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Msg__port__recv_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Msg__port__recv_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Msg__port__recv_operation.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Msg__port__recv_operation otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Msg__port__recv_operation. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Msg__port__recv_operation.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Msg__port__recv_operation enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("receive__op".equals(strPar) || "receive_op".equals(strPar)) {
return enum_type.receive__op;
}
if ("check__receive__op".equals(strPar) || "check_receive_op".equals(strPar)) {
return enum_type.check__receive__op;
}
if ("trigger__op".equals(strPar) || "trigger_op".equals(strPar)) {
return enum_type.trigger__op;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Msg_port_recv.operation.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Msg_port_recv.operation.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Msg__port__recv_operation_template extends Base_Template {
// single_value
private Msg__port__recv_operation.enum_type single_value;
// value_list part
private ArrayList<Msg__port__recv_operation_template> value_list;

private void copy_template(final Msg__port__recv_operation_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Msg__port__recv_operation_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Msg__port__recv_operation_template temp = new Msg__port__recv_operation_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Msg__port__recv_operation.");
}
}

public Msg__port__recv_operation_template() {
}

public Msg__port__recv_operation_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Msg__port__recv_operation_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Msg__port__recv_operation.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Msg__port__recv_operation with unknown numeric value "+ otherValue +".");
}
single_value = Msg__port__recv_operation.enum_type.getValue(otherValue);
}

public Msg__port__recv_operation_template(final Msg__port__recv_operation otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Msg__port__recv_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Msg__port__recv_operation. ");
}
single_value = otherValue.enum_value;
}

public Msg__port__recv_operation_template(final Msg__port__recv_operation_template otherValue) {
copy_template(otherValue);
}

public Msg__port__recv_operation_template(final Msg__port__recv_operation.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Msg__port__recv_operation.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Msg__port__recv_operation_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Msg__port__recv_operation_template assign(final int otherValue) {
if (!Msg__port__recv_operation.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Msg__port__recv_operation.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Msg__port__recv_operation_template assign(final Msg__port__recv_operation.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Msg__port__recv_operation_template assign(final Msg__port__recv_operation_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Msg__port__recv_operation_template assign(final Msg__port__recv_operation otherValue){
if (otherValue.enum_value == Msg__port__recv_operation.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Msg__port__recv_operation to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Msg__port__recv_operation_template assign(final Base_Type otherValue){
if( otherValue instanceof Msg__port__recv_operation ) {
return assign((Msg__port__recv_operation) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation' can not be cast to {1}", otherValue));
}

@Override
public Msg__port__recv_operation_template assign(final Base_Template otherValue){
if( otherValue instanceof Msg__port__recv_operation_template ) {
return assign((Msg__port__recv_operation_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Msg__port__recv_operation.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Msg__port__recv_operation.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Msg__port__recv_operation.");
}
}

// originally match
public boolean match(final Msg__port__recv_operation otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Msg__port__recv_operation otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Msg__port__recv_operation ) {
return match((Msg__port__recv_operation) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Msg__port__recv_operation' can not be cast to {1}", otherValue));
}

public Msg__port__recv_operation valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Msg__port__recv_operation.");
}
return new Msg__port__recv_operation(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Msg__port__recv_operation.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Msg__port__recv_operation_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Msg__port__recv_operation_template());
}
}

public Msg__port__recv_operation_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Msg__port__recv_operation.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Msg__port__recv_operation.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Msg__port__recv_operation.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Msg__port__recv_operation.enum2str(single_value), Msg__port__recv_operation.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Msg__port__recv_operation) {
log_match((Msg__port__recv_operation)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Msg_port_recv.operation.");
}
public void log_match(final Msg__port__recv_operation match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Msg_port_recv.operation.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Msg__port__recv_operation.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Msg_port_recv.operation.", temp));
}
single_value = Msg__port__recv_operation.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Msg__port__recv_operation_template>(size);
for(int i = 0; i < size; i++) {
final Msg__port__recv_operation_template temp = new Msg__port__recv_operation_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Msg_port_recv.operation.");
}
}
}
public static void Msg__port__recv_operation_encoder(final Msg__port__recv_operation input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_operation_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_operation_decoder( final TitanOctetString input_stream, final Msg__port__recv_operation output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Msg_port_recv.operation' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_operation_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__mapped_target__type_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__mapped_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__mapped_target__type_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__mapped_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Misc_remote__component_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_remote__component_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_remote__component_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_remote__component_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParPort_srcPort_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParPort_srcPort_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParPort_srcPort_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParPort_srcPort_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void QualifiedName_module__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(QualifiedName_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger QualifiedName_module__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(QualifiedName_module__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class Verdict extends Base_Type {
public enum enum_type {
v0none (0),
v1pass (1),
v2inconc (2),
v3fail (3),
v4error (4),
UNKNOWN_VALUE(5),
UNBOUND_VALUE(6);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return v0none;
case 1:  return v1pass;
case 2:  return v2inconc;
case 3:  return v3fail;
case 4:  return v4error;
case 5:  return UNKNOWN_VALUE;
case 6:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public Verdict() {
enum_value = enum_type.UNBOUND_VALUE;
}

public Verdict(final Verdict otherValue) {
enum_value = otherValue.enum_value;
}

public Verdict(final Verdict.enum_type otherValue ) {
enum_value = otherValue;
}

public Verdict(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `Verdict' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public Verdict assign(final Verdict otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public Verdict assign(final Base_Type otherValue){
if( otherValue instanceof Verdict ) {
return assign((Verdict) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict' can not be cast to {1}", otherValue));
}

//originally operator=
public Verdict assign(final Verdict.enum_type otherValue){
return assign( new Verdict(otherValue) );
}

//originally operator=
public Verdict assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `Verdict'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final Verdict otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof Verdict) {
return operatorEquals( (Verdict) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Verdict.");
}
}

//originally operator==
public boolean operatorEquals(final Verdict.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final Verdict otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Verdict.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final Verdict.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final Verdict otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final Verdict.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final Verdict otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final Verdict.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final Verdict otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Verdict.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final Verdict otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type Verdict. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type Verdict. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final Verdict.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final Verdict enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("v0none".equals(strPar)) {
return enum_type.v0none;
}
if ("v1pass".equals(strPar)) {
return enum_type.v1pass;
}
if ("v2inconc".equals(strPar)) {
return enum_type.v2inconc;
}
if ("v3fail".equals(strPar)) {
return enum_type.v3fail;
}
if ("v4error".equals(strPar)) {
return enum_type.v4error;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.Verdict.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Verdict.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class Verdict_template extends Base_Template {
// single_value
private Verdict.enum_type single_value;
// value_list part
private ArrayList<Verdict_template> value_list;

private void copy_template(final Verdict_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<Verdict_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final Verdict_template temp = new Verdict_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type Verdict.");
}
}

public Verdict_template() {
}

public Verdict_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public Verdict_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!Verdict.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type Verdict with unknown numeric value "+ otherValue +".");
}
single_value = Verdict.enum_type.getValue(otherValue);
}

public Verdict_template(final Verdict otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == Verdict.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type Verdict. ");
}
single_value = otherValue.enum_value;
}

public Verdict_template(final Verdict_template otherValue) {
copy_template(otherValue);
}

public Verdict_template(final Verdict.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != Verdict.enum_type.UNBOUND_VALUE;
}

//originally operator=
public Verdict_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public Verdict_template assign(final int otherValue) {
if (!Verdict.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type Verdict.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public Verdict_template assign(final Verdict.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public Verdict_template assign(final Verdict_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public Verdict_template assign(final Verdict otherValue){
if (otherValue.enum_value == Verdict.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type Verdict to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public Verdict_template assign(final Base_Type otherValue){
if( otherValue instanceof Verdict ) {
return assign((Verdict) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict' can not be cast to {1}", otherValue));
}

@Override
public Verdict_template assign(final Base_Template otherValue){
if( otherValue instanceof Verdict_template ) {
return assign((Verdict_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final Verdict.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final Verdict.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type Verdict.");
}
}

// originally match
public boolean match(final Verdict otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final Verdict otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof Verdict ) {
return match((Verdict) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `Verdict' can not be cast to {1}", otherValue));
}

public Verdict valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type Verdict.");
}
return new Verdict(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type Verdict.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<Verdict_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new Verdict_template());
}
}

public Verdict_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type Verdict.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type Verdict.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type Verdict.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(Verdict.enum2str(single_value), Verdict.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof Verdict) {
log_match((Verdict)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Verdict.");
}
public void log_match(final Verdict match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.Verdict.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!Verdict.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.Verdict.", temp));
}
single_value = Verdict.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<Verdict_template>(size);
for(int i = 0; i < size; i++) {
final Verdict_template temp = new Verdict_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.Verdict.");
}
}
}
public static void Verdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Verdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Verdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Verdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_tc__loc_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_tc__loc_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_tc__loc_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_tc__loc_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FunctionEvent_choice_random_intseed_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_choice_random_intseed_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_choice_random_intseed_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_choice_random_intseed_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PTC__exit_statuscode_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PTC__exit_statuscode_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PTC__exit_statuscode_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PTC__exit_statuscode_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_statistics_encoder(final StatisticsType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_statistics_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_statistics_decoder( final TitanOctetString input_stream, final StatisticsType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_statistics_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_debugLog_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_debugLog_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_debugLog_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_debugLog_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ParallelPTC_reason extends Base_Type {
public enum enum_type {
init__component__start (0),
init__component__finish (1),
terminating__component (2),
component__shut__down (3),
error__idle__ptc (4),
ptc__created (5),
ptc__created__pid (6),
function__started (7),
function__stopped (8),
function__finished (9),
function__error (10),
ptc__done (11),
ptc__killed (12),
stopping__mtc (13),
ptc__stopped (14),
all__comps__stopped (15),
ptc__was__killed (16),
all__comps__killed (17),
kill__request__frm__mc (18),
mtc__finished (19),
ptc__finished (20),
starting__function (21),
UNKNOWN_VALUE(22),
UNBOUND_VALUE(23);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return init__component__start;
case 1:  return init__component__finish;
case 2:  return terminating__component;
case 3:  return component__shut__down;
case 4:  return error__idle__ptc;
case 5:  return ptc__created;
case 6:  return ptc__created__pid;
case 7:  return function__started;
case 8:  return function__stopped;
case 9:  return function__finished;
case 10:  return function__error;
case 11:  return ptc__done;
case 12:  return ptc__killed;
case 13:  return stopping__mtc;
case 14:  return ptc__stopped;
case 15:  return all__comps__stopped;
case 16:  return ptc__was__killed;
case 17:  return all__comps__killed;
case 18:  return kill__request__frm__mc;
case 19:  return mtc__finished;
case 20:  return ptc__finished;
case 21:  return starting__function;
case 22:  return UNKNOWN_VALUE;
case 23:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public ParallelPTC_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public ParallelPTC_reason(final ParallelPTC_reason otherValue) {
enum_value = otherValue.enum_value;
}

public ParallelPTC_reason(final ParallelPTC_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public ParallelPTC_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ParallelPTC_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public ParallelPTC_reason assign(final ParallelPTC_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public ParallelPTC_reason assign(final Base_Type otherValue){
if( otherValue instanceof ParallelPTC_reason ) {
return assign((ParallelPTC_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public ParallelPTC_reason assign(final ParallelPTC_reason.enum_type otherValue){
return assign( new ParallelPTC_reason(otherValue) );
}

//originally operator=
public ParallelPTC_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ParallelPTC_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final ParallelPTC_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof ParallelPTC_reason) {
return operatorEquals( (ParallelPTC_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelPTC.reason.");
}
}

//originally operator==
public boolean operatorEquals(final ParallelPTC_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final ParallelPTC_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final ParallelPTC_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final ParallelPTC_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final ParallelPTC_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final ParallelPTC_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final ParallelPTC_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final ParallelPTC_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final ParallelPTC_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ParallelPTC_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ParallelPTC_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ParallelPTC_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final ParallelPTC_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final ParallelPTC_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("init__component__start".equals(strPar) || "init_component_start".equals(strPar)) {
return enum_type.init__component__start;
}
if ("init__component__finish".equals(strPar) || "init_component_finish".equals(strPar)) {
return enum_type.init__component__finish;
}
if ("terminating__component".equals(strPar) || "terminating_component".equals(strPar)) {
return enum_type.terminating__component;
}
if ("component__shut__down".equals(strPar) || "component_shut_down".equals(strPar)) {
return enum_type.component__shut__down;
}
if ("error__idle__ptc".equals(strPar) || "error_idle_ptc".equals(strPar)) {
return enum_type.error__idle__ptc;
}
if ("ptc__created".equals(strPar) || "ptc_created".equals(strPar)) {
return enum_type.ptc__created;
}
if ("ptc__created__pid".equals(strPar) || "ptc_created_pid".equals(strPar)) {
return enum_type.ptc__created__pid;
}
if ("function__started".equals(strPar) || "function_started".equals(strPar)) {
return enum_type.function__started;
}
if ("function__stopped".equals(strPar) || "function_stopped".equals(strPar)) {
return enum_type.function__stopped;
}
if ("function__finished".equals(strPar) || "function_finished".equals(strPar)) {
return enum_type.function__finished;
}
if ("function__error".equals(strPar) || "function_error".equals(strPar)) {
return enum_type.function__error;
}
if ("ptc__done".equals(strPar) || "ptc_done".equals(strPar)) {
return enum_type.ptc__done;
}
if ("ptc__killed".equals(strPar) || "ptc_killed".equals(strPar)) {
return enum_type.ptc__killed;
}
if ("stopping__mtc".equals(strPar) || "stopping_mtc".equals(strPar)) {
return enum_type.stopping__mtc;
}
if ("ptc__stopped".equals(strPar) || "ptc_stopped".equals(strPar)) {
return enum_type.ptc__stopped;
}
if ("all__comps__stopped".equals(strPar) || "all_comps_stopped".equals(strPar)) {
return enum_type.all__comps__stopped;
}
if ("ptc__was__killed".equals(strPar) || "ptc_was_killed".equals(strPar)) {
return enum_type.ptc__was__killed;
}
if ("all__comps__killed".equals(strPar) || "all_comps_killed".equals(strPar)) {
return enum_type.all__comps__killed;
}
if ("kill__request__frm__mc".equals(strPar) || "kill_request_frm_mc".equals(strPar)) {
return enum_type.kill__request__frm__mc;
}
if ("mtc__finished".equals(strPar) || "mtc_finished".equals(strPar)) {
return enum_type.mtc__finished;
}
if ("ptc__finished".equals(strPar) || "ptc_finished".equals(strPar)) {
return enum_type.ptc__finished;
}
if ("starting__function".equals(strPar) || "starting_function".equals(strPar)) {
return enum_type.starting__function;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ParallelPTC.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParallelPTC.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class ParallelPTC_reason_template extends Base_Template {
// single_value
private ParallelPTC_reason.enum_type single_value;
// value_list part
private ArrayList<ParallelPTC_reason_template> value_list;

private void copy_template(final ParallelPTC_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ParallelPTC_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final ParallelPTC_reason_template temp = new ParallelPTC_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ParallelPTC_reason.");
}
}

public ParallelPTC_reason_template() {
}

public ParallelPTC_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public ParallelPTC_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!ParallelPTC_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type ParallelPTC_reason with unknown numeric value "+ otherValue +".");
}
single_value = ParallelPTC_reason.enum_type.getValue(otherValue);
}

public ParallelPTC_reason_template(final ParallelPTC_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == ParallelPTC_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type ParallelPTC_reason. ");
}
single_value = otherValue.enum_value;
}

public ParallelPTC_reason_template(final ParallelPTC_reason_template otherValue) {
copy_template(otherValue);
}

public ParallelPTC_reason_template(final ParallelPTC_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != ParallelPTC_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public ParallelPTC_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public ParallelPTC_reason_template assign(final int otherValue) {
if (!ParallelPTC_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ParallelPTC_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public ParallelPTC_reason_template assign(final ParallelPTC_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public ParallelPTC_reason_template assign(final ParallelPTC_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public ParallelPTC_reason_template assign(final ParallelPTC_reason otherValue){
if (otherValue.enum_value == ParallelPTC_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type ParallelPTC_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public ParallelPTC_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof ParallelPTC_reason ) {
return assign((ParallelPTC_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason' can not be cast to {1}", otherValue));
}

@Override
public ParallelPTC_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof ParallelPTC_reason_template ) {
return assign((ParallelPTC_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final ParallelPTC_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final ParallelPTC_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ParallelPTC_reason.");
}
}

// originally match
public boolean match(final ParallelPTC_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final ParallelPTC_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof ParallelPTC_reason ) {
return match((ParallelPTC_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ParallelPTC_reason' can not be cast to {1}", otherValue));
}

public ParallelPTC_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ParallelPTC_reason.");
}
return new ParallelPTC_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type ParallelPTC_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<ParallelPTC_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ParallelPTC_reason_template());
}
}

public ParallelPTC_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type ParallelPTC_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type ParallelPTC_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type ParallelPTC_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(ParallelPTC_reason.enum2str(single_value), ParallelPTC_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ParallelPTC_reason) {
log_match((ParallelPTC_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ParallelPTC.reason.");
}
public void log_match(final ParallelPTC_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ParallelPTC.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!ParallelPTC_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ParallelPTC.reason.", temp));
}
single_value = ParallelPTC_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ParallelPTC_reason_template>(size);
for(int i = 0; i < size; i++) {
final ParallelPTC_reason_template temp = new ParallelPTC_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ParallelPTC.reason.");
}
}
}
public static void ParallelPTC_reason_encoder(final ParallelPTC_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_reason_decoder( final TitanOctetString input_stream, final ParallelPTC_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ParallelPTC.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Categorized_category_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Categorized_category_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Categorized_category_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Categorized_category_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorUnqualified_name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorUnqualified_name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorUnqualified_name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorUnqualified_name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Misc_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Misc_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Misc_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Misc_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TimerGuardType extends Base_Type {
		private final TitanFloat value__; //Float_Type

		public TimerGuardType() {
			value__ = new TitanFloat();
		}

		public TimerGuardType( final TitanFloat aValue__ ) {
			value__ = new TitanFloat( aValue__ );
		}

		public TimerGuardType( final TimerGuardType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TimerGuardType.");
			}
			value__ = new TitanFloat();
			assign( aOtherValue );
		}
		public TimerGuardType assign(final TimerGuardType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TimerGuardType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getValue__().isBound() ) {
					this.value__.assign( aOtherValue.getValue__() );
				} else {
					this.value__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TimerGuardType assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerGuardType ) {
				return assign((TimerGuardType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerGuardType", otherValue));
		}

		public void cleanUp() {
			value__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( value__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !value__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TimerGuardType aOtherValue ) {
			if ( !this.value__.operatorEquals( aOtherValue.value__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TimerGuardType ) {
				return operatorEquals((TimerGuardType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TimerGuardType", otherValue));
		}

		public TitanFloat getValue__() {
			return value__;
		}

		public TitanFloat constGetValue__() {
			return value__;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" value_ := ");
			value__.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (value__.isBound()) {
				value__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			value__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			value__.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TimerGuardType_template extends Base_Template {

	private TitanFloat_template value__; //Float_Type
	//originally value_list/list_value
	List<TimerGuardType_template> list_value;

	public TitanFloat_template getValue__() {
		setSpecific();
		return value__;
	}

	public TitanFloat_template constGetValue__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field value_ of a non-specific template of type @TitanLoggerApi.TimerGuardType.");
		}
		return value__;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			value__ = new TitanFloat_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				value__.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TimerGuardType_template() {
	}

	public TimerGuardType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TimerGuardType_template( final TimerGuardType otherValue ) {
		copyValue(otherValue);
	}

	public TimerGuardType_template( final TimerGuardType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TimerGuardType_template( final Optional<TimerGuardType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TimerGuardType from an unbound optional field.");
		}
	}

	//originally operator=
	public TimerGuardType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TimerGuardType_template assign( final TimerGuardType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TimerGuardType_template assign( final TimerGuardType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TimerGuardType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TimerGuardType) {
				return assign((TimerGuardType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerGuardType' can not be cast to {1}", otherValue));
		}

		@Override
		public TimerGuardType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TimerGuardType_template) {
				return assign((TimerGuardType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TimerGuardType' can not be cast to {1}_template", otherValue));
		}

	public TimerGuardType_template assign( final Optional<TimerGuardType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TimerGuardType.");
		}
		return this;
	}

	private void copyValue(final TimerGuardType other_value) {
		if (other_value.getValue__().isBound()) {
			getValue__().assign(other_value.getValue__());
		} else {
			getValue__().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TimerGuardType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getValue__().get_selection()) {
				getValue__().cleanUp();
			} else {
				getValue__().assign(other_value.getValue__());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TimerGuardType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TimerGuardType_template temp = new TimerGuardType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TimerGuardType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TimerGuardType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TimerGuardType.");
			}
			final TimerGuardType ret_val = new TimerGuardType();
			 if (value__.isBound()) {
				ret_val.value__.assign(value__.valueOf());
			}
			return ret_val;
		}

		public TimerGuardType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TimerGuardType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TimerGuardType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TimerGuardType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TimerGuardType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TimerGuardType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (value__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!value__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TimerGuardType other_value) {
			return match(other_value, false);
		}

		public boolean match(final TimerGuardType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getValue__().isBound()) {
					return false;
				}
				if(!value__.match(other_value.getValue__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TimerGuardType) {
		return match((TimerGuardType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TimerGuardType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TimerGuardType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" value_ := ");
				value__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TimerGuardType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TimerGuardType) {
				log_match((TimerGuardType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TimerGuardType.");
		}

		public void log_match(final TimerGuardType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !value__.match(match_value.constGetValue__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".value_");
							value__.log_match(match_value.constGetValue__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ value_ := ");
				value__.log_match(match_value.constGetValue__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				value__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TimerGuardType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				value__ = new TitanFloat_template();
				value__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TimerGuardType_template>(size);
				for(int i = 0; i < size; i++) {
					final TimerGuardType_template temp = new TimerGuardType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TimerGuardType.");
			}
		}
}
public static void TimerGuardType_encoder(final TimerGuardType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerGuardType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerGuardType_decoder( final TitanOctetString input_stream, final TimerGuardType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerGuardType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerGuardType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_startTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_startTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_startTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_startTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void SetVerdictType_newVerdict_encoder(final Verdict input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(SetVerdictType_newVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger SetVerdictType_newVerdict_decoder( final TitanOctetString input_stream, final Verdict output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Verdict' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(SetVerdictType_newVerdict_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class StartFunction extends Base_Type {
		private final TitanCharString function__name; //CharString_Type
		private final TitanInteger compref; //Integer_Type
		private final StartFunction_parameter__list parameter__list; //SequenceOf_Type

		public StartFunction() {
			function__name = new TitanCharString();
			compref = new TitanInteger();
			parameter__list = new StartFunction_parameter__list();
		}

		public StartFunction( final TitanCharString aFunction__name, final TitanInteger aCompref, final StartFunction_parameter__list aParameter__list ) {
			function__name = new TitanCharString( aFunction__name );
			compref = new TitanInteger( aCompref );
			parameter__list = new StartFunction_parameter__list( aParameter__list );
		}

		public StartFunction( final StartFunction aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.StartFunction.");
			}
			function__name = new TitanCharString();
			compref = new TitanInteger();
			parameter__list = new StartFunction_parameter__list();
			assign( aOtherValue );
		}
		public StartFunction assign(final StartFunction aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.StartFunction");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getFunction__name().isBound() ) {
					this.function__name.assign( aOtherValue.getFunction__name() );
				} else {
					this.function__name.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
				if ( aOtherValue.getParameter__list().isBound() ) {
					this.parameter__list.assign( aOtherValue.getParameter__list() );
				} else {
					this.parameter__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public StartFunction assign(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction ) {
				return assign((StartFunction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StartFunction", otherValue));
		}

		public void cleanUp() {
			function__name.cleanUp();
			compref.cleanUp();
			parameter__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( function__name.isBound() ) { return true; }
			if ( compref.isBound() ) { return true; }
			if ( parameter__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !function__name.isValue() ) { return false; }
			if ( !compref.isValue() ) { return false; }
			if ( !parameter__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final StartFunction aOtherValue ) {
			if ( !this.function__name.operatorEquals( aOtherValue.function__name ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			if ( !this.parameter__list.operatorEquals( aOtherValue.parameter__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction ) {
				return operatorEquals((StartFunction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StartFunction", otherValue));
		}

		public TitanCharString getFunction__name() {
			return function__name;
		}

		public TitanCharString constGetFunction__name() {
			return function__name;
		}

		public TitanInteger getCompref() {
			return compref;
		}

		public TitanInteger constGetCompref() {
			return compref;
		}

		public StartFunction_parameter__list getParameter__list() {
			return parameter__list;
		}

		public StartFunction_parameter__list constGetParameter__list() {
			return parameter__list;
		}

		public TitanInteger sizeOf() {
			int sizeof = 3;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" function_name := ");
			function__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" parameter_list := ");
			parameter__list.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (function__name.isBound()) {
				function__name.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			}
			if (parameter__list.isBound()) {
				parameter__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			function__name.encode_text(text_buf);
			compref.encode_text(text_buf);
			parameter__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			function__name.decode_text(text_buf);
			compref.decode_text(text_buf);
			parameter__list.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class StartFunction_template extends Base_Template {

	private TitanCharString_template function__name; //CharString_Type
	private TitanInteger_template compref; //Integer_Type
	private StartFunction_parameter__list_template parameter__list; //SequenceOf_Type
	//originally value_list/list_value
	List<StartFunction_template> list_value;

	public TitanCharString_template getFunction__name() {
		setSpecific();
		return function__name;
	}

	public TitanCharString_template constGetFunction__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field function_name of a non-specific template of type @TitanLoggerApi.StartFunction.");
		}
		return function__name;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.StartFunction.");
		}
		return compref;
	}

	public StartFunction_parameter__list_template getParameter__list() {
		setSpecific();
		return parameter__list;
	}

	public StartFunction_parameter__list_template constGetParameter__list() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field parameter_list of a non-specific template of type @TitanLoggerApi.StartFunction.");
		}
		return parameter__list;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			function__name = new TitanCharString_template();
			compref = new TitanInteger_template();
			parameter__list = new StartFunction_parameter__list_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				function__name.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_VALUE);
				parameter__list.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public StartFunction_template() {
	}

	public StartFunction_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public StartFunction_template( final StartFunction otherValue ) {
		copyValue(otherValue);
	}

	public StartFunction_template( final StartFunction_template otherValue ) {
		copyTemplate( otherValue );
	}

	public StartFunction_template( final Optional<StartFunction> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.StartFunction from an unbound optional field.");
		}
	}

	//originally operator=
	public StartFunction_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public StartFunction_template assign( final StartFunction other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public StartFunction_template assign( final StartFunction_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public StartFunction_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StartFunction) {
				return assign((StartFunction) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StartFunction' can not be cast to {1}", otherValue));
		}

		@Override
		public StartFunction_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StartFunction_template) {
				return assign((StartFunction_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StartFunction' can not be cast to {1}_template", otherValue));
		}

	public StartFunction_template assign( final Optional<StartFunction> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StartFunction.");
		}
		return this;
	}

	private void copyValue(final StartFunction other_value) {
		if (other_value.getFunction__name().isBound()) {
			getFunction__name().assign(other_value.getFunction__name());
		} else {
			getFunction__name().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			getCompref().assign(other_value.getCompref());
		} else {
			getCompref().cleanUp();
		}
		if (other_value.getParameter__list().isBound()) {
			getParameter__list().assign(other_value.getParameter__list());
		} else {
			getParameter__list().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final StartFunction_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getFunction__name().get_selection()) {
				getFunction__name().cleanUp();
			} else {
				getFunction__name().assign(other_value.getFunction__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getParameter__list().get_selection()) {
				getParameter__list().cleanUp();
			} else {
				getParameter__list().assign(other_value.getParameter__list());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<StartFunction_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final StartFunction_template temp = new StartFunction_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StartFunction.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public StartFunction valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StartFunction.");
			}
			final StartFunction ret_val = new StartFunction();
			 if (function__name.isBound()) {
				ret_val.function__name.assign(function__name.valueOf());
			}
			 if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			 if (parameter__list.isBound()) {
				ret_val.parameter__list.assign(parameter__list.valueOf());
			}
			return ret_val;
		}

		public StartFunction_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StartFunction.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StartFunction.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.StartFunction.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<StartFunction_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new StartFunction_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (function__name.isBound()) {
				return true;
			}
			if (compref.isBound()) {
				return true;
			}
			if (parameter__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!function__name.isValue()) {
				return false;
			}
			if (!compref.isValue()) {
				return false;
			}
			if (!parameter__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final StartFunction other_value) {
			return match(other_value, false);
		}

		public boolean match(final StartFunction other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getFunction__name().isBound()) {
					return false;
				}
				if(!function__name.match(other_value.getFunction__name(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if(!compref.match(other_value.getCompref(), legacy)) {
					return false;
				}
				if(!other_value.getParameter__list().isBound()) {
					return false;
				}
				if(!parameter__list.match(other_value.getParameter__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof StartFunction) {
		return match((StartFunction)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StartFunction.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 3;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StartFunction containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" function_name := ");
				function__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" parameter_list := ");
				parameter__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final StartFunction match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StartFunction) {
				log_match((StartFunction)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StartFunction.");
		}

		public void log_match(final StartFunction match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !function__name.match(match_value.constGetFunction__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".function_name");
							function__name.log_match(match_value.constGetFunction__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !compref.match(match_value.constGetCompref(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".compref");
							compref.log_match(match_value.constGetCompref(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !parameter__list.match(match_value.constGetParameter__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".parameter_list");
							parameter__list.log_match(match_value.constGetParameter__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ function_name := ");
				function__name.log_match(match_value.constGetFunction__name(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str("{ parameter_list := ");
				parameter__list.log_match(match_value.constGetParameter__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				function__name.encode_text(text_buf);
				compref.encode_text(text_buf);
				parameter__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StartFunction.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				function__name = new TitanCharString_template();
				function__name.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				parameter__list = new StartFunction_parameter__list_template();
				parameter__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StartFunction_template>(size);
				for(int i = 0; i < size; i++) {
					final StartFunction_template temp = new StartFunction_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.StartFunction.");
			}
		}
}
public static void StartFunction_encoder(final StartFunction input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StartFunction_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StartFunction_decoder( final TitanOctetString input_stream, final StartFunction output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StartFunction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StartFunction_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_failPercent_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_failPercent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_failPercent_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_failPercent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ExecutorUnqualified extends Base_Type {
		private final ExecutorUnqualified_reason reason; //TTCN3_Enumerated_Type
		private final TitanCharString name; //CharString_Type
		private final TitanCharString addr; //CharString_Type
		private final TitanInteger port__; //Integer_Type

		public ExecutorUnqualified() {
			reason = new ExecutorUnqualified_reason();
			name = new TitanCharString();
			addr = new TitanCharString();
			port__ = new TitanInteger();
		}

		public ExecutorUnqualified( final ExecutorUnqualified_reason aReason, final TitanCharString aName, final TitanCharString aAddr, final TitanInteger aPort__ ) {
			reason = new ExecutorUnqualified_reason( aReason );
			name = new TitanCharString( aName );
			addr = new TitanCharString( aAddr );
			port__ = new TitanInteger( aPort__ );
		}

		public ExecutorUnqualified( final ExecutorUnqualified aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			reason = new ExecutorUnqualified_reason();
			name = new TitanCharString();
			addr = new TitanCharString();
			port__ = new TitanInteger();
			assign( aOtherValue );
		}
		public ExecutorUnqualified assign(final ExecutorUnqualified aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorUnqualified");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getName().isBound() ) {
					this.name.assign( aOtherValue.getName() );
				} else {
					this.name.cleanUp();
				}
				if ( aOtherValue.getAddr().isBound() ) {
					this.addr.assign( aOtherValue.getAddr() );
				} else {
					this.addr.cleanUp();
				}
				if ( aOtherValue.getPort__().isBound() ) {
					this.port__.assign( aOtherValue.getPort__() );
				} else {
					this.port__.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorUnqualified assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorUnqualified ) {
				return assign((ExecutorUnqualified) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorUnqualified", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			name.cleanUp();
			addr.cleanUp();
			port__.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( name.isBound() ) { return true; }
			if ( addr.isBound() ) { return true; }
			if ( port__.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !name.isValue() ) { return false; }
			if ( !addr.isValue() ) { return false; }
			if ( !port__.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorUnqualified aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.name.operatorEquals( aOtherValue.name ) ) { return false; }
			if ( !this.addr.operatorEquals( aOtherValue.addr ) ) { return false; }
			if ( !this.port__.operatorEquals( aOtherValue.port__ ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorUnqualified ) {
				return operatorEquals((ExecutorUnqualified) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorUnqualified", otherValue));
		}

		public ExecutorUnqualified_reason getReason() {
			return reason;
		}

		public ExecutorUnqualified_reason constGetReason() {
			return reason;
		}

		public TitanCharString getName() {
			return name;
		}

		public TitanCharString constGetName() {
			return name;
		}

		public TitanCharString getAddr() {
			return addr;
		}

		public TitanCharString constGetAddr() {
			return addr;
		}

		public TitanInteger getPort__() {
			return port__;
		}

		public TitanInteger constGetPort__() {
			return port__;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" name := ");
			name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" addr := ");
			addr.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_ := ");
			port__.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (name.isBound()) {
				name.set_implicit_omit();
			}
			if (addr.isBound()) {
				addr.set_implicit_omit();
			}
			if (port__.isBound()) {
				port__.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			name.encode_text(text_buf);
			addr.encode_text(text_buf);
			port__.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			name.decode_text(text_buf);
			addr.decode_text(text_buf);
			port__.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ExecutorUnqualified_template extends Base_Template {

	private ExecutorUnqualified_reason_template reason; //TTCN3_Enumerated_Type
	private TitanCharString_template name; //CharString_Type
	private TitanCharString_template addr; //CharString_Type
	private TitanInteger_template port__; //Integer_Type
	//originally value_list/list_value
	List<ExecutorUnqualified_template> list_value;

	public ExecutorUnqualified_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public ExecutorUnqualified_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
		}
		return reason;
	}

	public TitanCharString_template getName() {
		setSpecific();
		return name;
	}

	public TitanCharString_template constGetName() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field name of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
		}
		return name;
	}

	public TitanCharString_template getAddr() {
		setSpecific();
		return addr;
	}

	public TitanCharString_template constGetAddr() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field addr of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
		}
		return addr;
	}

	public TitanInteger_template getPort__() {
		setSpecific();
		return port__;
	}

	public TitanInteger_template constGetPort__() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_ of a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
		}
		return port__;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new ExecutorUnqualified_reason_template();
			name = new TitanCharString_template();
			addr = new TitanCharString_template();
			port__ = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				name.assign(template_sel.ANY_VALUE);
				addr.assign(template_sel.ANY_VALUE);
				port__.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ExecutorUnqualified_template() {
	}

	public ExecutorUnqualified_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ExecutorUnqualified_template( final ExecutorUnqualified otherValue ) {
		copyValue(otherValue);
	}

	public ExecutorUnqualified_template( final ExecutorUnqualified_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ExecutorUnqualified_template( final Optional<ExecutorUnqualified> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorUnqualified from an unbound optional field.");
		}
	}

	//originally operator=
	public ExecutorUnqualified_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ExecutorUnqualified_template assign( final ExecutorUnqualified other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ExecutorUnqualified_template assign( final ExecutorUnqualified_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ExecutorUnqualified_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorUnqualified) {
				return assign((ExecutorUnqualified) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorUnqualified_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorUnqualified_template) {
				return assign((ExecutorUnqualified_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorUnqualified' can not be cast to {1}_template", otherValue));
		}

	public ExecutorUnqualified_template assign( final Optional<ExecutorUnqualified> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorUnqualified.");
		}
		return this;
	}

	private void copyValue(final ExecutorUnqualified other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getName().isBound()) {
			getName().assign(other_value.getName());
		} else {
			getName().cleanUp();
		}
		if (other_value.getAddr().isBound()) {
			getAddr().assign(other_value.getAddr());
		} else {
			getAddr().cleanUp();
		}
		if (other_value.getPort__().isBound()) {
			getPort__().assign(other_value.getPort__());
		} else {
			getPort__().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ExecutorUnqualified_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getName().get_selection()) {
				getName().cleanUp();
			} else {
				getName().assign(other_value.getName());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getAddr().get_selection()) {
				getAddr().cleanUp();
			} else {
				getAddr().assign(other_value.getAddr());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__().get_selection()) {
				getPort__().cleanUp();
			} else {
				getPort__().assign(other_value.getPort__());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ExecutorUnqualified_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ExecutorUnqualified_template temp = new ExecutorUnqualified_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorUnqualified.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorUnqualified valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			final ExecutorUnqualified ret_val = new ExecutorUnqualified();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			 if (name.isBound()) {
				ret_val.name.assign(name.valueOf());
			}
			 if (addr.isBound()) {
				ret_val.addr.assign(addr.valueOf());
			}
			 if (port__.isBound()) {
				ret_val.port__.assign(port__.valueOf());
			}
			return ret_val;
		}

		public ExecutorUnqualified_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorUnqualified_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorUnqualified_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (name.isBound()) {
				return true;
			}
			if (addr.isBound()) {
				return true;
			}
			if (port__.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!name.isValue()) {
				return false;
			}
			if (!addr.isValue()) {
				return false;
			}
			if (!port__.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorUnqualified other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorUnqualified other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getName().isBound()) {
					return false;
				}
				if(!name.match(other_value.getName(), legacy)) {
					return false;
				}
				if(!other_value.getAddr().isBound()) {
					return false;
				}
				if(!addr.match(other_value.getAddr(), legacy)) {
					return false;
				}
				if(!other_value.getPort__().isBound()) {
					return false;
				}
				if(!port__.match(other_value.getPort__(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutorUnqualified) {
		return match((ExecutorUnqualified)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorUnqualified.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorUnqualified containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" name := ");
				name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" addr := ");
				addr.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_ := ");
				port__.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorUnqualified match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorUnqualified) {
				log_match((ExecutorUnqualified)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorUnqualified.");
		}

		public void log_match(final ExecutorUnqualified match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !name.match(match_value.constGetName(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".name");
							name.log_match(match_value.constGetName(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !addr.match(match_value.constGetAddr(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".addr");
							addr.log_match(match_value.constGetAddr(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__.match(match_value.constGetPort__(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_");
							port__.log_match(match_value.constGetPort__(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ name := ");
				name.log_match(match_value.constGetName(), legacy);
				TTCN_Logger.log_event_str("{ addr := ");
				addr.log_match(match_value.constGetAddr(), legacy);
				TTCN_Logger.log_event_str("{ port_ := ");
				port__.log_match(match_value.constGetPort__(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				name.encode_text(text_buf);
				addr.encode_text(text_buf);
				port__.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorUnqualified_reason_template();
				reason.decode_text(text_buf);
				name = new TitanCharString_template();
				name.decode_text(text_buf);
				addr = new TitanCharString_template();
				addr.decode_text(text_buf);
				port__ = new TitanInteger_template();
				port__.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorUnqualified_template>(size);
				for(int i = 0; i < size; i++) {
					final ExecutorUnqualified_template temp = new ExecutorUnqualified_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorUnqualified.");
			}
		}
}
public static void ExecutorUnqualified_encoder(final ExecutorUnqualified input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorUnqualified_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorUnqualified_decoder( final TitanOctetString input_stream, final ExecutorUnqualified output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorUnqualified' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorUnqualified_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StartFunction_function__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StartFunction_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StartFunction_function__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StartFunction_function__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_timerEvent_encoder(final TimerEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_timerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_timerEvent_decoder( final TitanOctetString input_stream, final TimerEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_timerEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TitanLog_sequence__list_0_entityId_encoder(final ComponentIDType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLog_sequence__list_0_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLog_sequence__list_0_entityId_decoder( final TitanOctetString input_stream, final ComponentIDType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ComponentIDType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLog_sequence__list_0_entityId_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class DefaultEnd extends Base_Type {
public enum enum_type {
break__ (0),
finish (1),
repeat__ (2),
UNKNOWN_VALUE(3),
UNBOUND_VALUE(4);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return break__;
case 1:  return finish;
case 2:  return repeat__;
case 3:  return UNKNOWN_VALUE;
case 4:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public DefaultEnd() {
enum_value = enum_type.UNBOUND_VALUE;
}

public DefaultEnd(final DefaultEnd otherValue) {
enum_value = otherValue.enum_value;
}

public DefaultEnd(final DefaultEnd.enum_type otherValue ) {
enum_value = otherValue;
}

public DefaultEnd(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `DefaultEnd' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public DefaultEnd assign(final DefaultEnd otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public DefaultEnd assign(final Base_Type otherValue){
if( otherValue instanceof DefaultEnd ) {
return assign((DefaultEnd) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd' can not be cast to {1}", otherValue));
}

//originally operator=
public DefaultEnd assign(final DefaultEnd.enum_type otherValue){
return assign( new DefaultEnd(otherValue) );
}

//originally operator=
public DefaultEnd assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `DefaultEnd'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final DefaultEnd otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof DefaultEnd) {
return operatorEquals( (DefaultEnd) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEnd.");
}
}

//originally operator==
public boolean operatorEquals(final DefaultEnd.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final DefaultEnd otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final DefaultEnd.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final DefaultEnd.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final DefaultEnd otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final DefaultEnd.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final DefaultEnd otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final DefaultEnd.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final DefaultEnd otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final DefaultEnd.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final DefaultEnd otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type DefaultEnd. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final DefaultEnd.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final DefaultEnd enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("break__".equals(strPar) || "break_".equals(strPar)) {
return enum_type.break__;
}
if ("finish".equals(strPar)) {
return enum_type.finish;
}
if ("repeat__".equals(strPar) || "repeat_".equals(strPar)) {
return enum_type.repeat__;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.DefaultEnd.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.DefaultEnd.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class DefaultEnd_template extends Base_Template {
// single_value
private DefaultEnd.enum_type single_value;
// value_list part
private ArrayList<DefaultEnd_template> value_list;

private void copy_template(final DefaultEnd_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<DefaultEnd_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final DefaultEnd_template temp = new DefaultEnd_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type DefaultEnd.");
}
}

public DefaultEnd_template() {
}

public DefaultEnd_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public DefaultEnd_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!DefaultEnd.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type DefaultEnd with unknown numeric value "+ otherValue +".");
}
single_value = DefaultEnd.enum_type.getValue(otherValue);
}

public DefaultEnd_template(final DefaultEnd otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == DefaultEnd.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type DefaultEnd. ");
}
single_value = otherValue.enum_value;
}

public DefaultEnd_template(final DefaultEnd_template otherValue) {
copy_template(otherValue);
}

public DefaultEnd_template(final DefaultEnd.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != DefaultEnd.enum_type.UNBOUND_VALUE;
}

//originally operator=
public DefaultEnd_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public DefaultEnd_template assign(final int otherValue) {
if (!DefaultEnd.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type DefaultEnd.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public DefaultEnd_template assign(final DefaultEnd.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public DefaultEnd_template assign(final DefaultEnd_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public DefaultEnd_template assign(final DefaultEnd otherValue){
if (otherValue.enum_value == DefaultEnd.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type DefaultEnd to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public DefaultEnd_template assign(final Base_Type otherValue){
if( otherValue instanceof DefaultEnd ) {
return assign((DefaultEnd) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd' can not be cast to {1}", otherValue));
}

@Override
public DefaultEnd_template assign(final Base_Template otherValue){
if( otherValue instanceof DefaultEnd_template ) {
return assign((DefaultEnd_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final DefaultEnd.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final DefaultEnd.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type DefaultEnd.");
}
}

// originally match
public boolean match(final DefaultEnd otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final DefaultEnd otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof DefaultEnd ) {
return match((DefaultEnd) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `DefaultEnd' can not be cast to {1}", otherValue));
}

public DefaultEnd valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type DefaultEnd.");
}
return new DefaultEnd(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type DefaultEnd.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<DefaultEnd_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new DefaultEnd_template());
}
}

public DefaultEnd_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type DefaultEnd.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type DefaultEnd.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type DefaultEnd.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(DefaultEnd.enum2str(single_value), DefaultEnd.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof DefaultEnd) {
log_match((DefaultEnd)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.DefaultEnd.");
}
public void log_match(final DefaultEnd match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.DefaultEnd.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!DefaultEnd.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.DefaultEnd.", temp));
}
single_value = DefaultEnd.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<DefaultEnd_template>(size);
for(int i = 0; i < size; i++) {
final DefaultEnd_template temp = new DefaultEnd_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.DefaultEnd.");
}
}
}
public static void DefaultEnd_encoder(final DefaultEnd input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultEnd_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultEnd_decoder( final TitanOctetString input_stream, final DefaultEnd output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultEnd' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultEnd_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Queue_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Categorized extends Base_Type {
		private final TitanInteger category; //Integer_Type
		private final TitanCharString text; //CharString_Type

		public Categorized() {
			category = new TitanInteger();
			text = new TitanCharString();
		}

		public Categorized( final TitanInteger aCategory, final TitanCharString aText ) {
			category = new TitanInteger( aCategory );
			text = new TitanCharString( aText );
		}

		public Categorized( final Categorized aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Categorized.");
			}
			category = new TitanInteger();
			text = new TitanCharString();
			assign( aOtherValue );
		}
		public Categorized assign(final Categorized aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Categorized");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getCategory().isBound() ) {
					this.category.assign( aOtherValue.getCategory() );
				} else {
					this.category.cleanUp();
				}
				if ( aOtherValue.getText().isBound() ) {
					this.text.assign( aOtherValue.getText() );
				} else {
					this.text.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Categorized assign(final Base_Type otherValue) {
			if (otherValue instanceof Categorized ) {
				return assign((Categorized) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Categorized", otherValue));
		}

		public void cleanUp() {
			category.cleanUp();
			text.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( category.isBound() ) { return true; }
			if ( text.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !category.isValue() ) { return false; }
			if ( !text.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Categorized aOtherValue ) {
			if ( !this.category.operatorEquals( aOtherValue.category ) ) { return false; }
			if ( !this.text.operatorEquals( aOtherValue.text ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Categorized ) {
				return operatorEquals((Categorized) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Categorized", otherValue));
		}

		public TitanInteger getCategory() {
			return category;
		}

		public TitanInteger constGetCategory() {
			return category;
		}

		public TitanCharString getText() {
			return text;
		}

		public TitanCharString constGetText() {
			return text;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" category := ");
			category.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" text := ");
			text.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (category.isBound()) {
				category.set_implicit_omit();
			}
			if (text.isBound()) {
				text.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			category.encode_text(text_buf);
			text.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			category.decode_text(text_buf);
			text.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Categorized_template extends Base_Template {

	private TitanInteger_template category; //Integer_Type
	private TitanCharString_template text; //CharString_Type
	//originally value_list/list_value
	List<Categorized_template> list_value;

	public TitanInteger_template getCategory() {
		setSpecific();
		return category;
	}

	public TitanInteger_template constGetCategory() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field category of a non-specific template of type @TitanLoggerApi.Categorized.");
		}
		return category;
	}

	public TitanCharString_template getText() {
		setSpecific();
		return text;
	}

	public TitanCharString_template constGetText() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field text of a non-specific template of type @TitanLoggerApi.Categorized.");
		}
		return text;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			category = new TitanInteger_template();
			text = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				category.assign(template_sel.ANY_VALUE);
				text.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Categorized_template() {
	}

	public Categorized_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Categorized_template( final Categorized otherValue ) {
		copyValue(otherValue);
	}

	public Categorized_template( final Categorized_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Categorized_template( final Optional<Categorized> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Categorized from an unbound optional field.");
		}
	}

	//originally operator=
	public Categorized_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Categorized_template assign( final Categorized other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Categorized_template assign( final Categorized_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Categorized_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Categorized) {
				return assign((Categorized) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Categorized' can not be cast to {1}", otherValue));
		}

		@Override
		public Categorized_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Categorized_template) {
				return assign((Categorized_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Categorized' can not be cast to {1}_template", otherValue));
		}

	public Categorized_template assign( final Optional<Categorized> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Categorized.");
		}
		return this;
	}

	private void copyValue(final Categorized other_value) {
		if (other_value.getCategory().isBound()) {
			getCategory().assign(other_value.getCategory());
		} else {
			getCategory().cleanUp();
		}
		if (other_value.getText().isBound()) {
			getText().assign(other_value.getText());
		} else {
			getText().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Categorized_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCategory().get_selection()) {
				getCategory().cleanUp();
			} else {
				getCategory().assign(other_value.getCategory());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getText().get_selection()) {
				getText().cleanUp();
			} else {
				getText().assign(other_value.getText());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Categorized_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Categorized_template temp = new Categorized_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Categorized.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Categorized valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Categorized.");
			}
			final Categorized ret_val = new Categorized();
			 if (category.isBound()) {
				ret_val.category.assign(category.valueOf());
			}
			 if (text.isBound()) {
				ret_val.text.assign(text.valueOf());
			}
			return ret_val;
		}

		public Categorized_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Categorized.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Categorized.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Categorized.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Categorized_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Categorized_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (category.isBound()) {
				return true;
			}
			if (text.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!category.isValue()) {
				return false;
			}
			if (!text.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Categorized other_value) {
			return match(other_value, false);
		}

		public boolean match(final Categorized other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getCategory().isBound()) {
					return false;
				}
				if(!category.match(other_value.getCategory(), legacy)) {
					return false;
				}
				if(!other_value.getText().isBound()) {
					return false;
				}
				if(!text.match(other_value.getText(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Categorized.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Categorized) {
		return match((Categorized)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Categorized.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Categorized containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Categorized.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" category := ");
				category.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" text := ");
				text.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Categorized match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Categorized) {
				log_match((Categorized)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Categorized.");
		}

		public void log_match(final Categorized match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !category.match(match_value.constGetCategory(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".category");
							category.log_match(match_value.constGetCategory(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !text.match(match_value.constGetText(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".text");
							text.log_match(match_value.constGetText(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ category := ");
				category.log_match(match_value.constGetCategory(), legacy);
				TTCN_Logger.log_event_str("{ text := ");
				text.log_match(match_value.constGetText(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				category.encode_text(text_buf);
				text.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Categorized.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				category = new TitanInteger_template();
				category.decode_text(text_buf);
				text = new TitanCharString_template();
				text.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Categorized_template>(size);
				for(int i = 0; i < size; i++) {
					final Categorized_template temp = new Categorized_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Categorized.");
			}
		}
}
public static void Categorized_encoder(final Categorized input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Categorized_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Categorized_decoder( final TitanOctetString input_stream, final Categorized output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Categorized' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Categorized_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Port__Queue_address___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Port__Queue_address___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Port__Queue_address___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Port__Queue_address___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ExecutorEvent_choice_extcommandSuccess_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorEvent_choice_extcommandSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorEvent_choice_extcommandSuccess_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorEvent_choice_extcommandSuccess_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class TitanLog_sequence__list extends Base_Type {

	private List<TitanLog_sequence__list_0> valueElements;

	public TitanLog_sequence__list() {
	}

	public TitanLog_sequence__list( final TitanLog_sequence__list otherValue ) {
		otherValue.mustBound("Copying an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		valueElements = copyList( otherValue.valueElements );
	}

	public TitanLog_sequence__list(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanLog_sequence__list_0>();
	}

	private static final List<TitanLog_sequence__list_0> copyList( final List<TitanLog_sequence__list_0> srcList ) {
		if ( srcList == null ) {
			return null;
		}

		final List<TitanLog_sequence__list_0> newList = new ArrayList<TitanLog_sequence__list_0>( srcList.size() );
		for (final TitanLog_sequence__list_0 srcElem : srcList) {
			final TitanLog_sequence__list_0 newElem = getUnboundElem();
			if (srcElem.isBound()) {
				newElem.assign( srcElem );
			}
			newList.add( ( newElem ) );
		}
		return newList;
	}

	@Override
	public boolean isPresent() {
		return isBound();
	}

	@Override
	public boolean isBound() {
		return valueElements != null;
	}

	public void mustBound( final String aErrorMessage ) {
		if ( !isBound() ) {
			throw new TtcnError( aErrorMessage );
		}
	}

	@Override
	public boolean isValue() {
		if (valueElements == null) {
			return false;
		}
		for (int i=0; i < valueElements.size(); i++) {
			final TitanLog_sequence__list_0 elem = valueElements.get(i);
			if (elem == null || !elem.isValue()) {
				return false;
			}
		}
		return true;
	}


	@Override
	public boolean operatorEquals(final Base_Type otherValue) {
		if (otherValue instanceof TitanLog_sequence__list) {
			return operatorEquals((TitanLog_sequence__list)otherValue);
		}
		throw new TtcnError("Internal Error: The left operand of comparison is not of type TitanLog_sequence__list.");
	}

	//originally operator==
	public boolean operatorEquals( final TitanLog_sequence__list otherValue ) {
		mustBound("The left operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		otherValue.mustBound("The right operand of comparison is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");

		final int size = valueElements.size();
		if ( size != otherValue.valueElements.size() ) {
			return false;
		}

		for ( int i = 0; i < size; i++ ) {
			final TitanLog_sequence__list_0 leftElem = valueElements.get( i );
			final TitanLog_sequence__list_0 rightElem = otherValue.valueElements.get( i );
			if (leftElem.isBound()) {
				if (rightElem.isBound()) {
					if ( !leftElem.operatorEquals( rightElem ) ) {
						return false;
					}
				} else {
					return false;
				}
			} else if (rightElem.isBound()) {
				return false;
			}
		}

		return true;
	}

	@Override
	public TitanLog_sequence__list assign(final Base_Type otherValue) {
	if (otherValue instanceof TitanLog_sequence__list) {
		return assign((TitanLog_sequence__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list.");
	}

	//originally operator=
	public TitanLog_sequence__list assign( final TitanLog_sequence__list aOtherValue ) {
		aOtherValue.mustBound( "Assigning an unbound value of type @TitanLoggerApi.TitanLog.sequence_list." );

		valueElements = copyList( aOtherValue.valueElements );
		return this;
	}

	public TitanLog_sequence__list assign(final TitanNull_Type nullValue) {
		valueElements = new ArrayList<TitanLog_sequence__list_0>();
		return this;
	}

	//originally operator+
	public TitanLog_sequence__list concatenate(final TitanLog_sequence__list other_value) {
		if (valueElements == null || other_value.valueElements == null) {
			throw new TtcnError("Unbound operand of @TitanLoggerApi.TitanLog.sequence_list concatenation.");
		}
		final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i < valueElements.size(); i++) {
			final TitanLog_sequence__list_0 elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		for (int i = 0; i < other_value.valueElements.size(); i++) {
			final TitanLog_sequence__list_0 elem = other_value.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		return ret_val;
	}

	public TitanLog_sequence__list concatenate(final TitanNull_Type nullValue) {
		return new TitanLog_sequence__list(this);
	}

	//originally operator<<=
	public TitanLog_sequence__list rotateLeft(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate left operator.");
		return rotateLeft(rotate_count.getInt());
	}

	//originally operator<<=
	public TitanLog_sequence__list rotateLeft(final int rotate_count) {
		return rotateRight(-rotate_count);
	}

	//originally operator>>=
	public TitanLog_sequence__list rotateRight(final TitanInteger rotate_count) {
		rotate_count.mustBound("Unbound integer operand of rotate right operator.");
		return rotateRight(rotate_count.getInt());
	}

	//originally operator>>=
	public TitanLog_sequence__list rotateRight(final int rotate_count) {
		if (valueElements == null) {
			throw new TtcnError("Performing rotation operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		final int size = valueElements.size();
		if (size == 0) {
			return new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
		}
		int rc;
		if (rotate_count >= 0) {
			rc = rotate_count % size;
		} else {
			rc = size - ((-rotate_count) % size);
		}
		if (rc == 0) {
			return new TitanLog_sequence__list(this);
		}
		final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
		for (int i = size - rc; i < size; i++) {
			final TitanLog_sequence__list_0 elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		for (int i = 0; i < size - rc; i++) {
			final TitanLog_sequence__list_0 elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		return ret_val;
	}

	//originally clean_up
	public void cleanUp() {
		valueElements = null;
	}

	//originally get_at(int)
	public TitanLog_sequence__list_0 getAt( final int index_value ) {
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list using a negative index: "+index_value+".");
		}

		if (valueElements == null || index_value >= valueElements.size() ) {
			//increase list size
			setSize(index_value + 1);
		}

		if ( valueElements.get( index_value ) == null ) {
			final TitanLog_sequence__list_0 newElem = getUnboundElem();
			valueElements.set( index_value, newElem );
		}
		return valueElements.get( index_value );
	}

	//originally get_at(const INTEGER&)
	public TitanLog_sequence__list_0 getAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list." );
		return getAt( index_value.getInt() );
	}

	//originally get_at(int) const
	public TitanLog_sequence__list_0 constGetAt( final int index_value ) {
		if ( !isBound() ) {
			throw new TtcnError( "Accessing an element in an unbound value of type @TitanLoggerApi.TitanLog.sequence_list." );
		}
		if (index_value < 0) {
			throw new TtcnError( "Accessing an element of type @TitanLoggerApi.TitanLog.sequence_list using a negative index: "+index_value+".");
		}
		final int nofElements = n_elem().getInt();
		if ( index_value >= nofElements ) {
			throw new TtcnError( "Index overflow in a value of type @TitanLoggerApi.TitanLog.sequence_list: The index is "+index_value+", but the value has only "+nofElements+" elements." );
		}

		final TitanLog_sequence__list_0 elem = valueElements.get( index_value );
		return ( elem != null ) ? elem : getUnboundElem();
	}

	//originally get_at(const INTEGER&) const
	public TitanLog_sequence__list_0 constGetAt(final TitanInteger index_value) {
		index_value.mustBound( "Using an unbound integer value for indexing a value of type @TitanLoggerApi.TitanLog.sequence_list." );
		return constGetAt( index_value.getInt() );
	}

	public TitanInteger sizeOf() {
		mustBound("Performing sizeof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		return new TitanInteger(valueElements.size());
	}

	public TitanInteger n_elem() {
		return sizeOf();
	}

	public TitanInteger lengthOf() {
		mustBound("Performing lengthof operation on an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		for ( int i = valueElements.size() - 1; i >= 0; i-- ) {
			final TitanLog_sequence__list_0 elem = valueElements.get( i );
			if ( elem != null && elem.isBound() ) {
				return new TitanInteger(i + 1);
			}
		}
		return new TitanInteger(0);
	}

	public void setSize(final int newSize) {
		if (newSize < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a value of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		if ( valueElements == null ) {
			valueElements = new ArrayList<TitanLog_sequence__list_0>();
		}
		if (newSize > valueElements.size()) {
			for ( int i = valueElements.size(); i < newSize; i++ ) {
				valueElements.add( new TitanLog_sequence__list_0() );
			}
		} else if (newSize < valueElements.size()) {
			while(valueElements.size() > newSize) {
				valueElements.remove(valueElements.size()-1);
			}
		}
	}

	private static TitanLog_sequence__list_0 getUnboundElem() {
		return new TitanLog_sequence__list_0();
	}
/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */

	@Override
	public String toString() {
		if (!isBound()) {
			return "<unbound>";
		}
		final StringBuilder sb = new StringBuilder();
		sb.append('{');
		final int size = ( valueElements == null ) ? 0 : valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				sb.append(',');
			}
			sb.append(valueElements.get(i).toString());
		}
		sb.append('}');
		return sb.toString();
	}

	public TitanLog_sequence__list substr(final int index, final int returncount) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of substr() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		AdditionalFunctions.check_substr_arguments(valueElements.size(), index, returncount, "@TitanLoggerApi.TitanLog.sequence_list","element");
		final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
		for (int i=0; i<returncount; i++) {
			if (valueElements.get(i+index) != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(valueElements.get(i+index)));
			}
		}
		return ret_val;
	}

	public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list repl) {
		if (valueElements == null) {
			throw new TtcnError("The first argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		if (repl.valueElements == null) {
			throw new TtcnError("The fourth argument of replace() is an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		AdditionalFunctions.check_replace_arguments(valueElements.size(), index, len, "@TitanLoggerApi.TitanLog.sequence_list","element");
		final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
		for (int i = 0; i < index; i++) {
			final TitanLog_sequence__list_0 elem = valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		for (int i = 0; i < repl.valueElements.size(); i++) {
			final TitanLog_sequence__list_0 elem = repl.valueElements.get(i);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		for (int i = 0; i < valueElements.size() - index - len; i++) {
			final TitanLog_sequence__list_0 elem = valueElements.get(index + i + len);
			if (elem != null) {
				ret_val.valueElements.add(new TitanLog_sequence__list_0(elem));
			}
		}
		return ret_val;
	}

	public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len, repl.valueOf());
	}

	public TitanLog_sequence__list replace(final int index, final TitanInteger len, final TitanLog_sequence__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index, len.getInt(), repl.valueOf());
	}

	public TitanLog_sequence__list replace(final TitanInteger index, final int len, final TitanLog_sequence__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len, repl.valueOf());
	}

	public TitanLog_sequence__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_template repl) {
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return replace(index.getInt(), len.getInt(), repl.valueOf());
	}
	public void log() {
		if (valueElements == null) {
			TTCN_Logger.log_event_unbound();
			return;
		}
		TTCN_Logger.log_event_str("{ ");
		final int size = valueElements.size();
		for (int i = 0; i < size; i++ ) {
			if ( i > 0 ) {
				TTCN_Logger.log_event_str(", ");
			}
		valueElements.get(i).log();
		}
		TTCN_Logger.log_event_str(" }");
	}
		@Override
		public void set_implicit_omit() {
			if(valueElements == null) {
				return;
			}
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			mustBound("Text encoder: Encoding an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.");
			text_buf.push_int(valueElements.size());
			for (int i = 0; i < valueElements.size(); i++) {
				valueElements.get(i).encode_text(text_buf);
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			final int temp = text_buf.pull_int().getInt();
			valueElements = new ArrayList<TitanLog_sequence__list_0>(temp);
			for (int i = 0; i < temp; i++) {
				final TitanLog_sequence__list_0 temp2 = new TitanLog_sequence__list_0();
				temp2.decode_text(text_buf);
				valueElements.add(temp2);
			}
		}

		@Override
		public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
				final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
				RAW_encode(p_td, root);
				root.put_to_buf(p_buf);
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
			}
		}

		@Override
		public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
			switch (p_coding) {
			case CT_RAW: {
				final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
				if (p_td.raw == null) {
					TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
				}
				raw_order_t order;
				switch (p_td.raw.top_bit_order) {
				case TOP_BIT_LEFT:
					order = raw_order_t.ORDER_LSB;
					break;
				case TOP_BIT_RIGHT:
				default:
					order = raw_order_t.ORDER_MSB;
					break;
				}
				final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
				if (rawr < 0) {
					final error_type temp = error_type.values()[-rawr];
					switch (temp) {
					case ET_INCOMPL_MSG:
					case ET_LEN_ERR:
						TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					case ET_UNBOUND:
					default:
						TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
						break;
					}
				}
				errorContext.leaveContext();
				break;
			}
			default:
				throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
			}
		}

}
public static class TitanLog_sequence__list_template extends Record_Of_Template {

	//originally single_value/value_elements
	List<TitanLog_sequence__list_0_template> value_elements;

	//originally value_list/list_value
	List<TitanLog_sequence__list_template> list_value;

	private final match_function_t match_function_specific = new match_function_t() {
		@Override
		public boolean match(final Base_Type value_ptr, final int value_index, final Restricted_Length_Template template_ptr, final int template_index, final boolean legacy) {
			return match_index((TitanLog_sequence__list)value_ptr, value_index, (TitanLog_sequence__list_template)template_ptr, template_index, legacy);
		}
	};

	public TitanLog_sequence__list_template() {
	}

	public TitanLog_sequence__list_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanLog_sequence__list_template( final TitanLog_sequence__list otherValue ) {
		copy_value( otherValue );
	}

	public TitanLog_sequence__list_template( final TitanLog_sequence__list_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanLog_sequence__list_template( final Optional<TitanLog_sequence__list> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog.sequence_list from an unbound optional field.");
		}
	}

	public TitanLog_sequence__list_template( final TitanNull_Type nullValue ) {
		super( template_sel.SPECIFIC_VALUE );
		value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
	}

	private void copy_value(final TitanLog_sequence__list other_value) {
		if (!other_value.isBound()) {
			throw new TtcnError("Initialization of a template of type @TitanLoggerApi.TitanLog.sequence_list with an unbound value.");
		}
		value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
		final int otherSize = other_value.valueElements.size();
		for (int elem_count = 0; elem_count < otherSize; elem_count++) {
			if (other_value.constGetAt(elem_count).isBound()) {
				value_elements.add( new TitanLog_sequence__list_0_template(other_value.constGetAt(elem_count)) );
			} else {
				value_elements.add( new TitanLog_sequence__list_0_template() );
			}
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanLog_sequence__list_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
			final int otherSize = other_value.value_elements.size();
			for (int elem_count = 0; elem_count < otherSize; elem_count++) {
				if (other_value.constGetAt(elem_count).isBound()) {
					value_elements.add( new TitanLog_sequence__list_0_template(other_value.constGetAt(elem_count)) );
				} else {
					value_elements.add( new TitanLog_sequence__list_0_template() );
				}
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLog_sequence__list_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanLog_sequence__list_template temp = new TitanLog_sequence__list_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		set_selection(other_value);
	}

	public boolean isPresent() {
		return isPresent(false);
	}

	public boolean isPresent(final boolean legacy) {
		if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
			return false;
		}
		return !match_omit(legacy);
	}

	// originally match
	public boolean match(final TitanLog_sequence__list other_value) {
		return match(other_value, false);
	}

	// originally match
	public boolean match(final TitanLog_sequence__list other_value, final boolean legacy) {
		if(!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case OMIT_VALUE:
			return false;
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for(int i = 0 ; i < list_value.size(); i++) {
				if(list_value.get(i).match(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
				}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
	}

	private boolean match_index(final TitanLog_sequence__list value_ptr, final int value_index, final TitanLog_sequence__list_template template_ptr, final int template_index, final boolean legacy) {
		if (value_index >= 0) {
			return template_ptr.value_elements.get(template_index).match(value_ptr.valueElements.get(value_index), legacy);
		} else {
			return template_ptr.value_elements.get(template_index).is_any_or_omit();
		}
	}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
		if (otherValue instanceof TitanLog_sequence__list) {
			return match((TitanLog_sequence__list)otherValue, legacy);
		}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list.");
	}

	public boolean match_omit(final boolean legacy) {
		if (is_ifPresent) {
			return true;
		}
		switch (templateSelection) {
		case OMIT_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			if (legacy) {
				for (int i = 0 ; i < list_value.size(); i++) {
					if (list_value.get(i).match_omit(legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			}
			return false;
		default:
			return false;
		}
	}

	//originally operator=
	public TitanLog_sequence__list_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_sequence__list_template assign( final TitanLog_sequence__list other_value ) {
		cleanUp();
		copy_value(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_sequence__list_template assign( final TitanLog_sequence__list_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

	@Override
	public TitanLog_sequence__list_template assign(final Base_Type otherValue) {
	if (otherValue instanceof TitanLog_sequence__list) {
		return assign((TitanLog_sequence__list)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list.");
	}

	@Override
	public TitanLog_sequence__list_template assign(final Base_Template otherValue) {
	if (otherValue instanceof TitanLog_sequence__list_template) {
		return assign((TitanLog_sequence__list_template)otherValue);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_template.");
	}

	public TitanLog_sequence__list_template assign( final Optional<TitanLog_sequence__list> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copy_value(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		return this;
	}

	@Override
	public void cleanUp() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			value_elements.clear();
			value_elements = null;
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value.clear();
			list_value = null;
			break;
		default:
			break;
		}
		templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
	}

	public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl.valueOf());
	}

	public TitanLog_sequence__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list_template repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		if (!repl.isValue()) {
			throw new TtcnError("The fourth argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl.valueOf());
	}

	public TitanLog_sequence__list replace(final int index, final int len, final TitanLog_sequence__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index, len, repl);
	}

	public TitanLog_sequence__list replace(final TitanInteger index, final TitanInteger len, final TitanLog_sequence__list repl) {
		if (!isValue()) {
			throw new TtcnError("The first argument of function replace() is a template with non-specific value.");
		}
		return valueOf().replace(index.getInt(), len.getInt(), repl);
	}

	public TitanLog_sequence__list_0_template getAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list using a negative index: {0}.", index_value ) );
		}

		switch (templateSelection) {
		case SPECIFIC_VALUE:
			if(index_value < value_elements.size()) {

				break;
			}
			// no break
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case UNINITIALIZED_TEMPLATE:
			setSize(index_value + 1);
			break;
		default:
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		return value_elements.get(index_value);
	}

	public TitanLog_sequence__list_0_template getAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}

		return getAt(index_value.getInt());
	}

	public TitanLog_sequence__list_0_template constGetAt(final int index_value) {
		if (index_value < 0) {
			throw new TtcnError( MessageFormat.format( "Accessing an element of a template for type @TitanLoggerApi.TitanLog.sequence_list using a negative index: {0}.", index_value ) );
		}

		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing an element of a non-specific template for type @TitanLoggerApi.TitanLog.sequence_list.");
		}

		if (index_value >= value_elements.size()) {
			throw new TtcnError( MessageFormat.format( "Index overflow in a template of type @TitanLoggerApi.TitanLog.sequence_list: The index is {0}, but the template has only {1} elements.", index_value, value_elements.size() ) );
		}

		return value_elements.get(index_value);
	}

	public TitanLog_sequence__list_0_template constGetAt(final TitanInteger index_value) {
		if (!index_value.isBound()) {
			throw new TtcnError("Using an unbound integer value for indexing a template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}

		return constGetAt(index_value.getInt());
	}

	private int get_length_for_concat(final AtomicBoolean is_any_value) {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return value_elements.size();
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				if (templateSelection == template_sel.ANY_VALUE) {
					// ? => { * }
					is_any_value.set( true );
					return 1;
				}
				throw new TtcnError("Operand of record of template concatenation is an AnyValueOrNone (*) matching mechanism with no length restriction");
			case RANGE_LENGTH_RESTRICTION:
				if (range_length_max_length == 0 || range_length_max_length != range_length_min_length) {
					throw new TtcnError( MessageFormat.format( "Operand of record of template concatenation is an {0} matching mechanism with non-fixed length restriction", templateSelection == template_sel.ANY_VALUE ? "AnyValue (?)" : "AnyValueOrNone (*)" ) );
				}
				// else fall through (range length restriction is allowed if the minimum
				// and maximum value are the same)
			case SINGLE_LENGTH_RESTRICTION:
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				return length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? single_length : range_length_min_length;
			}
		default:
			throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
		}
	}

	private int get_length_for_concat(final TitanLog_sequence__list operand) {
		operand.mustBound("Operand of record of template concatenation is an unbound value.");
		return operand.valueElements.size();
	}


	private int get_length_for_concat(final template_sel operand) {
		if (operand == template_sel.ANY_VALUE) {
			// ? => { * }
			return 1;
		}
		throw new TtcnError("Operand of record of template concatenation is an uninitialized or unsupported template.");
	}

			//TODO: simplify, just use value_elements.add()
	private void concat(final AtomicInteger pos, final TitanLog_sequence__list_template operand) {
		// all errors should have already been caught by the operand's
		// get_length_for_concat() call;
		// the result template (this) should already be set to SPECIFIC_VALUE and
		// single_value.value_elements should already be allocated
		switch (operand.templateSelection) {
		case SPECIFIC_VALUE:
			for (int i = 0; i < operand.value_elements.size(); ++i) {
				value_elements.set( pos.get() + i, new TitanLog_sequence__list_0_template(operand.value_elements.get(i)) );
			}
			pos.addAndGet( operand.value_elements.size() );
			break;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			switch (operand.length_restriction_type) {
			case NO_LENGTH_RESTRICTION:
				// ? => { * }
				value_elements.set( pos.get(), new TitanLog_sequence__list_0_template( template_sel.ANY_OR_OMIT ) );
				pos.incrementAndGet();
				break;
			case RANGE_LENGTH_RESTRICTION:
			case SINGLE_LENGTH_RESTRICTION: {
				// ? length(N) or * length(N) => { ?, ?, ... ? } N times
				final int N = operand.length_restriction_type == length_restriction_type_t.SINGLE_LENGTH_RESTRICTION ? operand.single_length : operand.range_length_min_length;
				for (int i = 0; i < N; ++i) {
					value_elements.set( pos.get() + i, new TitanLog_sequence__list_0_template( template_sel.ANY_VALUE ) );
				}
				pos.addAndGet( N );
				break; }
			}
		default:
			break;
		}
	}

	public void setSize(final int new_size) {
		if (new_size < 0) {
			throw new TtcnError("Internal error: Setting a negative size for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		final template_sel old_selection = templateSelection;
		if (old_selection != template_sel.SPECIFIC_VALUE) {
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			value_elements = null;
		}
		if (value_elements == null) {
			value_elements = new ArrayList<TitanLog_sequence__list_0_template>();
		}
		if (new_size > value_elements.size()) {
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanLog_sequence__list_0_template(template_sel.ANY_VALUE) );
				}
			} else {
				for (int elem_count = value_elements.size(); elem_count < new_size; elem_count++) {
					value_elements.add( new TitanLog_sequence__list_0_template() );
				}
			}
		} else if (new_size < value_elements.size()) {
			final int oldSize = value_elements.size();
			for (int elem_count = new_size; elem_count < oldSize; elem_count++) {
				value_elements.remove( new_size );
			}
		}
	}

	public TitanInteger sizeOf() {
		return sizeOf(true);
	}

	public TitanInteger lengthOf() {
		return sizeOf(false);
	}

	public TitanInteger sizeOf(final boolean is_size) {
		final String op_name = is_size ? "size" : "length";
		if (is_ifPresent) {
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list which has an ifpresent attribute.", op_name ) );
		}
		int min_size;
		boolean has_any_or_none;
		switch (templateSelection)
		{
		case SPECIFIC_VALUE: {
			min_size = 0;
			has_any_or_none = false;
			int elem_count = value_elements.size();
			if (!is_size) {
				while (elem_count>0 && !(value_elements.get(elem_count-1)).isBound()) {
					elem_count--;
				}
			}
			for (int i=0; i<elem_count; i++)
			{
			switch (value_elements.get(i).get_selection())
				{
				case OMIT_VALUE:
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing omit element.", op_name ) );
				case ANY_OR_OMIT:
					has_any_or_none = true;
					break;
				default:
					min_size++;
					break;
				}
			}
		} break;
		case OMIT_VALUE:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing omit value.", op_name ) );
		case ANY_VALUE:
		case ANY_OR_OMIT:
			min_size = 0;
			has_any_or_none = true;
			break;
		case VALUE_LIST:
		{
			if (list_value.size()<1) {
				throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing an empty list.", op_name ) );
			}
			final int item_size = list_value.get(0).sizeOf(is_size).getInt();
			for (int i = 1; i < list_value.size(); i++) {
				if (list_value.get(i).sizeOf(is_size).getInt()!=item_size) {
					throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing a value list with different sizes.", op_name ) );
				}
			}
			min_size = item_size;
			has_any_or_none = false;
			break;
		}
		case COMPLEMENTED_LIST:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list containing complemented list.", op_name ) );
		default:
			throw new TtcnError( MessageFormat.format( "Performing {0}of() operation on an uninitialized/unsupported template of type TitanLog_sequence__list.", op_name ) );
		}
		return new TitanInteger(check_section_is_single(min_size, has_any_or_none, op_name, "a template of type", "TitanLog_sequence__list_0_template"));
	}

	public TitanInteger n_elem() {
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return new TitanInteger(value_elements.size());
		case COMPLEMENTED_LIST:
			throw new TtcnError("Performing n_elem() operation on a template of type TitanLog_sequence__list containing complemented list.");
		case UNINITIALIZED_TEMPLATE:
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
		case VALUE_LIST:
		case VALUE_RANGE:
		case STRING_PATTERN:
		case SUPERSET_MATCH:
		case SUBSET_MATCH:
		case DECODE_MATCH:
			break;
		}
		throw new TtcnError("Performing n_elem() operation on an uninitialized/unsupported template of type TitanLog_sequence__list.");
	}

	private boolean matchv(final TitanLog_sequence__list other_value, final boolean legacy) {
		if (!other_value.isBound()) {
			return false;
		}
		final int value_length = other_value.sizeOf().getInt();
		if (!match_length(value_length)) {
			return false;
		}
		switch (templateSelection) {
		case SPECIFIC_VALUE:
			return RecordOfMatch.match_record_of(other_value, value_length, this, value_elements.size(), match_function_specific, legacy);
		case OMIT_VALUE:
			return false;
		case ANY_VALUE:
		case ANY_OR_OMIT:
			return true;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			for (int list_count = 0; list_count < list_value.size(); list_count++) {
				if (list_value.get(list_count).matchv(other_value, legacy)) {
					return templateSelection == template_sel.VALUE_LIST;
		}
			}
			return templateSelection == template_sel.COMPLEMENTED_LIST;
		default:
			throw new TtcnError("Matching with an uninitialized/unsupported template of type TitanLog_sequence__list.");
		}
	}

	@Override
	public boolean isValue() {
		if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
			return false;
		}
		for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
			if (!value_elements.get(elem_count).isValue()) {
				return false;
			}
		}
		return true;
	}

	public void setType(final template_sel template_type, final int list_length) {
		cleanUp();
		switch (template_type) {
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLog_sequence__list_template>( list_length );
			for (int list_count = 0; list_count < list_length; list_count++) {
				list_value.add( new TitanLog_sequence__list_template() );
			}
			break;
		default:
			throw new TtcnError("Internal error: Setting an invalid type for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		set_selection(template_type);
	}

		public TitanLog_sequence__list_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			return list_value.get(list_index);
		}

	public TitanLog_sequence__list_template get_list_item(final int list_index) {
		if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
			throw new TtcnError("Internal error: Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		if (list_index < 0) {
			throw new TtcnError( MessageFormat.format( "Internal error: Accessing a value list template of type @TitanLoggerApi.TitanLog.sequence_list using a negative index ({0}).", list_index ) );
		}
		if (list_index >= list_value.size()) {
			throw new TtcnError("Internal error: Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.");
		}
		return list_value.get( list_index );
	}

		public TitanLog_sequence__list valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
			final TitanLog_sequence__list ret_val = new TitanLog_sequence__list(TitanNull_Type.NULL_VALUE);
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (value_elements.get(elem_count).isBound()) {
					ret_val.valueElements.add( value_elements.get(elem_count).valueOf() );
				}
			}
			return ret_val;
		}

		public TitanLog_sequence__list substr(final int index, final int returncount) {
			if (!isValue()) {
				throw new TtcnError("The first argument of function substr() is a template with non-specific value.");
			}
			return valueOf().substr(index, returncount);
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				if (value_elements.size() > 0) {
					TTCN_Logger.log_event_str("{ ");
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if (elem_count > 0) {
							TTCN_Logger.log_event_str(", ");
						}
						if (permutation_starts_at(elem_count)) {
							TTCN_Logger.log_event_str("permutation(");
						}
						value_elements.get(elem_count).log();
						if (permutation_ends_at(elem_count)) {
							TTCN_Logger.log_char(')');
						}
					}
					TTCN_Logger.log_event_str(" }");
				} else {
					TTCN_Logger.log_event_str("{ }");
				}
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
			}
			log_restricted();
			log_ifpresent();
		}

	public void log_match(final TitanLog_sequence__list match_value) {
		log_match(match_value, false);
	}

	@Override
	public void log_match(final Base_Type match_value, final boolean legacy) {
		if (match_value instanceof TitanLog_sequence__list) {
			log_match((TitanLog_sequence__list)match_value, legacy);
			return;
		}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.sequence_list.");
	}

	public void log_match(final TitanLog_sequence__list match_value, final boolean legacy) {
		if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
			if(match(match_value, legacy)) {
				TTCN_Logger.print_logmatch_buffer();
				TTCN_Logger.log_event_str(" matched");
			} else {
				if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
					final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
					for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
						if ( !value_elements.get(elem_count).match(match_value.constGetAt(elem_count), legacy) ) {
						TTCN_Logger.log_logmatch_info("[%d]", elem_count);
							value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					}
					log_match_length(value_elements.size());
				} else {
					TTCN_Logger.print_logmatch_buffer();
					match_value.log();
					TTCN_Logger.log_event_str(" with ");
					log();
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
			return;
		}
		if (templateSelection == template_sel.SPECIFIC_VALUE && value_elements.size() > 0 && get_number_of_permutations() == 0 && value_elements.size() == match_value.sizeOf().getInt()) {
			TTCN_Logger.log_event_str("{ ");
			for (int elem_count = 0; elem_count < value_elements.size(); elem_count++) {
				if (elem_count > 0) {
					TTCN_Logger.log_event_str(", ");
				}
				value_elements.get(elem_count).log_match( match_value.constGetAt(elem_count), legacy );
			}
			TTCN_Logger.log_event_str(" }");
			log_match_length(value_elements.size());
		} else {
			match_value.log();
			TTCN_Logger.log_event_str(" with ");
			log();
			if ( match(match_value, legacy) ) {
				TTCN_Logger.log_event_str(" matched");
			} else {
				TTCN_Logger.log_event_str(" unmatched");
			}
		}
	}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				text_buf.push_int(value_elements.size());
				for (int i = 0; i < value_elements.size(); i++) {
					value_elements.get(i).encode_text(text_buf);
				}
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_permutation(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE: {
				final int temp = text_buf.pull_int().getInt();
				if (temp < 0) {
					throw new TtcnError("Text decoder: Negative size was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
				}
				value_elements = new ArrayList<TitanLog_sequence__list_0_template>(temp);
				for (int i = 0; i < temp; i++) {
					final TitanLog_sequence__list_0_template temp2 = new TitanLog_sequence__list_0_template();
					temp2.decode_text(text_buf);
					value_elements.add(temp2);
				}
				break;
				}
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
				final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_sequence__list_template>(size);
				for (int i = 0; i < size; i++) {
					final TitanLog_sequence__list_template temp2 = new TitanLog_sequence__list_template();
					temp2.decode_text(text_buf);
					list_value.add(temp2);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of type @TitanLoggerApi.TitanLog.sequence_list.");
			}
		}

	@Override
	public boolean get_istemplate_kind(final String type) {
		if ("AnyElement".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
			return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_VALUE) {
					return true;
				}
			}
			return false;
		} else if ("AnyElementsOrNone".equals(type)) {
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return false;
			}
			for (int i = 0; i < value_elements.size(); i++) {
				if (value_elements.get(i).get_selection() == template_sel.ANY_OR_OMIT) {
					return true;
				}
			}
			return false;
		} else if ("permutation".equals(type)) {
			return get_number_of_permutations() != 0;
		} else if ("length".equals(type)) {
			return length_restriction_type != length_restriction_type_t.NO_LENGTH_RESTRICTION;
		} else {
			return super.get_istemplate_kind(type);
		}
	}
}
public static void TitanLog_sequence__list_encoder(final TitanLog_sequence__list input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLog_sequence__list_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLog_sequence__list_decoder( final TitanOctetString input_stream, final TitanLog_sequence__list output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLog_sequence__list_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__out_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__out_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__out_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__out_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void MatchingEvent_choice_matchingProblem_encoder(final MatchingProblemType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_choice_matchingProblem_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_choice_matchingProblem_decoder( final TitanOctetString input_stream, final MatchingProblemType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingProblemType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_choice_matchingProblem_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void DefaultEvent_choice_defaultopActivate_encoder(final DefaultOp input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(DefaultEvent_choice_defaultopActivate_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger DefaultEvent_choice_defaultopActivate_decoder( final TitanOctetString input_stream, final DefaultOp output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.DefaultOp' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(DefaultEvent_choice_defaultopActivate_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__out_compref_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__out_compref_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__out_compref_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__out_compref_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void StatisticsType_choice_verdictStatistics_error___encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_choice_verdictStatistics_error___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_choice_verdictStatistics_error___decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_choice_verdictStatistics_error___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FunctionEvent_choice_unqualified_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_choice_unqualified_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_choice_unqualified_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_choice_unqualified_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FinalVerdictType_choice_info_encoder(final FinalVerdictInfo input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FinalVerdictType_choice_info_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FinalVerdictType_choice_info_decoder( final TitanOctetString input_stream, final FinalVerdictInfo output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FinalVerdictInfo' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FinalVerdictType_choice_info_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelPTC_status_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelPTC_status_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelPTC_status_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelPTC_status_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_unqualifiedTimer_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_unqualifiedTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_unqualifiedTimer_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_unqualifiedTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__discard_incoming_encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__discard_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__discard_incoming_decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__discard_incoming_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void FunctionEvent_choice_random_retval_encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_choice_random_retval_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_choice_random_retval_decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_choice_random_retval_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ExecutionSummaryType extends Base_Type {
		private final TitanInteger numberOfTestcases; //Integer_Type
		private final TitanCharString overallStatistics; //CharString_Type

		public ExecutionSummaryType() {
			numberOfTestcases = new TitanInteger();
			overallStatistics = new TitanCharString();
		}

		public ExecutionSummaryType( final TitanInteger aNumberOfTestcases, final TitanCharString aOverallStatistics ) {
			numberOfTestcases = new TitanInteger( aNumberOfTestcases );
			overallStatistics = new TitanCharString( aOverallStatistics );
		}

		public ExecutionSummaryType( final ExecutionSummaryType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			numberOfTestcases = new TitanInteger();
			overallStatistics = new TitanCharString();
			assign( aOtherValue );
		}
		public ExecutionSummaryType assign(final ExecutionSummaryType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutionSummaryType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getNumberOfTestcases().isBound() ) {
					this.numberOfTestcases.assign( aOtherValue.getNumberOfTestcases() );
				} else {
					this.numberOfTestcases.cleanUp();
				}
				if ( aOtherValue.getOverallStatistics().isBound() ) {
					this.overallStatistics.assign( aOtherValue.getOverallStatistics() );
				} else {
					this.overallStatistics.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutionSummaryType assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutionSummaryType ) {
				return assign((ExecutionSummaryType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutionSummaryType", otherValue));
		}

		public void cleanUp() {
			numberOfTestcases.cleanUp();
			overallStatistics.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( numberOfTestcases.isBound() ) { return true; }
			if ( overallStatistics.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !numberOfTestcases.isValue() ) { return false; }
			if ( !overallStatistics.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutionSummaryType aOtherValue ) {
			if ( !this.numberOfTestcases.operatorEquals( aOtherValue.numberOfTestcases ) ) { return false; }
			if ( !this.overallStatistics.operatorEquals( aOtherValue.overallStatistics ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutionSummaryType ) {
				return operatorEquals((ExecutionSummaryType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutionSummaryType", otherValue));
		}

		public TitanInteger getNumberOfTestcases() {
			return numberOfTestcases;
		}

		public TitanInteger constGetNumberOfTestcases() {
			return numberOfTestcases;
		}

		public TitanCharString getOverallStatistics() {
			return overallStatistics;
		}

		public TitanCharString constGetOverallStatistics() {
			return overallStatistics;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" numberOfTestcases := ");
			numberOfTestcases.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" overallStatistics := ");
			overallStatistics.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (numberOfTestcases.isBound()) {
				numberOfTestcases.set_implicit_omit();
			}
			if (overallStatistics.isBound()) {
				overallStatistics.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			numberOfTestcases.encode_text(text_buf);
			overallStatistics.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			numberOfTestcases.decode_text(text_buf);
			overallStatistics.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ExecutionSummaryType_template extends Base_Template {

	private TitanInteger_template numberOfTestcases; //Integer_Type
	private TitanCharString_template overallStatistics; //CharString_Type
	//originally value_list/list_value
	List<ExecutionSummaryType_template> list_value;

	public TitanInteger_template getNumberOfTestcases() {
		setSpecific();
		return numberOfTestcases;
	}

	public TitanInteger_template constGetNumberOfTestcases() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field numberOfTestcases of a non-specific template of type @TitanLoggerApi.ExecutionSummaryType.");
		}
		return numberOfTestcases;
	}

	public TitanCharString_template getOverallStatistics() {
		setSpecific();
		return overallStatistics;
	}

	public TitanCharString_template constGetOverallStatistics() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field overallStatistics of a non-specific template of type @TitanLoggerApi.ExecutionSummaryType.");
		}
		return overallStatistics;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			numberOfTestcases = new TitanInteger_template();
			overallStatistics = new TitanCharString_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				numberOfTestcases.assign(template_sel.ANY_VALUE);
				overallStatistics.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public ExecutionSummaryType_template() {
	}

	public ExecutionSummaryType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ExecutionSummaryType_template( final ExecutionSummaryType otherValue ) {
		copyValue(otherValue);
	}

	public ExecutionSummaryType_template( final ExecutionSummaryType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ExecutionSummaryType_template( final Optional<ExecutionSummaryType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutionSummaryType from an unbound optional field.");
		}
	}

	//originally operator=
	public ExecutionSummaryType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ExecutionSummaryType_template assign( final ExecutionSummaryType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ExecutionSummaryType_template assign( final ExecutionSummaryType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ExecutionSummaryType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutionSummaryType) {
				return assign((ExecutionSummaryType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutionSummaryType' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutionSummaryType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutionSummaryType_template) {
				return assign((ExecutionSummaryType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutionSummaryType' can not be cast to {1}_template", otherValue));
		}

	public ExecutionSummaryType_template assign( final Optional<ExecutionSummaryType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutionSummaryType.");
		}
		return this;
	}

	private void copyValue(final ExecutionSummaryType other_value) {
		if (other_value.getNumberOfTestcases().isBound()) {
			getNumberOfTestcases().assign(other_value.getNumberOfTestcases());
		} else {
			getNumberOfTestcases().cleanUp();
		}
		if (other_value.getOverallStatistics().isBound()) {
			getOverallStatistics().assign(other_value.getOverallStatistics());
		} else {
			getOverallStatistics().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ExecutionSummaryType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getNumberOfTestcases().get_selection()) {
				getNumberOfTestcases().cleanUp();
			} else {
				getNumberOfTestcases().assign(other_value.getNumberOfTestcases());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getOverallStatistics().get_selection()) {
				getOverallStatistics().cleanUp();
			} else {
				getOverallStatistics().assign(other_value.getOverallStatistics());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ExecutionSummaryType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ExecutionSummaryType_template temp = new ExecutionSummaryType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutionSummaryType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutionSummaryType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			final ExecutionSummaryType ret_val = new ExecutionSummaryType();
			 if (numberOfTestcases.isBound()) {
				ret_val.numberOfTestcases.assign(numberOfTestcases.valueOf());
			}
			 if (overallStatistics.isBound()) {
				ret_val.overallStatistics.assign(overallStatistics.valueOf());
			}
			return ret_val;
		}

		public ExecutionSummaryType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutionSummaryType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutionSummaryType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (numberOfTestcases.isBound()) {
				return true;
			}
			if (overallStatistics.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!numberOfTestcases.isValue()) {
				return false;
			}
			if (!overallStatistics.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutionSummaryType other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutionSummaryType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getNumberOfTestcases().isBound()) {
					return false;
				}
				if(!numberOfTestcases.match(other_value.getNumberOfTestcases(), legacy)) {
					return false;
				}
				if(!other_value.getOverallStatistics().isBound()) {
					return false;
				}
				if(!overallStatistics.match(other_value.getOverallStatistics(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutionSummaryType) {
		return match((ExecutionSummaryType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutionSummaryType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutionSummaryType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" numberOfTestcases := ");
				numberOfTestcases.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" overallStatistics := ");
				overallStatistics.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutionSummaryType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutionSummaryType) {
				log_match((ExecutionSummaryType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutionSummaryType.");
		}

		public void log_match(final ExecutionSummaryType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !numberOfTestcases.match(match_value.constGetNumberOfTestcases(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".numberOfTestcases");
							numberOfTestcases.log_match(match_value.constGetNumberOfTestcases(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !overallStatistics.match(match_value.constGetOverallStatistics(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".overallStatistics");
							overallStatistics.log_match(match_value.constGetOverallStatistics(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ numberOfTestcases := ");
				numberOfTestcases.log_match(match_value.constGetNumberOfTestcases(), legacy);
				TTCN_Logger.log_event_str("{ overallStatistics := ");
				overallStatistics.log_match(match_value.constGetOverallStatistics(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				numberOfTestcases.encode_text(text_buf);
				overallStatistics.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				numberOfTestcases = new TitanInteger_template();
				numberOfTestcases.decode_text(text_buf);
				overallStatistics = new TitanCharString_template();
				overallStatistics.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutionSummaryType_template>(size);
				for(int i = 0; i < size; i++) {
					final ExecutionSummaryType_template temp = new ExecutionSummaryType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutionSummaryType.");
			}
		}
}
public static void ExecutionSummaryType_encoder(final ExecutionSummaryType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutionSummaryType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutionSummaryType_decoder( final TitanOctetString input_stream, final ExecutionSummaryType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutionSummaryType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Setstate_port__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Setstate_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Setstate_port__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Setstate_port__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void LogEventType_choice_executionSummary_encoder(final ExecutionSummaryType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(LogEventType_choice_executionSummary_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger LogEventType_choice_executionSummary_decoder( final TitanOctetString input_stream, final ExecutionSummaryType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutionSummaryType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(LogEventType_choice_executionSummary_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerEvent_choice_readTimer_encoder(final TimerType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerEvent_choice_readTimer_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerEvent_choice_readTimer_decoder( final TitanOctetString input_stream, final TimerType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TimerType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerEvent_choice_readTimer_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimerGuardType_value___encoder(final TitanFloat input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimerGuardType_value___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimerGuardType_value___decoder( final TitanOctetString input_stream, final TitanFloat output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `float' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimerGuardType_value___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__in_check___encoder(final TitanBoolean input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_check___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_check___decoder( final TitanOctetString input_stream, final TitanBoolean output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `boolean' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_check___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void ParallelEvent_choice_parallelPTC__exit_encoder(final PTC__exit input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ParallelEvent_choice_parallelPTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ParallelEvent_choice_parallelPTC__exit_decoder( final TitanOctetString input_stream, final PTC__exit output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.PTC_exit' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ParallelEvent_choice_parallelPTC__exit_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__discard_target__type_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__discard_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__discard_target__type_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__discard_target__type_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class MatchingEvent extends Base_Type {
		private final MatchingEvent_choice choice; //TTCN3_Choice_Type

		public MatchingEvent() {
			choice = new MatchingEvent_choice();
		}

		public MatchingEvent( final MatchingEvent_choice aChoice ) {
			choice = new MatchingEvent_choice( aChoice );
		}

		public MatchingEvent( final MatchingEvent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.MatchingEvent.");
			}
			choice = new MatchingEvent_choice();
			assign( aOtherValue );
		}
		public MatchingEvent assign(final MatchingEvent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.MatchingEvent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public MatchingEvent assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingEvent ) {
				return assign((MatchingEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingEvent", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final MatchingEvent aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof MatchingEvent ) {
				return operatorEquals((MatchingEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.MatchingEvent", otherValue));
		}

		public MatchingEvent_choice getChoice() {
			return choice;
		}

		public MatchingEvent_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class MatchingEvent_template extends Base_Template {

	private MatchingEvent_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<MatchingEvent_template> list_value;

	public MatchingEvent_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public MatchingEvent_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.MatchingEvent.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new MatchingEvent_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public MatchingEvent_template() {
	}

	public MatchingEvent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public MatchingEvent_template( final MatchingEvent otherValue ) {
		copyValue(otherValue);
	}

	public MatchingEvent_template( final MatchingEvent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public MatchingEvent_template( final Optional<MatchingEvent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.MatchingEvent from an unbound optional field.");
		}
	}

	//originally operator=
	public MatchingEvent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public MatchingEvent_template assign( final MatchingEvent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public MatchingEvent_template assign( final MatchingEvent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public MatchingEvent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof MatchingEvent) {
				return assign((MatchingEvent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingEvent' can not be cast to {1}", otherValue));
		}

		@Override
		public MatchingEvent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof MatchingEvent_template) {
				return assign((MatchingEvent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `MatchingEvent' can not be cast to {1}_template", otherValue));
		}

	public MatchingEvent_template assign( final Optional<MatchingEvent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.MatchingEvent.");
		}
		return this;
	}

	private void copyValue(final MatchingEvent other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final MatchingEvent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<MatchingEvent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final MatchingEvent_template temp = new MatchingEvent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.MatchingEvent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public MatchingEvent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.MatchingEvent.");
			}
			final MatchingEvent ret_val = new MatchingEvent();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public MatchingEvent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.MatchingEvent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.MatchingEvent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.MatchingEvent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<MatchingEvent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new MatchingEvent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final MatchingEvent other_value) {
			return match(other_value, false);
		}

		public boolean match(final MatchingEvent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingEvent) {
		return match((MatchingEvent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingEvent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.MatchingEvent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final MatchingEvent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof MatchingEvent) {
				log_match((MatchingEvent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.");
		}

		public void log_match(final MatchingEvent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.MatchingEvent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new MatchingEvent_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<MatchingEvent_template>(size);
				for(int i = 0; i < size; i++) {
					final MatchingEvent_template temp = new MatchingEvent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.MatchingEvent.");
			}
		}
}
public static void MatchingEvent_encoder(final MatchingEvent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_decoder( final TitanOctetString input_stream, final MatchingEvent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Dualface__mapped_value___encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__mapped_value___descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__mapped_value___decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__mapped_value___descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class StatisticsType extends Base_Type {
		private final StatisticsType_choice choice; //TTCN3_Choice_Type

		public StatisticsType() {
			choice = new StatisticsType_choice();
		}

		public StatisticsType( final StatisticsType_choice aChoice ) {
			choice = new StatisticsType_choice( aChoice );
		}

		public StatisticsType( final StatisticsType aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.StatisticsType.");
			}
			choice = new StatisticsType_choice();
			assign( aOtherValue );
		}
		public StatisticsType assign(final StatisticsType aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.StatisticsType");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getChoice().isBound() ) {
					this.choice.assign( aOtherValue.getChoice() );
				} else {
					this.choice.cleanUp();
				}
			}

			return this;
		}

		@Override
		public StatisticsType assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType ) {
				return assign((StatisticsType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType", otherValue));
		}

		public void cleanUp() {
			choice.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( choice.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !choice.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final StatisticsType aOtherValue ) {
			if ( !this.choice.operatorEquals( aOtherValue.choice ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType ) {
				return operatorEquals((StatisticsType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.StatisticsType", otherValue));
		}

		public StatisticsType_choice getChoice() {
			return choice;
		}

		public StatisticsType_choice constGetChoice() {
			return choice;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" choice := ");
			choice.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (choice.isBound()) {
				choice.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			choice.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			choice.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class StatisticsType_template extends Base_Template {

	private StatisticsType_choice_template choice; //TTCN3_Choice_Type
	//originally value_list/list_value
	List<StatisticsType_template> list_value;

	public StatisticsType_choice_template getChoice() {
		setSpecific();
		return choice;
	}

	public StatisticsType_choice_template constGetChoice() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field choice of a non-specific template of type @TitanLoggerApi.StatisticsType.");
		}
		return choice;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			choice = new StatisticsType_choice_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				choice.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public StatisticsType_template() {
	}

	public StatisticsType_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public StatisticsType_template( final StatisticsType otherValue ) {
		copyValue(otherValue);
	}

	public StatisticsType_template( final StatisticsType_template otherValue ) {
		copyTemplate( otherValue );
	}

	public StatisticsType_template( final Optional<StatisticsType> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.StatisticsType from an unbound optional field.");
		}
	}

	//originally operator=
	public StatisticsType_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public StatisticsType_template assign( final StatisticsType other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public StatisticsType_template assign( final StatisticsType_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public StatisticsType_template assign(final Base_Type otherValue) {
			if (otherValue instanceof StatisticsType) {
				return assign((StatisticsType) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType' can not be cast to {1}", otherValue));
		}

		@Override
		public StatisticsType_template assign(final Base_Template otherValue) {
			if (otherValue instanceof StatisticsType_template) {
				return assign((StatisticsType_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `StatisticsType' can not be cast to {1}_template", otherValue));
		}

	public StatisticsType_template assign( final Optional<StatisticsType> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.StatisticsType.");
		}
		return this;
	}

	private void copyValue(final StatisticsType other_value) {
		if (other_value.getChoice().isBound()) {
			getChoice().assign(other_value.getChoice());
		} else {
			getChoice().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final StatisticsType_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getChoice().get_selection()) {
				getChoice().cleanUp();
			} else {
				getChoice().assign(other_value.getChoice());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<StatisticsType_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final StatisticsType_template temp = new StatisticsType_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.StatisticsType.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public StatisticsType valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.StatisticsType.");
			}
			final StatisticsType ret_val = new StatisticsType();
			 if (choice.isBound()) {
				ret_val.choice.assign(choice.valueOf());
			}
			return ret_val;
		}

		public StatisticsType_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.StatisticsType.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.StatisticsType.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.StatisticsType.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<StatisticsType_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new StatisticsType_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (choice.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!choice.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final StatisticsType other_value) {
			return match(other_value, false);
		}

		public boolean match(final StatisticsType other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getChoice().isBound()) {
					return false;
				}
				if(!choice.match(other_value.getChoice(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof StatisticsType) {
		return match((StatisticsType)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type StatisticsType.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.StatisticsType containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" choice := ");
				choice.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final StatisticsType match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof StatisticsType) {
				log_match((StatisticsType)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.StatisticsType.");
		}

		public void log_match(final StatisticsType match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !choice.match(match_value.constGetChoice(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".choice");
							choice.log_match(match_value.constGetChoice(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ choice := ");
				choice.log_match(match_value.constGetChoice(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.StatisticsType.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				choice = new StatisticsType_choice_template();
				choice.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<StatisticsType_template>(size);
				for(int i = 0; i < size; i++) {
					final StatisticsType_template temp = new StatisticsType_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.StatisticsType.");
			}
		}
}
public static void StatisticsType_encoder(final StatisticsType input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(StatisticsType_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger StatisticsType_decoder( final TitanOctetString input_stream, final StatisticsType output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.StatisticsType' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(StatisticsType_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class Dualface__discard extends Base_Type {
		private final TitanBoolean incoming; //Boolean_Type
		private final TitanCharString target__type; //CharString_Type
		private final TitanCharString port__name; //CharString_Type
		private final TitanBoolean unhandled; //Boolean_Type

		public Dualface__discard() {
			incoming = new TitanBoolean();
			target__type = new TitanCharString();
			port__name = new TitanCharString();
			unhandled = new TitanBoolean();
		}

		public Dualface__discard( final TitanBoolean aIncoming, final TitanCharString aTarget__type, final TitanCharString aPort__name, final TitanBoolean aUnhandled ) {
			incoming = new TitanBoolean( aIncoming );
			target__type = new TitanCharString( aTarget__type );
			port__name = new TitanCharString( aPort__name );
			unhandled = new TitanBoolean( aUnhandled );
		}

		public Dualface__discard( final Dualface__discard aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.Dualface_discard.");
			}
			incoming = new TitanBoolean();
			target__type = new TitanCharString();
			port__name = new TitanCharString();
			unhandled = new TitanBoolean();
			assign( aOtherValue );
		}
		public Dualface__discard assign(final Dualface__discard aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.Dualface_discard");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getIncoming().isBound() ) {
					this.incoming.assign( aOtherValue.getIncoming() );
				} else {
					this.incoming.cleanUp();
				}
				if ( aOtherValue.getTarget__type().isBound() ) {
					this.target__type.assign( aOtherValue.getTarget__type() );
				} else {
					this.target__type.cleanUp();
				}
				if ( aOtherValue.getPort__name().isBound() ) {
					this.port__name.assign( aOtherValue.getPort__name() );
				} else {
					this.port__name.cleanUp();
				}
				if ( aOtherValue.getUnhandled().isBound() ) {
					this.unhandled.assign( aOtherValue.getUnhandled() );
				} else {
					this.unhandled.cleanUp();
				}
			}

			return this;
		}

		@Override
		public Dualface__discard assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__discard ) {
				return assign((Dualface__discard) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_discard", otherValue));
		}

		public void cleanUp() {
			incoming.cleanUp();
			target__type.cleanUp();
			port__name.cleanUp();
			unhandled.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( incoming.isBound() ) { return true; }
			if ( target__type.isBound() ) { return true; }
			if ( port__name.isBound() ) { return true; }
			if ( unhandled.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !incoming.isValue() ) { return false; }
			if ( !target__type.isValue() ) { return false; }
			if ( !port__name.isValue() ) { return false; }
			if ( !unhandled.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final Dualface__discard aOtherValue ) {
			if ( !this.incoming.operatorEquals( aOtherValue.incoming ) ) { return false; }
			if ( !this.target__type.operatorEquals( aOtherValue.target__type ) ) { return false; }
			if ( !this.port__name.operatorEquals( aOtherValue.port__name ) ) { return false; }
			if ( !this.unhandled.operatorEquals( aOtherValue.unhandled ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__discard ) {
				return operatorEquals((Dualface__discard) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.Dualface_discard", otherValue));
		}

		public TitanBoolean getIncoming() {
			return incoming;
		}

		public TitanBoolean constGetIncoming() {
			return incoming;
		}

		public TitanCharString getTarget__type() {
			return target__type;
		}

		public TitanCharString constGetTarget__type() {
			return target__type;
		}

		public TitanCharString getPort__name() {
			return port__name;
		}

		public TitanCharString constGetPort__name() {
			return port__name;
		}

		public TitanBoolean getUnhandled() {
			return unhandled;
		}

		public TitanBoolean constGetUnhandled() {
			return unhandled;
		}

		public TitanInteger sizeOf() {
			int sizeof = 4;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" incoming := ");
			incoming.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" target_type := ");
			target__type.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" port_name := ");
			port__name.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" unhandled := ");
			unhandled.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (incoming.isBound()) {
				incoming.set_implicit_omit();
			}
			if (target__type.isBound()) {
				target__type.set_implicit_omit();
			}
			if (port__name.isBound()) {
				port__name.set_implicit_omit();
			}
			if (unhandled.isBound()) {
				unhandled.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			incoming.encode_text(text_buf);
			target__type.encode_text(text_buf);
			port__name.encode_text(text_buf);
			unhandled.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			incoming.decode_text(text_buf);
			target__type.decode_text(text_buf);
			port__name.decode_text(text_buf);
			unhandled.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class Dualface__discard_template extends Base_Template {

	private TitanBoolean_template incoming; //Boolean_Type
	private TitanCharString_template target__type; //CharString_Type
	private TitanCharString_template port__name; //CharString_Type
	private TitanBoolean_template unhandled; //Boolean_Type
	//originally value_list/list_value
	List<Dualface__discard_template> list_value;

	public TitanBoolean_template getIncoming() {
		setSpecific();
		return incoming;
	}

	public TitanBoolean_template constGetIncoming() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field incoming of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
		}
		return incoming;
	}

	public TitanCharString_template getTarget__type() {
		setSpecific();
		return target__type;
	}

	public TitanCharString_template constGetTarget__type() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field target_type of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
		}
		return target__type;
	}

	public TitanCharString_template getPort__name() {
		setSpecific();
		return port__name;
	}

	public TitanCharString_template constGetPort__name() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field port_name of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
		}
		return port__name;
	}

	public TitanBoolean_template getUnhandled() {
		setSpecific();
		return unhandled;
	}

	public TitanBoolean_template constGetUnhandled() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field unhandled of a non-specific template of type @TitanLoggerApi.Dualface_discard.");
		}
		return unhandled;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			incoming = new TitanBoolean_template();
			target__type = new TitanCharString_template();
			port__name = new TitanCharString_template();
			unhandled = new TitanBoolean_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				incoming.assign(template_sel.ANY_VALUE);
				target__type.assign(template_sel.ANY_VALUE);
				port__name.assign(template_sel.ANY_VALUE);
				unhandled.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public Dualface__discard_template() {
	}

	public Dualface__discard_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public Dualface__discard_template( final Dualface__discard otherValue ) {
		copyValue(otherValue);
	}

	public Dualface__discard_template( final Dualface__discard_template otherValue ) {
		copyTemplate( otherValue );
	}

	public Dualface__discard_template( final Optional<Dualface__discard> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.Dualface_discard from an unbound optional field.");
		}
	}

	//originally operator=
	public Dualface__discard_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public Dualface__discard_template assign( final Dualface__discard other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public Dualface__discard_template assign( final Dualface__discard_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public Dualface__discard_template assign(final Base_Type otherValue) {
			if (otherValue instanceof Dualface__discard) {
				return assign((Dualface__discard) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__discard' can not be cast to {1}", otherValue));
		}

		@Override
		public Dualface__discard_template assign(final Base_Template otherValue) {
			if (otherValue instanceof Dualface__discard_template) {
				return assign((Dualface__discard_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `Dualface__discard' can not be cast to {1}_template", otherValue));
		}

	public Dualface__discard_template assign( final Optional<Dualface__discard> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.Dualface_discard.");
		}
		return this;
	}

	private void copyValue(final Dualface__discard other_value) {
		if (other_value.getIncoming().isBound()) {
			getIncoming().assign(other_value.getIncoming());
		} else {
			getIncoming().cleanUp();
		}
		if (other_value.getTarget__type().isBound()) {
			getTarget__type().assign(other_value.getTarget__type());
		} else {
			getTarget__type().cleanUp();
		}
		if (other_value.getPort__name().isBound()) {
			getPort__name().assign(other_value.getPort__name());
		} else {
			getPort__name().cleanUp();
		}
		if (other_value.getUnhandled().isBound()) {
			getUnhandled().assign(other_value.getUnhandled());
		} else {
			getUnhandled().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final Dualface__discard_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getIncoming().get_selection()) {
				getIncoming().cleanUp();
			} else {
				getIncoming().assign(other_value.getIncoming());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getTarget__type().get_selection()) {
				getTarget__type().cleanUp();
			} else {
				getTarget__type().assign(other_value.getTarget__type());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getPort__name().get_selection()) {
				getPort__name().cleanUp();
			} else {
				getPort__name().assign(other_value.getPort__name());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getUnhandled().get_selection()) {
				getUnhandled().cleanUp();
			} else {
				getUnhandled().assign(other_value.getUnhandled());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<Dualface__discard_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final Dualface__discard_template temp = new Dualface__discard_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.Dualface_discard.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public Dualface__discard valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.Dualface_discard.");
			}
			final Dualface__discard ret_val = new Dualface__discard();
			 if (incoming.isBound()) {
				ret_val.incoming.assign(incoming.valueOf());
			}
			 if (target__type.isBound()) {
				ret_val.target__type.assign(target__type.valueOf());
			}
			 if (port__name.isBound()) {
				ret_val.port__name.assign(port__name.valueOf());
			}
			 if (unhandled.isBound()) {
				ret_val.unhandled.assign(unhandled.valueOf());
			}
			return ret_val;
		}

		public Dualface__discard_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.Dualface_discard.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.Dualface_discard.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.Dualface_discard.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<Dualface__discard_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new Dualface__discard_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (incoming.isBound()) {
				return true;
			}
			if (target__type.isBound()) {
				return true;
			}
			if (port__name.isBound()) {
				return true;
			}
			if (unhandled.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!incoming.isValue()) {
				return false;
			}
			if (!target__type.isValue()) {
				return false;
			}
			if (!port__name.isValue()) {
				return false;
			}
			if (!unhandled.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final Dualface__discard other_value) {
			return match(other_value, false);
		}

		public boolean match(final Dualface__discard other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getIncoming().isBound()) {
					return false;
				}
				if(!incoming.match(other_value.getIncoming(), legacy)) {
					return false;
				}
				if(!other_value.getTarget__type().isBound()) {
					return false;
				}
				if(!target__type.match(other_value.getTarget__type(), legacy)) {
					return false;
				}
				if(!other_value.getPort__name().isBound()) {
					return false;
				}
				if(!port__name.match(other_value.getPort__name(), legacy)) {
					return false;
				}
				if(!other_value.getUnhandled().isBound()) {
					return false;
				}
				if(!unhandled.match(other_value.getUnhandled(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof Dualface__discard) {
		return match((Dualface__discard)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type Dualface__discard.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 4;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.Dualface_discard containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" incoming := ");
				incoming.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" target_type := ");
				target__type.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" port_name := ");
				port__name.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" unhandled := ");
				unhandled.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final Dualface__discard match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof Dualface__discard) {
				log_match((Dualface__discard)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.Dualface_discard.");
		}

		public void log_match(final Dualface__discard match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !incoming.match(match_value.constGetIncoming(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".incoming");
							incoming.log_match(match_value.constGetIncoming(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !target__type.match(match_value.constGetTarget__type(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".target_type");
							target__type.log_match(match_value.constGetTarget__type(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !port__name.match(match_value.constGetPort__name(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".port_name");
							port__name.log_match(match_value.constGetPort__name(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !unhandled.match(match_value.constGetUnhandled(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".unhandled");
							unhandled.log_match(match_value.constGetUnhandled(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ incoming := ");
				incoming.log_match(match_value.constGetIncoming(), legacy);
				TTCN_Logger.log_event_str("{ target_type := ");
				target__type.log_match(match_value.constGetTarget__type(), legacy);
				TTCN_Logger.log_event_str("{ port_name := ");
				port__name.log_match(match_value.constGetPort__name(), legacy);
				TTCN_Logger.log_event_str("{ unhandled := ");
				unhandled.log_match(match_value.constGetUnhandled(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming.encode_text(text_buf);
				target__type.encode_text(text_buf);
				port__name.encode_text(text_buf);
				unhandled.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.Dualface_discard.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				incoming = new TitanBoolean_template();
				incoming.decode_text(text_buf);
				target__type = new TitanCharString_template();
				target__type.decode_text(text_buf);
				port__name = new TitanCharString_template();
				port__name.decode_text(text_buf);
				unhandled = new TitanBoolean_template();
				unhandled.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<Dualface__discard_template>(size);
				for(int i = 0; i < size; i++) {
					final Dualface__discard_template temp = new Dualface__discard_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.Dualface_discard.");
			}
		}
}
public static void Dualface__discard_encoder(final Dualface__discard input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Dualface__discard_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Dualface__discard_decoder( final TitanOctetString input_stream, final Dualface__discard output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_discard' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Dualface__discard_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void TimestampType_seconds_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TimestampType_seconds_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TimestampType_seconds_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TimestampType_seconds_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PortEvent_choice_dualMapped_encoder(final Dualface__mapped input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PortEvent_choice_dualMapped_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PortEvent_choice_dualMapped_decoder( final TitanOctetString input_stream, final Dualface__mapped output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.Dualface_mapped' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PortEvent_choice_dualMapped_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class MatchingEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_MatchingDone,  ALT_MatchingSuccess,  ALT_MatchingFailure,  ALT_MatchingProblem,  ALT_MatchingTimeout };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public MatchingEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public MatchingEvent_choice(final MatchingEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final MatchingEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_MatchingDone:
field = new MatchingDoneType((MatchingDoneType)otherValue.field);
break;
case ALT_MatchingSuccess:
field = new MatchingSuccessType((MatchingSuccessType)otherValue.field);
break;
case ALT_MatchingFailure:
field = new MatchingFailureType((MatchingFailureType)otherValue.field);
break;
case ALT_MatchingProblem:
field = new MatchingProblemType((MatchingProblemType)otherValue.field);
break;
case ALT_MatchingTimeout:
field = new MatchingTimeout((MatchingTimeout)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.MatchingEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public MatchingEvent_choice assign( final MatchingEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public MatchingEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof MatchingEvent_choice) {
return assign((MatchingEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_MatchingDone:
return field.isValue();
case ALT_MatchingSuccess:
return field.isValue();
case ALT_MatchingFailure:
return field.isValue();
case ALT_MatchingProblem:
return field.isValue();
case ALT_MatchingTimeout:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final MatchingEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.MatchingEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_MatchingDone:
return ((MatchingDoneType)field).operatorEquals((MatchingDoneType)otherValue.field);
case ALT_MatchingSuccess:
return ((MatchingSuccessType)field).operatorEquals((MatchingSuccessType)otherValue.field);
case ALT_MatchingFailure:
return ((MatchingFailureType)field).operatorEquals((MatchingFailureType)otherValue.field);
case ALT_MatchingProblem:
return ((MatchingProblemType)field).operatorEquals((MatchingProblemType)otherValue.field);
case ALT_MatchingTimeout:
return ((MatchingTimeout)field).operatorEquals((MatchingTimeout)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof MatchingEvent_choice) {
return operatorEquals((MatchingEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final MatchingEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public MatchingDoneType getMatchingDone() {
if (union_selection != union_selection_type.ALT_MatchingDone) {
cleanUp();
field = new MatchingDoneType();
union_selection = union_selection_type.ALT_MatchingDone;
}
return (MatchingDoneType)field;
}

public MatchingDoneType constGetMatchingDone() {
if (union_selection != union_selection_type.ALT_MatchingDone) {
throw new TtcnError("Using non-selected field matchingDone in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingDoneType)field;
}

public MatchingSuccessType getMatchingSuccess() {
if (union_selection != union_selection_type.ALT_MatchingSuccess) {
cleanUp();
field = new MatchingSuccessType();
union_selection = union_selection_type.ALT_MatchingSuccess;
}
return (MatchingSuccessType)field;
}

public MatchingSuccessType constGetMatchingSuccess() {
if (union_selection != union_selection_type.ALT_MatchingSuccess) {
throw new TtcnError("Using non-selected field matchingSuccess in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingSuccessType)field;
}

public MatchingFailureType getMatchingFailure() {
if (union_selection != union_selection_type.ALT_MatchingFailure) {
cleanUp();
field = new MatchingFailureType();
union_selection = union_selection_type.ALT_MatchingFailure;
}
return (MatchingFailureType)field;
}

public MatchingFailureType constGetMatchingFailure() {
if (union_selection != union_selection_type.ALT_MatchingFailure) {
throw new TtcnError("Using non-selected field matchingFailure in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingFailureType)field;
}

public MatchingProblemType getMatchingProblem() {
if (union_selection != union_selection_type.ALT_MatchingProblem) {
cleanUp();
field = new MatchingProblemType();
union_selection = union_selection_type.ALT_MatchingProblem;
}
return (MatchingProblemType)field;
}

public MatchingProblemType constGetMatchingProblem() {
if (union_selection != union_selection_type.ALT_MatchingProblem) {
throw new TtcnError("Using non-selected field matchingProblem in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingProblemType)field;
}

public MatchingTimeout getMatchingTimeout() {
if (union_selection != union_selection_type.ALT_MatchingTimeout) {
cleanUp();
field = new MatchingTimeout();
union_selection = union_selection_type.ALT_MatchingTimeout;
}
return (MatchingTimeout)field;
}

public MatchingTimeout constGetMatchingTimeout() {
if (union_selection != union_selection_type.ALT_MatchingTimeout) {
throw new TtcnError("Using non-selected field matchingTimeout in a value of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingTimeout)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_MatchingDone:
TTCN_Logger.log_event_str("{ matchingDone := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MatchingSuccess:
TTCN_Logger.log_event_str("{ matchingSuccess := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MatchingFailure:
TTCN_Logger.log_event_str("{ matchingFailure := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MatchingProblem:
TTCN_Logger.log_event_str("{ matchingProblem := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_MatchingTimeout:
TTCN_Logger.log_event_str("{ matchingTimeout := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_MatchingDone:
case ALT_MatchingSuccess:
case ALT_MatchingFailure:
case ALT_MatchingProblem:
case ALT_MatchingTimeout:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_MatchingDone:
text_buf.push_int(0);
break;
case ALT_MatchingSuccess:
text_buf.push_int(1);
break;
case ALT_MatchingFailure:
text_buf.push_int(2);
break;
case ALT_MatchingProblem:
text_buf.push_int(3);
break;
case ALT_MatchingTimeout:
text_buf.push_int(4);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.MatchingEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getMatchingDone().decode_text(text_buf);
break;
case 1:
getMatchingSuccess().decode_text(text_buf);
break;
case 2:
getMatchingFailure().decode_text(text_buf);
break;
case 3:
getMatchingProblem().decode_text(text_buf);
break;
case 4:
getMatchingTimeout().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.MatchingEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class MatchingEvent_choice_template extends Base_Template {
//if single value which value?
private MatchingEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<MatchingEvent_choice_template> value_list;

private void copy_value(final MatchingEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_MatchingDone:
single_value = new MatchingDoneType_template(other_value.constGetMatchingDone());
break;
case ALT_MatchingSuccess:
single_value = new MatchingSuccessType_template(other_value.constGetMatchingSuccess());
break;
case ALT_MatchingFailure:
single_value = new MatchingFailureType_template(other_value.constGetMatchingFailure());
break;
case ALT_MatchingProblem:
single_value = new MatchingProblemType_template(other_value.constGetMatchingProblem());
break;
case ALT_MatchingTimeout:
single_value = new MatchingTimeout_template(other_value.constGetMatchingTimeout());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.MatchingEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final MatchingEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_MatchingDone:
single_value = new MatchingDoneType_template(other_value.constGetMatchingDone());
break;
case ALT_MatchingSuccess:
single_value = new MatchingSuccessType_template(other_value.constGetMatchingSuccess());
break;
case ALT_MatchingFailure:
single_value = new MatchingFailureType_template(other_value.constGetMatchingFailure());
break;
case ALT_MatchingProblem:
single_value = new MatchingProblemType_template(other_value.constGetMatchingProblem());
break;
case ALT_MatchingTimeout:
single_value = new MatchingTimeout_template(other_value.constGetMatchingTimeout());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.MatchingEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<MatchingEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final MatchingEvent_choice_template temp = new MatchingEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
set_selection(other_value);
}

public MatchingEvent_choice_template() {
}
public MatchingEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public MatchingEvent_choice_template(final MatchingEvent_choice other_value) {
copy_value(other_value);
}
public MatchingEvent_choice_template(final MatchingEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_MatchingDone:
((MatchingDoneType_template)single_value).cleanUp();
break;
case ALT_MatchingSuccess:
((MatchingSuccessType_template)single_value).cleanUp();
break;
case ALT_MatchingFailure:
((MatchingFailureType_template)single_value).cleanUp();
break;
case ALT_MatchingProblem:
((MatchingProblemType_template)single_value).cleanUp();
break;
case ALT_MatchingTimeout:
((MatchingTimeout_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public MatchingEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public MatchingEvent_choice_template assign( final MatchingEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public MatchingEvent_choice_template assign( final MatchingEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public MatchingEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof MatchingEvent_choice) {
return assign((MatchingEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to MatchingEvent_choice.");
}

@Override
public MatchingEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof MatchingEvent_choice_template) {
return assign((MatchingEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to MatchingEvent_choice_template.");
}

// originally match
public boolean match(final MatchingEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final MatchingEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final MatchingEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == MatchingEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_MatchingDone:
return ((MatchingDoneType_template)single_value).match(other_value.getMatchingDone(), legacy);
case ALT_MatchingSuccess:
return ((MatchingSuccessType_template)single_value).match(other_value.getMatchingSuccess(), legacy);
case ALT_MatchingFailure:
return ((MatchingFailureType_template)single_value).match(other_value.getMatchingFailure(), legacy);
case ALT_MatchingProblem:
return ((MatchingProblemType_template)single_value).match(other_value.getMatchingProblem(), legacy);
case ALT_MatchingTimeout:
return ((MatchingTimeout_template)single_value).match(other_value.getMatchingTimeout(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof MatchingEvent_choice) {
		return match((MatchingEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type MatchingEvent_choice.");
	}
public boolean isChosen(final MatchingEvent_choice.union_selection_type checked_selection) {
if(checked_selection == MatchingEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.MatchingEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == MatchingEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.MatchingEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_MatchingDone:
return ((MatchingDoneType_template)single_value).isValue();
case ALT_MatchingSuccess:
return ((MatchingSuccessType_template)single_value).isValue();
case ALT_MatchingFailure:
return ((MatchingFailureType_template)single_value).isValue();
case ALT_MatchingProblem:
return ((MatchingProblemType_template)single_value).isValue();
case ALT_MatchingTimeout:
return ((MatchingTimeout_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
}

public MatchingEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
final MatchingEvent_choice ret_val = new MatchingEvent_choice();
switch (single_value_union_selection) {
case ALT_MatchingDone:
ret_val.getMatchingDone().assign(((MatchingDoneType_template)single_value).valueOf());
break;
case ALT_MatchingSuccess:
ret_val.getMatchingSuccess().assign(((MatchingSuccessType_template)single_value).valueOf());
break;
case ALT_MatchingFailure:
ret_val.getMatchingFailure().assign(((MatchingFailureType_template)single_value).valueOf());
break;
case ALT_MatchingProblem:
ret_val.getMatchingProblem().assign(((MatchingProblemType_template)single_value).valueOf());
break;
case ALT_MatchingTimeout:
ret_val.getMatchingTimeout().assign(((MatchingTimeout_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<MatchingEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new MatchingEvent_choice_template());
}
}

public MatchingEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public MatchingDoneType_template getMatchingDone() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingDone) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new MatchingDoneType_template(template_sel.ANY_VALUE);
} else {
single_value = new MatchingDoneType_template();
}
single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_MatchingDone;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (MatchingDoneType_template)single_value;
}

public MatchingDoneType_template constGetMatchingDone() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field matchingDone in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingDone) {
throw new TtcnError("Accessing non-selected field matchingDone in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingDoneType_template)single_value;
}

public MatchingSuccessType_template getMatchingSuccess() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingSuccess) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new MatchingSuccessType_template(template_sel.ANY_VALUE);
} else {
single_value = new MatchingSuccessType_template();
}
single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_MatchingSuccess;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (MatchingSuccessType_template)single_value;
}

public MatchingSuccessType_template constGetMatchingSuccess() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field matchingSuccess in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingSuccess) {
throw new TtcnError("Accessing non-selected field matchingSuccess in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingSuccessType_template)single_value;
}

public MatchingFailureType_template getMatchingFailure() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingFailure) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new MatchingFailureType_template(template_sel.ANY_VALUE);
} else {
single_value = new MatchingFailureType_template();
}
single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_MatchingFailure;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (MatchingFailureType_template)single_value;
}

public MatchingFailureType_template constGetMatchingFailure() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field matchingFailure in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingFailure) {
throw new TtcnError("Accessing non-selected field matchingFailure in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingFailureType_template)single_value;
}

public MatchingProblemType_template getMatchingProblem() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingProblem) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new MatchingProblemType_template(template_sel.ANY_VALUE);
} else {
single_value = new MatchingProblemType_template();
}
single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_MatchingProblem;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (MatchingProblemType_template)single_value;
}

public MatchingProblemType_template constGetMatchingProblem() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field matchingProblem in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingProblem) {
throw new TtcnError("Accessing non-selected field matchingProblem in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingProblemType_template)single_value;
}

public MatchingTimeout_template getMatchingTimeout() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingTimeout) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new MatchingTimeout_template(template_sel.ANY_VALUE);
} else {
single_value = new MatchingTimeout_template();
}
single_value_union_selection = MatchingEvent_choice.union_selection_type.ALT_MatchingTimeout;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (MatchingTimeout_template)single_value;
}

public MatchingTimeout_template constGetMatchingTimeout() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field matchingTimeout in a non-specific template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
if (single_value_union_selection != MatchingEvent_choice.union_selection_type.ALT_MatchingTimeout) {
throw new TtcnError("Accessing non-selected field matchingTimeout in a template of union type @TitanLoggerApi.MatchingEvent.choice.");
}
return (MatchingTimeout_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof MatchingEvent_choice) {
log_match((MatchingEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.MatchingEvent.choice.");
}

public void log_match(final MatchingEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_MatchingDone:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".matchingDone");
single_value.log_match(match_value.getMatchingDone(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ matchingDone := ");
single_value.log_match(match_value.getMatchingDone(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MatchingSuccess:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".matchingSuccess");
single_value.log_match(match_value.getMatchingSuccess(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ matchingSuccess := ");
single_value.log_match(match_value.getMatchingSuccess(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MatchingFailure:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".matchingFailure");
single_value.log_match(match_value.getMatchingFailure(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ matchingFailure := ");
single_value.log_match(match_value.getMatchingFailure(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MatchingProblem:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".matchingProblem");
single_value.log_match(match_value.getMatchingProblem(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ matchingProblem := ");
single_value.log_match(match_value.getMatchingProblem(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_MatchingTimeout:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".matchingTimeout");
single_value.log_match(match_value.getMatchingTimeout(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ matchingTimeout := ");
single_value.log_match(match_value.getMatchingTimeout(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.MatchingEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new MatchingDoneType_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new MatchingSuccessType_template();
single_value.decode_text(text_buf);
break;
case 2:
single_value = new MatchingFailureType_template();
single_value.decode_text(text_buf);
break;
case 3:
single_value = new MatchingProblemType_template();
single_value.decode_text(text_buf);
break;
case 4:
single_value = new MatchingTimeout_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<MatchingEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final MatchingEvent_choice_template temp2 = new MatchingEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.MatchingEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void MatchingEvent_choice_encoder(final MatchingEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(MatchingEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger MatchingEvent_choice_decoder( final TitanOctetString input_stream, final MatchingEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.MatchingEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(MatchingEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void SetVerdictType_oldReason_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(SetVerdictType_oldReason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger SetVerdictType_oldReason_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(SetVerdictType_oldReason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class FunctionEvent_choice extends Base_Type {
public enum union_selection_type { UNBOUND_VALUE,  ALT_Unqualified,  ALT_Random };
private union_selection_type union_selection;
//originally a union which can not be mapped to Java
private Base_Type field;
public FunctionEvent_choice() {
union_selection = union_selection_type.UNBOUND_VALUE;
};
public FunctionEvent_choice(final FunctionEvent_choice otherValue) {
copy_value(otherValue);
};

private void copy_value(final FunctionEvent_choice otherValue) {
switch (otherValue.union_selection){
case ALT_Unqualified:
field = new TitanCharString((TitanCharString)otherValue.field);
break;
case ALT_Random:
field = new FunctionEvent_choice_random((FunctionEvent_choice_random)otherValue.field);
break;
default:
throw new TtcnError("Assignment of an unbound union value of type @TitanLoggerApi.FunctionEvent.choice.");
}
union_selection = otherValue.union_selection;
}

//originally operator=
public FunctionEvent_choice assign( final FunctionEvent_choice otherValue ) {
if (otherValue != this) {
cleanUp();
copy_value(otherValue);
}

return this;
}
@Override
public FunctionEvent_choice assign( final Base_Type otherValue ) {
if (otherValue instanceof FunctionEvent_choice) {
return assign((FunctionEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.");
}

//originally clean_up
public void cleanUp() {
field = null;
union_selection = union_selection_type.UNBOUND_VALUE;
}

public boolean isChosen(final union_selection_type checked_selection) {
if(checked_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return union_selection == checked_selection;
}

@Override
public boolean isBound() {
return union_selection != union_selection_type.UNBOUND_VALUE;
}

@Override
public boolean isValue() {
switch (union_selection) {
case UNBOUND_VALUE:
return false;
case ALT_Unqualified:
return field.isValue();
case ALT_Random:
return field.isValue();
default:
throw new TtcnError("Invalid selection in union is_bound");
}
}

@Override
public boolean isPresent() {
return isBound();
}

//originally operator==
public boolean operatorEquals( final FunctionEvent_choice otherValue ) {
if (union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The left operand of comparison is an unbound value of union type @TitanLoggerApi.FunctionEvent.choice." );
}
if (otherValue.union_selection == union_selection_type.UNBOUND_VALUE) {
throw new TtcnError( "The right operand of comparison is an unbound value of union type @TitanLoggerApi.FunctionEvent.choice." );
}
if (union_selection != otherValue.union_selection) {
return false;
}
switch (union_selection) {
case ALT_Unqualified:
return ((TitanCharString)field).operatorEquals((TitanCharString)otherValue.field);
case ALT_Random:
return ((FunctionEvent_choice_random)field).operatorEquals((FunctionEvent_choice_random)otherValue.field);
default:
return false;
}
}
@Override
public boolean operatorEquals( final Base_Type otherValue ) {
if (otherValue instanceof FunctionEvent_choice) {
return operatorEquals((FunctionEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.");
}

//originally operator!=
public boolean operatorNotEquals( final FunctionEvent_choice otherValue ) {
return !operatorEquals(otherValue);
}

public TitanCharString getUnqualified() {
if (union_selection != union_selection_type.ALT_Unqualified) {
cleanUp();
field = new TitanCharString();
union_selection = union_selection_type.ALT_Unqualified;
}
return (TitanCharString)field;
}

public TitanCharString constGetUnqualified() {
if (union_selection != union_selection_type.ALT_Unqualified) {
throw new TtcnError("Using non-selected field unqualified in a value of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return (TitanCharString)field;
}

public FunctionEvent_choice_random getRandom() {
if (union_selection != union_selection_type.ALT_Random) {
cleanUp();
field = new FunctionEvent_choice_random();
union_selection = union_selection_type.ALT_Random;
}
return (FunctionEvent_choice_random)field;
}

public FunctionEvent_choice_random constGetRandom() {
if (union_selection != union_selection_type.ALT_Random) {
throw new TtcnError("Using non-selected field random in a value of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return (FunctionEvent_choice_random)field;
}

public union_selection_type get_selection() {
return union_selection;
}
public void log() {
switch (union_selection) {
case ALT_Unqualified:
TTCN_Logger.log_event_str("{ unqualified := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
case ALT_Random:
TTCN_Logger.log_event_str("{ random := ");
field.log();
TTCN_Logger.log_event_str(" }");
break;
default:
TTCN_Logger.log_event_unbound();
break;
}
}
@Override
public void set_implicit_omit() {
switch (union_selection) {
case ALT_Unqualified:
case ALT_Random:
field.set_implicit_omit();
break;
default:
break;
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
switch (union_selection) {
case ALT_Unqualified:
text_buf.push_int(0);
break;
case ALT_Random:
text_buf.push_int(1);
break;
default:
throw new TtcnError("Text encoder: Encoding an unbound value of union type @TitanLoggerApi.FunctionEvent.choice.");
}
field.encode_text(text_buf);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
getUnqualified().decode_text(text_buf);
break;
case 1:
getRandom().decode_text(text_buf);
break;
default:
throw new TtcnError("Text decoder: Unrecognized union selector was received for type @TitanLoggerApi.FunctionEvent.choice.");
}
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

		//TODO: implement set_param !
}
public static class FunctionEvent_choice_template extends Base_Template {
//if single value which value?
private FunctionEvent_choice.union_selection_type single_value_union_selection;
//originally a union which can not be mapped to Java
private Base_Template single_value;
// value_list part
private ArrayList<FunctionEvent_choice_template> value_list;

private void copy_value(final FunctionEvent_choice other_value) {
single_value_union_selection = other_value.get_selection();
switch (other_value.get_selection()) {
case ALT_Unqualified:
single_value = new TitanCharString_template(other_value.constGetUnqualified());
break;
case ALT_Random:
single_value = new FunctionEvent_choice_random_template(other_value.constGetRandom());
break;
default:
throw new TtcnError("Initializing a template with an unbound value of type @TitanLoggerApi.FunctionEvent.choice.");
}
set_selection(template_sel.SPECIFIC_VALUE);
}
private void copy_template(final FunctionEvent_choice_template other_value) {
switch (other_value.templateSelection) {
case SPECIFIC_VALUE:
single_value_union_selection = other_value.single_value_union_selection;
switch (single_value_union_selection) {
case ALT_Unqualified:
single_value = new TitanCharString_template(other_value.constGetUnqualified());
break;
case ALT_Random:
single_value = new FunctionEvent_choice_random_template(other_value.constGetRandom());
break;
default:
throw new TtcnError("Internal error: Invalid union selector in a specific value when copying a template of type @TitanLoggerApi.FunctionEvent.choice.");
}
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<FunctionEvent_choice_template>(other_value.value_list.size());
for(int i = 0; i < other_value.value_list.size(); i++) {
final FunctionEvent_choice_template temp = new FunctionEvent_choice_template(other_value.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
set_selection(other_value);
}

public FunctionEvent_choice_template() {
}
public FunctionEvent_choice_template(final template_sel other_value) {
super(other_value);
checkSingleSelection(other_value);
}
public FunctionEvent_choice_template(final FunctionEvent_choice other_value) {
copy_value(other_value);
}
public FunctionEvent_choice_template(final FunctionEvent_choice_template other_value) {
copy_template(other_value);
}

@Override
public void cleanUp() {
switch (templateSelection) {
case SPECIFIC_VALUE:
switch (single_value_union_selection) {
case ALT_Unqualified:
((TitanCharString_template)single_value).cleanUp();
break;
case ALT_Random:
((FunctionEvent_choice_random_template)single_value).cleanUp();
break;
default:
break;
}
single_value = null;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.clear();
value_list = null;
break;
default:
break;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

//originally operator=
public FunctionEvent_choice_template assign( final template_sel other_value ) {
checkSingleSelection(other_value);
cleanUp();
set_selection(other_value);
return this;
}

//originally operator=
public FunctionEvent_choice_template assign( final FunctionEvent_choice other_value ) {
cleanUp();
copy_value(other_value);
return this;
}

//originally operator=
public FunctionEvent_choice_template assign( final FunctionEvent_choice_template other_value ) {
if (other_value != this) {
cleanUp();
copy_template(other_value);
}
return this;
}

@Override
public FunctionEvent_choice_template assign( final Base_Type otherValue ) {
if (otherValue instanceof FunctionEvent_choice) {
return assign((FunctionEvent_choice)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to FunctionEvent_choice.");
}

@Override
public FunctionEvent_choice_template assign( final Base_Template otherValue ) {
if (otherValue instanceof FunctionEvent_choice_template) {
return assign((FunctionEvent_choice_template)otherValue);
}
throw new TtcnError("Internal Error: value can not be cast to FunctionEvent_choice_template.");
}

// originally match
public boolean match(final FunctionEvent_choice other_value) {
return match(other_value, false);
}

// originally match
public boolean match(final FunctionEvent_choice other_value, final boolean legacy) {
if(!other_value.isBound()) {
return false;
}
switch (templateSelection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case OMIT_VALUE:
return false;
case SPECIFIC_VALUE:
final FunctionEvent_choice.union_selection_type value_selection = other_value.get_selection();
if (value_selection == FunctionEvent_choice.union_selection_type.UNBOUND_VALUE) {
return false;
}
if (value_selection != single_value_union_selection) {
return false;
}
switch (value_selection) {
case ALT_Unqualified:
return ((TitanCharString_template)single_value).match(other_value.getUnqualified(), legacy);
case ALT_Random:
return ((FunctionEvent_choice_random_template)single_value).match(other_value.getRandom(), legacy);
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when matching a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(other_value, legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported integer template.");
}
}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof FunctionEvent_choice) {
		return match((FunctionEvent_choice)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type FunctionEvent_choice.");
	}
public boolean isChosen(final FunctionEvent_choice.union_selection_type checked_selection) {
if(checked_selection == FunctionEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Performing ischosen() operation on an invalid field of union type @TitanLoggerApi.FunctionEvent.choice.");
}
switch (templateSelection) {
case SPECIFIC_VALUE:
if (single_value_union_selection == FunctionEvent_choice.union_selection_type.UNBOUND_VALUE) {
throw new TtcnError("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return single_value_union_selection == checked_selection;
case VALUE_LIST:
if (value_list.isEmpty()) {
throw new TtcnError("Internal error: Performing ischosen() operation on a template of union type @TitanLoggerApi.FunctionEvent.choice containing an empty list.");
}
for (int i = 0; i < value_list.size(); i++) {
if(!value_list.get(i).isChosen(checked_selection)) {
return false;
}
}
return true;
default:
return false;
}
}

@Override
public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
switch (single_value_union_selection) {
case ALT_Unqualified:
return ((TitanCharString_template)single_value).isValue();
case ALT_Random:
return ((FunctionEvent_choice_random_template)single_value).isValue();
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
}

public FunctionEvent_choice valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
final FunctionEvent_choice ret_val = new FunctionEvent_choice();
switch (single_value_union_selection) {
case ALT_Unqualified:
ret_val.getUnqualified().assign(((TitanCharString_template)single_value).valueOf());
break;
case ALT_Random:
ret_val.getRandom().assign(((FunctionEvent_choice_random_template)single_value).valueOf());
break;
default:
throw new TtcnError("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return ret_val;
}

public void setType(final template_sel template_type, final int list_length) {
if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Setting an invalid list for a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
cleanUp();
set_selection(template_type);
value_list = new ArrayList<FunctionEvent_choice_template>(list_length);
for(int i = 0 ; i < list_length; i++) {
value_list.add(new FunctionEvent_choice_template());
}
}

public FunctionEvent_choice_template listItem(final int list_index)  {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Internal error: Accessing a list element of a non-list template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
if (list_index < 0) {
throw new TtcnError("Internal error: Index underflow in a value list template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Internal error: Index overflow in a value list template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit(legacy)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
return false;
default:
return false;
}
}

public TitanCharString_template getUnqualified() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_Unqualified) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new TitanCharString_template(template_sel.ANY_VALUE);
} else {
single_value = new TitanCharString_template();
}
single_value_union_selection = FunctionEvent_choice.union_selection_type.ALT_Unqualified;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (TitanCharString_template)single_value;
}

public TitanCharString_template constGetUnqualified() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field unqualified in a non-specific template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
if (single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_Unqualified) {
throw new TtcnError("Accessing non-selected field unqualified in a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return (TitanCharString_template)single_value;
}

public FunctionEvent_choice_random_template getRandom() {
if (templateSelection != template_sel.SPECIFIC_VALUE || single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_Random) {
final template_sel old_selection = templateSelection;
cleanUp();
if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
single_value = new FunctionEvent_choice_random_template(template_sel.ANY_VALUE);
} else {
single_value = new FunctionEvent_choice_random_template();
}
single_value_union_selection = FunctionEvent_choice.union_selection_type.ALT_Random;
set_selection(template_sel.SPECIFIC_VALUE);
}
return (FunctionEvent_choice_random_template)single_value;
}

public FunctionEvent_choice_random_template constGetRandom() {
if (templateSelection != template_sel.SPECIFIC_VALUE) {
throw new TtcnError("Accessing field random in a non-specific template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
if (single_value_union_selection != FunctionEvent_choice.union_selection_type.ALT_Random) {
throw new TtcnError("Accessing non-selected field random in a template of union type @TitanLoggerApi.FunctionEvent.choice.");
}
return (FunctionEvent_choice_random_template)single_value;
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
single_value.log();
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}

@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof FunctionEvent_choice) {
log_match((FunctionEvent_choice)match_value, legacy);
			return;
}

throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.FunctionEvent.choice.");
}

public void log_match(final FunctionEvent_choice match_value, final boolean legacy) {
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() && match(match_value, legacy)) {
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str(" matched");
return;
}
if (templateSelection == template_sel.SPECIFIC_VALUE && single_value_union_selection == match_value.get_selection()) {
switch (single_value_union_selection) {
case ALT_Unqualified:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".unqualified");
single_value.log_match(match_value.getUnqualified(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ unqualified := ");
single_value.log_match(match_value.getUnqualified(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
case ALT_Random:
if (TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity()) {
TTCN_Logger.log_logmatch_info(".random");
single_value.log_match(match_value.getRandom(), legacy);
} else {
TTCN_Logger.log_logmatch_info("{ random := ");
single_value.log_match(match_value.getRandom(), legacy);
TTCN_Logger.log_event_str(" }");
}
break;
default:
TTCN_Logger.print_logmatch_buffer();
TTCN_Logger.log_event_str("<invalid selector>");
}
} else {
TTCN_Logger.print_logmatch_buffer();
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value_union_selection.ordinal());
single_value.encode_text(text_buf);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized template of type @TitanLoggerApi.FunctionEvent.choice.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
switch (temp) {
case 0:
single_value = new TitanCharString_template();
single_value.decode_text(text_buf);
break;
case 1:
single_value = new FunctionEvent_choice_random_template();
single_value.decode_text(text_buf);
break;
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<FunctionEvent_choice_template>(size);
for (int i = 0; i < size; i++) {
final FunctionEvent_choice_template temp2 = new FunctionEvent_choice_template();
temp2.decode_text(text_buf);
value_list.add(temp2);
}
break;
}
default:
throw new TtcnError("Text decoder: Unrecognized selector was received in a template of type @TitanLoggerApi.FunctionEvent.choice.");
}
}
		//TODO: implement set_param, check_restriction !
}
public static void FunctionEvent_choice_encoder(final FunctionEvent_choice input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(FunctionEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger FunctionEvent_choice_decoder( final TitanOctetString input_stream, final FunctionEvent_choice output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.FunctionEvent.choice' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(FunctionEvent_choice_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class RandomAction extends Base_Type {
public enum enum_type {
read__out (0),
seed (1),
UNKNOWN_VALUE(2),
UNBOUND_VALUE(3);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return read__out;
case 1:  return seed;
case 2:  return UNKNOWN_VALUE;
case 3:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public RandomAction() {
enum_value = enum_type.UNBOUND_VALUE;
}

public RandomAction(final RandomAction otherValue) {
enum_value = otherValue.enum_value;
}

public RandomAction(final RandomAction.enum_type otherValue ) {
enum_value = otherValue;
}

public RandomAction(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `RandomAction' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public RandomAction assign(final RandomAction otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public RandomAction assign(final Base_Type otherValue){
if( otherValue instanceof RandomAction ) {
return assign((RandomAction) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction' can not be cast to {1}", otherValue));
}

//originally operator=
public RandomAction assign(final RandomAction.enum_type otherValue){
return assign( new RandomAction(otherValue) );
}

//originally operator=
public RandomAction assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `RandomAction'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final RandomAction otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof RandomAction) {
return operatorEquals( (RandomAction) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.RandomAction.");
}
}

//originally operator==
public boolean operatorEquals(final RandomAction.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final RandomAction otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final RandomAction.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final RandomAction.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final RandomAction otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final RandomAction.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final RandomAction otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final RandomAction.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final RandomAction otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final RandomAction.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final RandomAction otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type RandomAction. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type RandomAction. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final RandomAction.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final RandomAction enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("read__out".equals(strPar) || "read_out".equals(strPar)) {
return enum_type.read__out;
}
if ("seed".equals(strPar)) {
return enum_type.seed;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.RandomAction.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.RandomAction.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class RandomAction_template extends Base_Template {
// single_value
private RandomAction.enum_type single_value;
// value_list part
private ArrayList<RandomAction_template> value_list;

private void copy_template(final RandomAction_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<RandomAction_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final RandomAction_template temp = new RandomAction_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type RandomAction.");
}
}

public RandomAction_template() {
}

public RandomAction_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public RandomAction_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!RandomAction.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type RandomAction with unknown numeric value "+ otherValue +".");
}
single_value = RandomAction.enum_type.getValue(otherValue);
}

public RandomAction_template(final RandomAction otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == RandomAction.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type RandomAction. ");
}
single_value = otherValue.enum_value;
}

public RandomAction_template(final RandomAction_template otherValue) {
copy_template(otherValue);
}

public RandomAction_template(final RandomAction.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != RandomAction.enum_type.UNBOUND_VALUE;
}

//originally operator=
public RandomAction_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public RandomAction_template assign(final int otherValue) {
if (!RandomAction.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type RandomAction.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public RandomAction_template assign(final RandomAction.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public RandomAction_template assign(final RandomAction_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public RandomAction_template assign(final RandomAction otherValue){
if (otherValue.enum_value == RandomAction.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type RandomAction to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public RandomAction_template assign(final Base_Type otherValue){
if( otherValue instanceof RandomAction ) {
return assign((RandomAction) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction' can not be cast to {1}", otherValue));
}

@Override
public RandomAction_template assign(final Base_Template otherValue){
if( otherValue instanceof RandomAction_template ) {
return assign((RandomAction_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final RandomAction.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final RandomAction.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type RandomAction.");
}
}

// originally match
public boolean match(final RandomAction otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final RandomAction otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof RandomAction ) {
return match((RandomAction) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `RandomAction' can not be cast to {1}", otherValue));
}

public RandomAction valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type RandomAction.");
}
return new RandomAction(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type RandomAction.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<RandomAction_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new RandomAction_template());
}
}

public RandomAction_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type RandomAction.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type RandomAction.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type RandomAction.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(RandomAction.enum2str(single_value), RandomAction.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof RandomAction) {
log_match((RandomAction)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.RandomAction.");
}
public void log_match(final RandomAction match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.RandomAction.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!RandomAction.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.RandomAction.", temp));
}
single_value = RandomAction.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<RandomAction_template>(size);
for(int i = 0; i < size; i++) {
final RandomAction_template temp = new RandomAction_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.RandomAction.");
}
}
}
public static void RandomAction_encoder(final RandomAction input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(RandomAction_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger RandomAction_decoder( final TitanOctetString input_stream, final RandomAction output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.RandomAction' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(RandomAction_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Proc__port__in_msgid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Proc__port__in_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Proc__port__in_msgid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Proc__port__in_msgid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class ExecutorComponent extends Base_Type {
		private final ExecutorComponent_reason reason; //TTCN3_Enumerated_Type
		private final Optional<TitanInteger> compref; //Integer_Type

		public ExecutorComponent() {
			reason = new ExecutorComponent_reason();
			compref = new Optional<TitanInteger>(TitanInteger.class);
		}

		public ExecutorComponent( final ExecutorComponent_reason aReason, final Optional<TitanInteger> aCompref ) {
			reason = new ExecutorComponent_reason( aReason );
			compref = new Optional<TitanInteger>(TitanInteger.class);
			this.compref.assign( aCompref );
		}

		public ExecutorComponent( final ExecutorComponent aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.ExecutorComponent.");
			}
			reason = new ExecutorComponent_reason();
			compref = new Optional<TitanInteger>(TitanInteger.class);
			assign( aOtherValue );
		}
		public ExecutorComponent assign(final ExecutorComponent aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.ExecutorComponent");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getReason().isBound() ) {
					this.reason.assign( aOtherValue.getReason() );
				} else {
					this.reason.cleanUp();
				}
				if ( aOtherValue.getCompref().isBound() ) {
					this.compref.assign( aOtherValue.getCompref() );
				} else {
					this.compref.cleanUp();
				}
			}

			return this;
		}

		@Override
		public ExecutorComponent assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorComponent ) {
				return assign((ExecutorComponent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorComponent", otherValue));
		}

		public void cleanUp() {
			reason.cleanUp();
			compref.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( reason.isBound() ) { return true; }
			if ( optional_sel.OPTIONAL_OMIT.equals(compref.get_selection()) || compref.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !reason.isValue() ) { return false; }
			if ( !optional_sel.OPTIONAL_OMIT.equals(compref.get_selection()) && !compref.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final ExecutorComponent aOtherValue ) {
			if ( !this.reason.operatorEquals( aOtherValue.reason ) ) { return false; }
			if ( !this.compref.operatorEquals( aOtherValue.compref ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorComponent ) {
				return operatorEquals((ExecutorComponent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.ExecutorComponent", otherValue));
		}

		public ExecutorComponent_reason getReason() {
			return reason;
		}

		public ExecutorComponent_reason constGetReason() {
			return reason;
		}

		public Optional<TitanInteger> getCompref() {
			return compref;
		}

		public Optional<TitanInteger> constGetCompref() {
			return compref;
		}

		public TitanInteger sizeOf() {
			int sizeof = 1;
			if (compref.isPresent()) {
				sizeof++;
			}
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" reason := ");
			reason.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" compref := ");
			compref.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (reason.isBound()) {
				reason.set_implicit_omit();
			}
			if (compref.isBound()) {
				compref.set_implicit_omit();
			} else {
				compref.assign(template_sel.OMIT_VALUE);
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			reason.encode_text(text_buf);
			compref.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			reason.decode_text(text_buf);
			compref.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class ExecutorComponent_template extends Base_Template {

	private ExecutorComponent_reason_template reason; //TTCN3_Enumerated_Type
	private TitanInteger_template compref; //Integer_Type
	//originally value_list/list_value
	List<ExecutorComponent_template> list_value;

	public ExecutorComponent_reason_template getReason() {
		setSpecific();
		return reason;
	}

	public ExecutorComponent_reason_template constGetReason() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field reason of a non-specific template of type @TitanLoggerApi.ExecutorComponent.");
		}
		return reason;
	}

	public TitanInteger_template getCompref() {
		setSpecific();
		return compref;
	}

	public TitanInteger_template constGetCompref() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field compref of a non-specific template of type @TitanLoggerApi.ExecutorComponent.");
		}
		return compref;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			reason = new ExecutorComponent_reason_template();
			compref = new TitanInteger_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				reason.assign(template_sel.ANY_VALUE);
				compref.assign(template_sel.ANY_OR_OMIT);
			}
		}
	}

	public ExecutorComponent_template() {
	}

	public ExecutorComponent_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public ExecutorComponent_template( final ExecutorComponent otherValue ) {
		copyValue(otherValue);
	}

	public ExecutorComponent_template( final ExecutorComponent_template otherValue ) {
		copyTemplate( otherValue );
	}

	public ExecutorComponent_template( final Optional<ExecutorComponent> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.ExecutorComponent from an unbound optional field.");
		}
	}

	//originally operator=
	public ExecutorComponent_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public ExecutorComponent_template assign( final ExecutorComponent other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public ExecutorComponent_template assign( final ExecutorComponent_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public ExecutorComponent_template assign(final Base_Type otherValue) {
			if (otherValue instanceof ExecutorComponent) {
				return assign((ExecutorComponent) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent' can not be cast to {1}", otherValue));
		}

		@Override
		public ExecutorComponent_template assign(final Base_Template otherValue) {
			if (otherValue instanceof ExecutorComponent_template) {
				return assign((ExecutorComponent_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent' can not be cast to {1}_template", otherValue));
		}

	public ExecutorComponent_template assign( final Optional<ExecutorComponent> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.ExecutorComponent.");
		}
		return this;
	}

	private void copyValue(final ExecutorComponent other_value) {
		if (other_value.getReason().isBound()) {
			getReason().assign(other_value.getReason());
		} else {
			getReason().cleanUp();
		}
		if (other_value.getCompref().isBound()) {
			if (other_value.getCompref().isPresent()) {
				getCompref().assign(other_value.getCompref().get());
			} else {
				getCompref().assign(template_sel.OMIT_VALUE);
			}
		} else {
			getCompref().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final ExecutorComponent_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getReason().get_selection()) {
				getReason().cleanUp();
			} else {
				getReason().assign(other_value.getReason());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getCompref().get_selection()) {
				getCompref().cleanUp();
			} else {
				getCompref().assign(other_value.getCompref());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<ExecutorComponent_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final ExecutorComponent_template temp = new ExecutorComponent_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.ExecutorComponent.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public ExecutorComponent valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.ExecutorComponent.");
			}
			final ExecutorComponent ret_val = new ExecutorComponent();
			 if (reason.isBound()) {
				ret_val.reason.assign(reason.valueOf());
			}
			if (compref.isOmit()) {
				ret_val.compref.assign(template_sel.OMIT_VALUE);
			} else if (compref.isBound()) {
				ret_val.compref.assign(compref.valueOf());
			}
			return ret_val;
		}

		public ExecutorComponent_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.ExecutorComponent.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.ExecutorComponent.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.ExecutorComponent.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<ExecutorComponent_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new ExecutorComponent_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (reason.isBound()) {
				return true;
			}
			if (compref.isOmit() || compref.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!reason.isValue()) {
				return false;
			}
			if (!compref.isOmit() && !compref.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final ExecutorComponent other_value) {
			return match(other_value, false);
		}

		public boolean match(final ExecutorComponent other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getReason().isBound()) {
					return false;
				}
				if(!reason.match(other_value.getReason(), legacy)) {
					return false;
				}
				if(!other_value.getCompref().isBound()) {
					return false;
				}
				if((other_value.getCompref().isPresent() ? !compref.match(other_value.getCompref().get(), legacy) : !compref.match_omit(legacy))) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof ExecutorComponent) {
		return match((ExecutorComponent)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type ExecutorComponent.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 1;
				if (compref.isPresent()) {
					sizeof++;
				}
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.ExecutorComponent containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" reason := ");
				reason.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" compref := ");
				compref.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final ExecutorComponent match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof ExecutorComponent) {
				log_match((ExecutorComponent)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorComponent.");
		}

		public void log_match(final ExecutorComponent match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !reason.match(match_value.constGetReason(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".reason");
							reason.log_match(match_value.constGetReason(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if (match_value.constGetCompref().isPresent()) {
							if( !compref.match(match_value.constGetCompref().get(), legacy) ) {
								TTCN_Logger.log_logmatch_info(".compref");
								compref.log_match(match_value.constGetCompref().get(), legacy);
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						} else {
							if (!compref.match_omit(legacy)) {
								TTCN_Logger.log_logmatch_info(".compref := omit with ");
							TTCN_Logger.print_logmatch_buffer();
								compref.log();
								TTCN_Logger.log_event_str(" unmatched");
								TTCN_Logger.set_logmatch_buffer_len(previous_size);
							}
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ reason := ");
				reason.log_match(match_value.constGetReason(), legacy);
				TTCN_Logger.log_event_str("{ compref := ");
				compref.log_match(match_value.constGetCompref(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason.encode_text(text_buf);
				compref.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				reason = new ExecutorComponent_reason_template();
				reason.decode_text(text_buf);
				compref = new TitanInteger_template();
				compref.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<ExecutorComponent_template>(size);
				for(int i = 0; i < size; i++) {
					final ExecutorComponent_template temp = new ExecutorComponent_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.ExecutorComponent.");
			}
		}
}
public static void ExecutorComponent_encoder(final ExecutorComponent input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorComponent_decoder( final TitanOctetString input_stream, final ExecutorComponent output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorComponent_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void PTC__exit_pid_encoder(final TitanInteger input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(PTC__exit_pid_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger PTC__exit_pid_decoder( final TitanOctetString input_stream, final TitanInteger output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `integer' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(PTC__exit_pid_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static void Msg__port__recv_sys__name_encoder(final TitanCharString input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(Msg__port__recv_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger Msg__port__recv_sys__name_decoder( final TitanOctetString input_stream, final TitanCharString output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `charstring' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(Msg__port__recv_sys__name_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

	public static class TitanLog_sequence__list_0 extends Base_Type {
		private final ComponentIDType entityId; //Referenced_Type
		private final TitanLog_sequence__list_0_event__list event__list; //SequenceOf_Type

		public TitanLog_sequence__list_0() {
			entityId = new ComponentIDType();
			event__list = new TitanLog_sequence__list_0_event__list();
		}

		public TitanLog_sequence__list_0( final ComponentIDType aEntityId, final TitanLog_sequence__list_0_event__list aEvent__list ) {
			entityId = new ComponentIDType( aEntityId );
			event__list = new TitanLog_sequence__list_0_event__list( aEvent__list );
		}

		public TitanLog_sequence__list_0( final TitanLog_sequence__list_0 aOtherValue ) {
			if(!aOtherValue.isBound()) {
				throw new TtcnError("Copying of an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			entityId = new ComponentIDType();
			event__list = new TitanLog_sequence__list_0_event__list();
			assign( aOtherValue );
		}
		public TitanLog_sequence__list_0 assign(final TitanLog_sequence__list_0 aOtherValue ) {
			if ( !aOtherValue.isBound() ) {
				throw new TtcnError( "Assignment of an unbound value of type @TitanLoggerApi.TitanLog.sequence_list.oftype");
			}

			if (aOtherValue != this) {
				if ( aOtherValue.getEntityId().isBound() ) {
					this.entityId.assign( aOtherValue.getEntityId() );
				} else {
					this.entityId.cleanUp();
				}
				if ( aOtherValue.getEvent__list().isBound() ) {
					this.event__list.assign( aOtherValue.getEvent__list() );
				} else {
					this.event__list.cleanUp();
				}
			}

			return this;
		}

		@Override
		public TitanLog_sequence__list_0 assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0 ) {
				return assign((TitanLog_sequence__list_0) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype", otherValue));
		}

		public void cleanUp() {
			entityId.cleanUp();
			event__list.cleanUp();
		}

		@Override
		public boolean isBound() {
			if ( entityId.isBound() ) { return true; }
			if ( event__list.isBound() ) { return true; }
			return false;
		}

		@Override
		public boolean isPresent() {
			return isBound();
		}

		@Override
		public boolean isValue() {
			if ( !entityId.isValue() ) { return false; }
			if ( !event__list.isValue() ) { return false; }
			return true;
		}

		public boolean operatorEquals( final TitanLog_sequence__list_0 aOtherValue ) {
			if ( !this.entityId.operatorEquals( aOtherValue.entityId ) ) { return false; }
			if ( !this.event__list.operatorEquals( aOtherValue.event__list ) ) { return false; }
			return true;
		}

		@Override
		public boolean operatorEquals(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0 ) {
				return operatorEquals((TitanLog_sequence__list_0) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `{0}'' can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype", otherValue));
		}

		public ComponentIDType getEntityId() {
			return entityId;
		}

		public ComponentIDType constGetEntityId() {
			return entityId;
		}

		public TitanLog_sequence__list_0_event__list getEvent__list() {
			return event__list;
		}

		public TitanLog_sequence__list_0_event__list constGetEvent__list() {
			return event__list;
		}

		public TitanInteger sizeOf() {
			int sizeof = 2;
			return new TitanInteger(sizeof);
		}
		public void log() {
			if (!isBound()) {
				TTCN_Logger.log_event_unbound();
				return;
			}
			TTCN_Logger.log_char('{');
			TTCN_Logger.log_event_str(" entityId := ");
			entityId.log();
			TTCN_Logger.log_char(',');
			TTCN_Logger.log_event_str(" event_list := ");
			event__list.log();
			TTCN_Logger.log_event_str(" }");
		}
		@Override
		public void set_implicit_omit() {
			if (entityId.isBound()) {
				entityId.set_implicit_omit();
			}
			if (event__list.isBound()) {
				event__list.set_implicit_omit();
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			entityId.encode_text(text_buf);
			event__list.encode_text(text_buf);
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			entityId.decode_text(text_buf);
			event__list.decode_text(text_buf);
		}
@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(false, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

	}
public static class TitanLog_sequence__list_0_template extends Base_Template {

	private ComponentIDType_template entityId; //Referenced_Type
	private TitanLog_sequence__list_0_event__list_template event__list; //SequenceOf_Type
	//originally value_list/list_value
	List<TitanLog_sequence__list_0_template> list_value;

	public ComponentIDType_template getEntityId() {
		setSpecific();
		return entityId;
	}

	public ComponentIDType_template constGetEntityId() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field entityId of a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
		}
		return entityId;
	}

	public TitanLog_sequence__list_0_event__list_template getEvent__list() {
		setSpecific();
		return event__list;
	}

	public TitanLog_sequence__list_0_event__list_template constGetEvent__list() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			throw new TtcnError("Accessing field event_list of a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
		}
		return event__list;
	}

	private void setSpecific() {
		if (templateSelection != template_sel.SPECIFIC_VALUE) {
			final template_sel old_selection = templateSelection;
			cleanUp();
			set_selection(template_sel.SPECIFIC_VALUE);
			entityId = new ComponentIDType_template();
			event__list = new TitanLog_sequence__list_0_event__list_template();
			if (old_selection == template_sel.ANY_VALUE || old_selection == template_sel.ANY_OR_OMIT) {
				entityId.assign(template_sel.ANY_VALUE);
				event__list.assign(template_sel.ANY_VALUE);
			}
		}
	}

	public TitanLog_sequence__list_0_template() {
	}

	public TitanLog_sequence__list_0_template(final template_sel other_value ) {
		super( other_value );
		checkSingleSelection( other_value );
	}

	public TitanLog_sequence__list_0_template( final TitanLog_sequence__list_0 otherValue ) {
		copyValue(otherValue);
	}

	public TitanLog_sequence__list_0_template( final TitanLog_sequence__list_0_template otherValue ) {
		copyTemplate( otherValue );
	}

	public TitanLog_sequence__list_0_template( final Optional<TitanLog_sequence__list_0> other_value ) {
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Creating a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype from an unbound optional field.");
		}
	}

	//originally operator=
	public TitanLog_sequence__list_0_template assign( final template_sel other_value ) {
		checkSingleSelection(other_value);
		cleanUp();
		set_selection(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_sequence__list_0_template assign( final TitanLog_sequence__list_0 other_value ) {
		cleanUp();
		copyValue(other_value);
		return this;
	}

	//originally operator=
	public TitanLog_sequence__list_0_template assign( final TitanLog_sequence__list_0_template other_value ) {
		if (other_value != this) {
			cleanUp();
			copyTemplate(other_value);
		}
		return this;
	}

		@Override
		public TitanLog_sequence__list_0_template assign(final Base_Type otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0) {
				return assign((TitanLog_sequence__list_0) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog_sequence__list_0' can not be cast to {1}", otherValue));
		}

		@Override
		public TitanLog_sequence__list_0_template assign(final Base_Template otherValue) {
			if (otherValue instanceof TitanLog_sequence__list_0_template) {
				return assign((TitanLog_sequence__list_0_template) otherValue);
			}

			throw new TtcnError(MessageFormat.format("Internal Error: value `TitanLog_sequence__list_0' can not be cast to {1}_template", otherValue));
		}

	public TitanLog_sequence__list_0_template assign( final Optional<TitanLog_sequence__list_0> other_value ) {
		cleanUp();
		switch (other_value.get_selection()) {
		case OPTIONAL_PRESENT:
			copyValue(other_value.constGet());
			break;
		case OPTIONAL_OMIT:
			set_selection(template_sel.OMIT_VALUE);
			break;
		default:
			throw new TtcnError("Assignment of an unbound optional field to a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
		}
		return this;
	}

	private void copyValue(final TitanLog_sequence__list_0 other_value) {
		if (other_value.getEntityId().isBound()) {
			getEntityId().assign(other_value.getEntityId());
		} else {
			getEntityId().cleanUp();
		}
		if (other_value.getEvent__list().isBound()) {
			getEvent__list().assign(other_value.getEvent__list());
		} else {
			getEvent__list().cleanUp();
		}
		set_selection(template_sel.SPECIFIC_VALUE);
	}

	private void copyTemplate(final TitanLog_sequence__list_0_template other_value) {
		switch (other_value.templateSelection) {
		case SPECIFIC_VALUE:
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEntityId().get_selection()) {
				getEntityId().cleanUp();
			} else {
				getEntityId().assign(other_value.getEntityId());
			}
			if (template_sel.UNINITIALIZED_TEMPLATE == other_value.getEvent__list().get_selection()) {
				getEvent__list().cleanUp();
			} else {
				getEvent__list().assign(other_value.getEvent__list());
			}
			break;
		case OMIT_VALUE:
		case ANY_VALUE:
		case ANY_OR_OMIT:
			break;
		case VALUE_LIST:
		case COMPLEMENTED_LIST:
			list_value = new ArrayList<TitanLog_sequence__list_0_template>(other_value.list_value.size());
			for(int i = 0; i < other_value.list_value.size(); i++) {
				final TitanLog_sequence__list_0_template temp = new TitanLog_sequence__list_0_template(other_value.list_value.get(i));
				list_value.add(temp);
			}
			break;
		default:
			throw new TtcnError("Copying an uninitialized template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
		}
		set_selection(other_value);
	}

		public boolean isPresent() {
			return isPresent(false);
		}

		public boolean isPresent(final boolean legacy) {
			return isPresent_(legacy);
		}

		private boolean isPresent_(final boolean legacy) {
			if (templateSelection==template_sel.UNINITIALIZED_TEMPLATE) {
				return false;
			}
			return !match_omit_(legacy);
		}

		public boolean match_omit() {
			return match_omit(false);
		}

		public boolean match_omit(final boolean legacy) {
			return match_omit_(legacy);
		}

		private boolean match_omit_(final boolean legacy) {
			if (is_ifPresent) {
				return true;
			}
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_OR_OMIT:
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				if (legacy) {
					for (int l_idx=0; l_idx<list_value.size(); l_idx++) {
						if (list_value.get(l_idx).match_omit_(legacy)) {
							return templateSelection==template_sel.VALUE_LIST;
						}
					}
					return templateSelection==template_sel.COMPLEMENTED_LIST;
				} // else fall through
			default:
				return false;
			}
		}

		public TitanLog_sequence__list_0 valueOf() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				throw new TtcnError("Performing a valueof or send operation on a non-specific template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			final TitanLog_sequence__list_0 ret_val = new TitanLog_sequence__list_0();
			 if (entityId.isBound()) {
				ret_val.entityId.assign(entityId.valueOf());
			}
			 if (event__list.isBound()) {
				ret_val.event__list.assign(event__list.valueOf());
			}
			return ret_val;
		}

		public TitanLog_sequence__list_0_template listItem(final int list_index) {
			if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Accessing a list element of a non-list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			if (list_index >= list_value.size()) {
				throw new TtcnError("Index overflow in a value list template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			return list_value.get(list_index);
		}

		public void setType(final template_sel template_type, final int list_length) {
			if (template_type != template_sel.VALUE_LIST && template_type != template_sel.COMPLEMENTED_LIST) {
				throw new TtcnError("Setting an invalid list for a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
			cleanUp();
			set_selection(template_type);
			list_value = new ArrayList<TitanLog_sequence__list_0_template>(list_length);
			for(int i = 0 ; i < list_length; i++) {
				list_value.add(new TitanLog_sequence__list_0_template());
			}
		}

		@Override
		public boolean isBound() {
			if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
				return false;
			}
			if (templateSelection != template_sel.SPECIFIC_VALUE) {
				return true;
			}
			if (entityId.isBound()) {
				return true;
			}
			if (event__list.isBound()) {
				return true;
			}
			return false;
		}

		@Override
		public boolean isValue() {
			if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
				return false;
			}
			if (!entityId.isValue()) {
				return false;
			}
			if (!event__list.isValue()) {
				return false;
			}
			return true;
		}

		public boolean match(final TitanLog_sequence__list_0 other_value) {
			return match(other_value, false);
		}

		public boolean match(final TitanLog_sequence__list_0 other_value, final boolean legacy) {
			if (!other_value.isBound()) {
				return false;
			}
			switch (templateSelection) {
			case ANY_VALUE:
			case ANY_OR_OMIT:
				return true;
			case OMIT_VALUE:
				return false;
			case SPECIFIC_VALUE:
				if(!other_value.getEntityId().isBound()) {
					return false;
				}
				if(!entityId.match(other_value.getEntityId(), legacy)) {
					return false;
				}
				if(!other_value.getEvent__list().isBound()) {
					return false;
				}
				if(!event__list.match(other_value.getEvent__list(), legacy)) {
					return false;
				}
				return true;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_value.get(list_count).match(other_value, legacy)) {
						return templateSelection == template_sel.VALUE_LIST;
					}
				}
				return templateSelection == template_sel.COMPLEMENTED_LIST;
			default:
				throw new TtcnError("Matching an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

	@Override
	public boolean match(final Base_Type otherValue, final boolean legacy) {
	if (otherValue instanceof TitanLog_sequence__list_0) {
		return match((TitanLog_sequence__list_0)otherValue, legacy);
	}

		throw new TtcnError("Internal Error: The left operand of assignment is not of type TitanLog_sequence__list_0.");
	}

		public TitanInteger sizeOf() {
			if (is_ifPresent) {
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype which has an ifpresent attribute.");
			}
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				int sizeof = 2;
				return new TitanInteger(sizeof);
			case VALUE_LIST:
				if (list_value.isEmpty()) {
					throw new TtcnError("Internal error: Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing an empty list.");
				}
				final int item_size = list_value.get(0).sizeOf().getInt();
				for (int l_idx = 1; l_idx < list_value.size(); l_idx++) {
					if (list_value.get(l_idx).sizeOf().getInt() != item_size) {
						throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing a value list with different sizes.");
					}
				}
				return new TitanInteger(item_size);
			case OMIT_VALUE:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing omit value.");
			case ANY_VALUE:
			case ANY_OR_OMIT:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing */? value.");
			case COMPLEMENTED_LIST:
				throw new TtcnError("Performing sizeof() operation on a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype containing complemented list.");
			default:
				throw new TtcnError("Performing sizeof() operation on an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

		public void log() {
			switch (templateSelection) {
			case SPECIFIC_VALUE:
				TTCN_Logger.log_char('{');
				TTCN_Logger.log_event_str(" entityId := ");
				entityId.log();
				TTCN_Logger.log_char(',');
				TTCN_Logger.log_event_str(" event_list := ");
				event__list.log();
				TTCN_Logger.log_event_str(" }");
				break;
			case COMPLEMENTED_LIST:
				TTCN_Logger.log_event_str("complement");
			case VALUE_LIST:
				TTCN_Logger.log_char('(');
				for (int list_count = 0; list_count < list_value.size(); list_count++) {
					if (list_count > 0) {
						TTCN_Logger.log_event_str(", ");
					}
					list_value.get(list_count).log();
				}
				TTCN_Logger.log_char(')');
				break;
			default:
				log_generic();
				break;
			}
			log_ifpresent();
		}

		public void log_match(final TitanLog_sequence__list_0 match_value) {
			log_match(match_value, false);
		}

		@Override
		public void log_match(final Base_Type match_value, final boolean legacy) {
			if (match_value instanceof TitanLog_sequence__list_0) {
				log_match((TitanLog_sequence__list_0)match_value, legacy);
				return;
			}

			throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.TitanLog.sequence_list.oftype.");
		}

		public void log_match(final TitanLog_sequence__list_0 match_value, final boolean legacy) {
			if ( TTCN_Logger.matching_verbosity_t.VERBOSITY_COMPACT == TTCN_Logger.get_matching_verbosity() ) {
				if(match(match_value, legacy)) {
					TTCN_Logger.print_logmatch_buffer();
					TTCN_Logger.log_event_str(" matched");
				} else {
					if (templateSelection == template_sel.SPECIFIC_VALUE) {
						final int previous_size = TTCN_Logger.get_logmatch_buffer_len();
						if( !entityId.match(match_value.constGetEntityId(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".entityId");
							entityId.log_match(match_value.constGetEntityId(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
						if( !event__list.match(match_value.constGetEvent__list(), legacy) ) {
							TTCN_Logger.log_logmatch_info(".event_list");
							event__list.log_match(match_value.constGetEvent__list(), legacy);
							TTCN_Logger.set_logmatch_buffer_len(previous_size);
						}
					} else {
						TTCN_Logger.print_logmatch_buffer();
						match_value.log();
						TTCN_Logger.log_event_str(" with ");
						log();
						TTCN_Logger.log_event_str(" unmatched");
					}
				}
				return;
			}
			if (templateSelection == template_sel.SPECIFIC_VALUE) {
				TTCN_Logger.log_event_str("{ entityId := ");
				entityId.log_match(match_value.constGetEntityId(), legacy);
				TTCN_Logger.log_event_str("{ event_list := ");
				event__list.log_match(match_value.constGetEvent__list(), legacy);
				TTCN_Logger.log_event_str(" }");
			} else {
				match_value.log();
				TTCN_Logger.log_event_str(" with ");
				log();
				if ( match(match_value, legacy) ) {
					TTCN_Logger.log_event_str(" matched");
				} else {
					TTCN_Logger.log_event_str(" unmatched");
				}
			}
		}

		@Override
		public void encode_text(final Text_Buf text_buf) {
			encode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId.encode_text(text_buf);
				event__list.encode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST:
				text_buf.push_int(list_value.size());
				for (int i = 0; i < list_value.size(); i++) {
					list_value.get(i).encode_text(text_buf);
				}
				break;
			default:
				throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}

		@Override
		public void decode_text(final Text_Buf text_buf) {
			cleanUp();
			decode_text_base(text_buf);
			switch (templateSelection) {
			case OMIT_VALUE:
			case ANY_VALUE:
			case ANY_OR_OMIT:
				break;
			case SPECIFIC_VALUE:
				entityId = new ComponentIDType_template();
				entityId.decode_text(text_buf);
				event__list = new TitanLog_sequence__list_0_event__list_template();
				event__list.decode_text(text_buf);
				break;
			case VALUE_LIST:
			case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
				list_value = new ArrayList<TitanLog_sequence__list_0_template>(size);
				for(int i = 0; i < size; i++) {
					final TitanLog_sequence__list_0_template temp = new TitanLog_sequence__list_0_template();
					temp.decode_text(text_buf);
					list_value.add(temp);
				}
				break;
			}
			default:
				throw new TtcnError("Text decoder: An unknown/unsupported selection was received in a template of type @TitanLoggerApi.TitanLog.sequence_list.oftype.");
			}
		}
}
public static void TitanLog_sequence__list_0_encoder(final TitanLog_sequence__list_0 input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(TitanLog_sequence__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger TitanLog_sequence__list_0_decoder( final TitanOctetString input_stream, final TitanLog_sequence__list_0 output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.TitanLog.sequence_list.oftype' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(TitanLog_sequence__list_0_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public static class ExecutorComponent_reason extends Base_Type {
public enum enum_type {
mtc__started (0),
mtc__finished (1),
ptc__started (2),
ptc__finished (3),
component__init__fail (4),
UNKNOWN_VALUE(5),
UNBOUND_VALUE(6);

 private int enum_num;
enum_type(final int num) {
this.enum_num = num;
}

private int getInt() {
return enum_num;
}

public static enum_type getValue(final int index) {
switch (index) {
case 0:  return mtc__started;
case 1:  return mtc__finished;
case 2:  return ptc__started;
case 3:  return ptc__finished;
case 4:  return component__init__fail;
case 5:  return UNKNOWN_VALUE;
case 6:  return UNBOUND_VALUE;
default:
return null;
}
}

}

public enum_type enum_value;
//===Constructors===;
public ExecutorComponent_reason() {
enum_value = enum_type.UNBOUND_VALUE;
}

public ExecutorComponent_reason(final ExecutorComponent_reason otherValue) {
enum_value = otherValue.enum_value;
}

public ExecutorComponent_reason(final ExecutorComponent_reason.enum_type otherValue ) {
enum_value = otherValue;
}

public ExecutorComponent_reason(final int otherValue) {
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Initializing a variable of enumerated type `ExecutorComponent_reason' with invalid numeric value {1} .", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
}

//===Methods===;
//originally operator=
public ExecutorComponent_reason assign(final ExecutorComponent_reason otherValue){
otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
this.enum_value = otherValue.enum_value;
}

return this;
}

@Override
public ExecutorComponent_reason assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorComponent_reason ) {
return assign((ExecutorComponent_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason' can not be cast to {1}", otherValue));
}

//originally operator=
public ExecutorComponent_reason assign(final ExecutorComponent_reason.enum_type otherValue){
return assign( new ExecutorComponent_reason(otherValue) );
}

//originally operator=
public ExecutorComponent_reason assign(final int otherValue){
if (!isValidEnum(otherValue)) {
throw new TtcnError(MessageFormat.format("Assigning unknown numeric value {1} to a variable of enumerated type `ExecutorComponent_reason'.", otherValue));
}

enum_value =  enum_type.getValue(otherValue);
return this;
}

//originally operator==
public boolean operatorEquals(final ExecutorComponent_reason otherValue){
return enum_value == otherValue.enum_value;
}

//originally operator==
public boolean operatorEquals(final Base_Type otherValue){
if (otherValue instanceof ExecutorComponent_reason) {
return operatorEquals( (ExecutorComponent_reason) otherValue);
} else {
throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorComponent.reason.");
}
}

//originally operator==
public boolean operatorEquals(final ExecutorComponent_reason.enum_type otherValue){
return enum_value == otherValue;
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorComponent_reason otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final Base_Type otherValue){
return !operatorEquals(otherValue);
}

//originally operator!=
public boolean operatorNotEquals(final ExecutorComponent_reason.enum_type otherValue){
return !operatorEquals(otherValue);
}

// originally operator<
public boolean isLessThan(final ExecutorComponent_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return enum_value.enum_num < otherValue.enum_num;
}

// originally operator<
public boolean isLessThan(final ExecutorComponent_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return  enum_value.enum_num < otherValue.enum_value.enum_num ;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorComponent_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return enum_value.enum_num <= otherValue.enum_num;
}

// originally operator<=
public boolean isLessThanOrEqual(final ExecutorComponent_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return  enum_value.enum_num <= otherValue.enum_value.enum_num ;
}

// originally operator>
public boolean isGreaterThan(final ExecutorComponent_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return enum_value.enum_num > otherValue.enum_num;
}

// originally operator>
public boolean isGreaterThan(final ExecutorComponent_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return  enum_value.enum_num > otherValue.enum_value.enum_num ;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorComponent_reason.enum_type otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return enum_value.enum_num >= otherValue.enum_num;
}

// originally operator>=
public boolean isGreaterThanOrEqual(final ExecutorComponent_reason otherValue){
if (this.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The left operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
if (otherValue.enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("The right operand of comparison is an unbound value of enumerated type ExecutorComponent_reason. ");
}
return  enum_value.enum_num >= otherValue.enum_value.enum_num ;
}

@Override
public boolean isPresent() {
return isBound();
}

@Override
public boolean isBound() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void mustBound(final String errorMessage) {
if ( !isBound() ) {
throw new TtcnError( errorMessage );
}
}

@Override
public boolean isValue() {
return enum_value != enum_type.UNBOUND_VALUE;
}

public void cleanUp() {
enum_value = enum_type.UNBOUND_VALUE;
}

public static boolean isValidEnum(final int otherValue) {
final enum_type helper =  enum_type.getValue(otherValue);
return helper != null && helper != enum_type.UNKNOWN_VALUE && helper != enum_type.UNBOUND_VALUE ;
}

public void int2enum(final int intValue) {
if (!isValidEnum(intValue)) {
throw new TtcnError("Assigning invalid numeric value "+intValue+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue);
}

public void int2enum(final TitanInteger intValue) {
if (!isValidEnum(intValue.getInt())) {
throw new TtcnError("Assigning invalid numeric value "+intValue.getInt()+" to a variable of enumerated type {}.");
	}
enum_value = enum_type.getValue(intValue.getInt());
}

public static int enum2int(final ExecutorComponent_reason.enum_type enumPar) {
if (enumPar == enum_type.UNBOUND_VALUE || enumPar == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_num;
}

public static int enum2int(final ExecutorComponent_reason enumPar) {
if (enumPar.enum_value == enum_type.UNBOUND_VALUE || enumPar.enum_value == enum_type.UNKNOWN_VALUE) {
throw new TtcnError("The argument of function enum2int() is an "+ (enumPar.enum_value==enum_type.UNBOUND_VALUE ? "unbound":"invalid") +" value of enumerated type {0}.");
}
return enumPar.enum_value.enum_num;
}

public static enum_type str_to_enum(final String strPar) {
if ("mtc__started".equals(strPar) || "mtc_started".equals(strPar)) {
return enum_type.mtc__started;
}
if ("mtc__finished".equals(strPar) || "mtc_finished".equals(strPar)) {
return enum_type.mtc__finished;
}
if ("ptc__started".equals(strPar) || "ptc_started".equals(strPar)) {
return enum_type.ptc__started;
}
if ("ptc__finished".equals(strPar) || "ptc_finished".equals(strPar)) {
return enum_type.ptc__finished;
}
if ("component__init__fail".equals(strPar) || "component_init_fail".equals(strPar)) {
return enum_type.component__init__fail;
}
return enum_type.UNKNOWN_VALUE;
}

public static String enum2str(final enum_type enumPar) {
	return enumPar.name();
}

//originally int as_int()
public int asInt() {
return enum2int(enum_value);
}

public void fromInt(final int otherValue) {
enum_value = enum_type.getValue(otherValue);
}

/** 
 * Do not use this function!<br>
 * It is provided by Java and currently used for debugging.
 * But it is not part of the intentionally provided interface,
 *   and so can be changed without notice. 
 * <p>
 * JAVA DESCRIPTION:
 * <p>
 * {@inheritDoc}
 *  */
public String toString() {
return enum_value.name() + "("+enum_value.enum_num+")";
}

public void log() {
if (enum_value == enum_type.UNBOUND_VALUE) {
TTCN_Logger.log_event_unbound();
} else {
TTCN_Logger.log_event_enum(enum2str(enum_value), enum2int(enum_value));
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
if (enum_value == enum_type.UNBOUND_VALUE) {
throw new TtcnError("Text encoder: Encoding an unbound value of enumerated type @TitanLoggerApi.ExecutorComponent.reason.");
}
text_buf.push_int(enum_value.enum_num);
}

@Override
public void decode_text(final Text_Buf text_buf) {
final int temp = text_buf.pull_int().getInt();
if (!isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorComponent.reason.", temp));
}
int2enum(temp);
}

@Override
public void encode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-encoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
final RAW_enc_tr_pos rp = new RAW_enc_tr_pos(0, null);
final RAW_enc_tree root = new RAW_enc_tree(true, null, rp, 1, p_td.raw);
RAW_encode(p_td, root);
root.put_to_buf(p_buf);
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to encode type `{0}''", p_td.name));
}
}

@Override
public void decode(final TTCN_Typedescriptor p_td, final TTCN_Buffer p_buf, final coding_type p_coding, final int flavour) {
switch (p_coding) {
case CT_RAW: {
final TTCN_EncDec_ErrorContext errorContext = new TTCN_EncDec_ErrorContext("While RAW-decoding type '%s': ", p_td.name);
if (p_td.raw == null) {
TTCN_EncDec_ErrorContext.error_internal("No RAW descriptor available for type '%s'.", p_td.name);
}
raw_order_t order;
switch (p_td.raw.top_bit_order) {
case TOP_BIT_LEFT:
order = raw_order_t.ORDER_LSB;
break;
case TOP_BIT_RIGHT:
default:
order = raw_order_t.ORDER_MSB;
break;
}
final int rawr = RAW_decode(p_td, p_buf, p_buf.get_len() * 8, order);
if (rawr < 0) {
final error_type temp = error_type.values()[-rawr];
switch (temp) {
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
TTCN_EncDec_ErrorContext.error(temp, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
case ET_UNBOUND:
default:
TTCN_EncDec_ErrorContext.error(error_type.ET_INVAL_MSG, "Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
break;
}
}
errorContext.leaveContext();
break;
}
default:
throw new TtcnError(MessageFormat.format("Unknown coding method requested to decode type `{0}''", p_td.name));
}
}

}
public static class ExecutorComponent_reason_template extends Base_Template {
// single_value
private ExecutorComponent_reason.enum_type single_value;
// value_list part
private ArrayList<ExecutorComponent_reason_template> value_list;

private void copy_template(final ExecutorComponent_reason_template otherValue) {
set_selection(otherValue);switch (otherValue.templateSelection) {
case SPECIFIC_VALUE:
single_value = otherValue.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list = new ArrayList<ExecutorComponent_reason_template>(otherValue.value_list.size());
for(int i = 0; i < otherValue.value_list.size(); i++) {
final ExecutorComponent_reason_template temp = new ExecutorComponent_reason_template(otherValue.value_list.get(i));
value_list.add(temp);
}
break;
default:
throw new TtcnError("Copying an uninitialized/unsupported template of enumerated type ExecutorComponent_reason.");
}
}

public ExecutorComponent_reason_template() {
}

public ExecutorComponent_reason_template(final template_sel otherValue) {
super(otherValue);
checkSingleSelection(otherValue);
}

public ExecutorComponent_reason_template(final int otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (!ExecutorComponent_reason.isValidEnum(otherValue)) {
throw new TtcnError("Initializing a template of enumerated type ExecutorComponent_reason with unknown numeric value "+ otherValue +".");
}
single_value = ExecutorComponent_reason.enum_type.getValue(otherValue);
}

public ExecutorComponent_reason_template(final ExecutorComponent_reason otherValue) {
super(template_sel.SPECIFIC_VALUE);
if (otherValue.enum_value == ExecutorComponent_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Creating a template from an unbound value of enumerated type ExecutorComponent_reason. ");
}
single_value = otherValue.enum_value;
}

public ExecutorComponent_reason_template(final ExecutorComponent_reason_template otherValue) {
copy_template(otherValue);
}

public ExecutorComponent_reason_template(final ExecutorComponent_reason.enum_type otherValue) {
super(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
}

public void cleanUp() {
if (templateSelection == template_sel.VALUE_LIST || templateSelection == template_sel.COMPLEMENTED_LIST) {
value_list.clear();
value_list = null;
}
if (templateSelection == template_sel.SPECIFIC_VALUE) {
single_value = null;
}
templateSelection = template_sel.UNINITIALIZED_TEMPLATE;
}

public boolean isBound() {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE && !is_ifPresent) {
return false;
}
return true;
}

public boolean isValue() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
return false;
}
return single_value != ExecutorComponent_reason.enum_type.UNBOUND_VALUE;
}

//originally operator=
public ExecutorComponent_reason_template assign(final template_sel otherValue) {
checkSingleSelection(otherValue);
cleanUp();
set_selection(otherValue);
return this;
}

//originally operator=
public ExecutorComponent_reason_template assign(final int otherValue) {
if (!ExecutorComponent_reason.isValidEnum(otherValue)) {
throw new TtcnError("Assigning unknown numeric value " + otherValue + " to a template of enumerated type ExecutorComponent_reason.");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
return this;
}

//originally operator=
public ExecutorComponent_reason_template assign(final ExecutorComponent_reason.enum_type otherValue){
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue;
return this;
}

//originally operator=
public ExecutorComponent_reason_template assign(final ExecutorComponent_reason_template otherValue){
// otherValue.mustBound("Assignment of an unbound enumerated value");

if (otherValue != this) {
cleanUp();
copy_template(otherValue);
}
return this;
}

//originally operator=
public ExecutorComponent_reason_template assign(final ExecutorComponent_reason otherValue){
if (otherValue.enum_value == ExecutorComponent_reason.enum_type.UNBOUND_VALUE) {
throw new TtcnError("Assignment of an unbound value of enumerated type ExecutorComponent_reason to a template. ");
}
cleanUp();
set_selection(template_sel.SPECIFIC_VALUE);
single_value = otherValue.enum_value;
return this;
}

@Override
public ExecutorComponent_reason_template assign(final Base_Type otherValue){
if( otherValue instanceof ExecutorComponent_reason ) {
return assign((ExecutorComponent_reason) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason' can not be cast to {1}", otherValue));
}

@Override
public ExecutorComponent_reason_template assign(final Base_Template otherValue){
if( otherValue instanceof ExecutorComponent_reason_template ) {
return assign((ExecutorComponent_reason_template) otherValue);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason'_template can not be cast to {1}", otherValue));
}

// originally match
public boolean match(final ExecutorComponent_reason.enum_type otherValue) {
return match(otherValue, false);
}

// originally match
public boolean match(final ExecutorComponent_reason.enum_type otherValue, final boolean legacy) {
switch (templateSelection) {
case SPECIFIC_VALUE:
return single_value == otherValue;
case OMIT_VALUE:
return false;
case ANY_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(int i = 0 ; i < value_list.size(); i++) {
if(value_list.get(i).match(otherValue)) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
default:
throw new TtcnError("Matching with an uninitialized/unsupported template of enumerated type ExecutorComponent_reason.");
}
}

// originally match
public boolean match(final ExecutorComponent_reason otherValue) {
return match(otherValue.enum_value, false);
}

// originally match
public boolean match(final ExecutorComponent_reason otherValue, final boolean legacy) {
return match(otherValue.enum_value, false);
}

@Override
public boolean match(final Base_Type otherValue, final boolean legacy){
if( otherValue instanceof ExecutorComponent_reason ) {
return match((ExecutorComponent_reason) otherValue, legacy);
}

throw new TtcnError(MessageFormat.format("Internal Error: value `ExecutorComponent_reason' can not be cast to {1}", otherValue));
}

public ExecutorComponent_reason valueOf() {
if (templateSelection != template_sel.SPECIFIC_VALUE || is_ifPresent) {
throw new TtcnError("Performing a valueof or send operation on a non-specific template of enumerated type ExecutorComponent_reason.");
}
return new ExecutorComponent_reason(single_value);
}

public void setType(final template_sel templateType, final int list_length) {
if (templateType != template_sel.VALUE_LIST && templateType != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Setting an invalid list type for a template of enumerated type ExecutorComponent_reason.");
}
cleanUp();
set_selection(templateType);
value_list = new ArrayList<ExecutorComponent_reason_template>();
for(int i = 0 ; i < list_length; i++) {
value_list.add(new ExecutorComponent_reason_template());
}
}

public ExecutorComponent_reason_template listItem(final int list_index) {
if (templateSelection != template_sel.VALUE_LIST && templateSelection != template_sel.COMPLEMENTED_LIST) {
throw new TtcnError("Accessing a list element of a non-list template of enumerated type ExecutorComponent_reason.");
}
if (list_index < 0) {
throw new TtcnError("Index underflow in a value list template of enumerated type ExecutorComponent_reason.");
}
if(list_index >= value_list.size()) {
throw new TtcnError("Index overflow in a value list template of enumerated type ExecutorComponent_reason.");
}
return value_list.get(list_index);
}

public boolean isPresent() {
return isPresent(false);
}

public boolean isPresent(final boolean legacy) {
if (templateSelection == template_sel.UNINITIALIZED_TEMPLATE) {
return false;
}
return !match_omit(legacy);
}

public boolean match_omit() {
return match_omit(false);
}

public boolean match_omit(final boolean legacy) {
if (is_ifPresent) {
return true;
}
switch (templateSelection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return true;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (int i = 0 ; i < value_list.size(); i++) {
if (value_list.get(i).match_omit()) {
return templateSelection == template_sel.VALUE_LIST;
}
}
return templateSelection == template_sel.COMPLEMENTED_LIST;
}
default:
return false;
}
}

public void log() {
switch (templateSelection) {
case SPECIFIC_VALUE:
TTCN_Logger.log_event_enum(ExecutorComponent_reason.enum2str(single_value), ExecutorComponent_reason.enum2int(single_value));
break;
case COMPLEMENTED_LIST:
TTCN_Logger.log_event_str("complement");
case VALUE_LIST:
TTCN_Logger.log_char('(');
for (int list_count = 0; list_count < value_list.size(); list_count++) {
if (list_count > 0) {
TTCN_Logger.log_event_str(", ");
}
value_list.get(list_count).log();
}
TTCN_Logger.log_char(')');
break;
default:
log_generic();
break;
}
log_ifpresent();
}
@Override
public void log_match(final Base_Type match_value, final boolean legacy) {
if (match_value instanceof ExecutorComponent_reason) {
log_match((ExecutorComponent_reason)match_value, legacy);
return;
}

		throw new TtcnError("Internal Error: value can not be cast to @TitanLoggerApi.ExecutorComponent.reason.");
}
public void log_match(final ExecutorComponent_reason match_value, final boolean legacy){
match_value.log();
TTCN_Logger.log_event_str(" with ");
log();
if (match(match_value, legacy)) {
TTCN_Logger.log_event_str(" matched");
} else {
TTCN_Logger.log_event_str(" unmatched");
}
}

@Override
public void encode_text(final Text_Buf text_buf) {
encode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:
text_buf.push_int(single_value.getInt());
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.size());
for (int i = 0; i < value_list.size(); i++) {
value_list.get(i).encode_text(text_buf);
}
break;
default:
throw new TtcnError("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @TitanLoggerApi.ExecutorComponent.reason.");
}
}

@Override
public void decode_text(final Text_Buf text_buf) {
cleanUp();
decode_text_base(text_buf);
switch (templateSelection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case SPECIFIC_VALUE:{
final int temp = text_buf.pull_int().getInt();
if (!ExecutorComponent_reason.isValidEnum(temp)) {
throw new TtcnError(MessageFormat.format("Text decoder: Unknown numeric value {0} was received for enumerated type @TitanLoggerApi.ExecutorComponent.reason.", temp));
}
single_value = ExecutorComponent_reason.enum_type.values()[temp];
break;
}
case VALUE_LIST:
case COMPLEMENTED_LIST: {
final int size = text_buf.pull_int().getInt();
value_list = new ArrayList<ExecutorComponent_reason_template>(size);
for(int i = 0; i < size; i++) {
final ExecutorComponent_reason_template temp = new ExecutorComponent_reason_template();
temp.decode_text(text_buf);
value_list.add(temp);
}
break;
}
default:
throw new TtcnError("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @TitanLoggerApi.ExecutorComponent.reason.");
}
}
}
public static void ExecutorComponent_reason_encoder(final ExecutorComponent_reason input_value, final TitanOctetString output_stream, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, true);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer();
input_value.encode(ExecutorComponent_reason_descr_, ttcnBuffer, codingType, extra_options.get());
ttcnBuffer.get_string(output_stream);
}

public static TitanInteger ExecutorComponent_reason_decoder( final TitanOctetString input_stream, final ExecutorComponent_reason output_value, final TitanUniversalCharString coding_name) {
final AtomicInteger extra_options = new AtomicInteger(0);
final TTCN_EncDec.coding_type codingType = TTCN_EncDec.get_coding_from_str(coding_name, extra_options, false);
if (codingType != TTCN_EncDec.coding_type.CT_XER) {
TTCN_Logger.begin_event_log2str();
coding_name.log();
throw new TtcnError(MessageFormat.format("Type `@TitanLoggerApi.ExecutorComponent.reason' does not support {0} encoding", TTCN_Logger.end_event_log2str()));
}
final TTCN_Buffer ttcnBuffer = new TTCN_Buffer(input_stream);
output_value.decode(ExecutorComponent_reason_descr_, ttcnBuffer, codingType, extra_options.get());
switch (TTCN_EncDec.get_last_error_type()) {
case ET_NONE:
ttcnBuffer.cut();
ttcnBuffer.get_string(input_stream);
return new TitanInteger(0);
case ET_INCOMPL_MSG:
case ET_LEN_ERR:
return new TitanInteger(2);
default:
return new TitanInteger(1);
}
}

public void pre_init_module()
{
if (pre_init_called) {
return;
}
pre_init_called = true;
final TTCN_Location current_location = TTCN_Location.enter("TitanLoggerApi.ttcn", 0, entity_type_t.LOCATION_UNKNOWN, "TitanLoggerApi");
TitanLog_sequence__list_0_event__list_descr_.oftype_descr = TitanLog_sequence__list_0_event__list_0_descr_;
TitanLog_sequence__list_descr_.oftype_descr = TitanLog_sequence__list_0_descr_;
TitanLogEvent_sourceInfo__list_descr_.oftype_descr = TitanLogEvent_sourceInfo__list_0_descr_;
Strings_str__list_descr_.oftype_descr = Strings_str__list_0_descr_;
StartFunction_parameter__list_descr_.oftype_descr = StartFunction_parameter__list_0_descr_;
current_location.leave();
}

}
